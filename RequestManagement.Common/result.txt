//IAuthService.cs
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Common.Interfaces;

/// <summary>
/// Интерфейс сервиса авторизации
/// </summary>
public interface IAuthService
{
    /// <summary>
    /// Аутентифицирует пользователя по логину и паролю
    /// </summary>
    /// <param name="login">Логин пользователя</param>
    /// <param name="password">Пароль пользователя</param>
    /// <returns>Модель пользователя при успешной аутентификации или null, если аутентификация не удалась</returns>
    Task<User> AuthenticateAsync(string login, string password);

    /// <summary>
    /// Проверяет, имеет ли пользователь права на выполнение действия
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <param name="requiredRole">Требуемая роль для действия</param>
    /// <returns>Признак наличия прав</returns>
    Task<bool> AuthorizeAsync(int userId, UserRole requiredRole);
}

//IDefectService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IDefectService
{
    Task<List<DefectGroup>> GetAllDefectGroupsAsync(string filter = "");
    Task<int> CreateDefectGroupAsync(DefectGroup defectGroup);
    Task<bool> UpdateDefectGroupAsync(DefectGroup defectGroup);
    Task<bool> DeleteDefectGroupAsync(int id);

    Task<List<Defect>> GetAllDefectsAsync(string filter = "");
    Task<int> CreateDefectAsync(Defect defect);
    Task<bool> UpdateDefectAsync(Defect defect);
    Task<bool> DeleteDefectAsync(int id);
}

//IDriverService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IDriverService
{
    Task<List<Driver>> GetAllDriversAsync(string filter = "");
    Task<int> CreateDriverAsync(Driver driver);
    Task<bool> UpdateDriverAsync(Driver driver);
    Task<bool> DeleteDriverAsync(int id);
}

//IEquipmentService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IEquipmentService
{
    Task<int> CreateEquipmentAsync(Equipment equipment);
    Task<bool> UpdateEquipmentAsync(Equipment equipment);
    Task<bool> DeleteEquipmentAsync(int id);
    Task<List<Equipment>> GetAllEquipmentAsync(string filter = "");
}

//IExpenseService.cs
using RequestManagement.Common.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Interfaces
{
    public interface IExpenseService
    {
        Task<Expense> CreateExpenseAsync(Expense expense);
        Task<bool> UpdateExpenseAsync(Expense expense);
        Task<bool> DeleteExpenseAsync(int id);
        Task<UserLastSelection?> GetUserLastSelectionAsync(int userId);
        Task<NomenclatureDefectMapping?> GetLastNomenclatureDefectMappingAsync(int userId, int nomenclatureId);
        Task SaveUserLastSelectionAsync(int userId, int? driverId, int? equipmentId);
        Task SaveNomenclatureDefectMappingAsync(int userId, int nomenclatureId, int defectId);
        Task<bool> DeleteExpensesAsync(List<int> requestId);
        Task<List<Expense>> GetAllExpensesAsync(string requestFilter, int requestWarehouseId, int requestEquipmentId, int requestDriverId, int requestDefectId, string requestFromDate, string requestToDate);
    }
}


//IIncomingService.cs
using RequestManagement.Common.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Interfaces
{
    public interface IIncomingService
    {
        Task<Incoming> CreateIncomingAsync(Incoming incoming);
        Task<bool> UpdateIncomingAsync(Incoming expense);
        Task<bool> DeleteIncomingAsync(int id);
        Task<bool> DeleteIncomingsAsync(List<int> requestId);
        Task<List<Incoming>> GetAllIncomingsAsync(string requestFilter, int requestWarehouseId, string requestFromDate, string requestToDate);
    }
}


//INomenclatureService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface INomenclatureService
{
    Task<List<Nomenclature>> GetAllNomenclaturesAsync(string filter = "");
    Task<int> CreateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> UpdateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> DeleteNomenclatureAsync(int id);
}

//IRequestService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IRequestService
{
    Task<int> CreateEquipmentAsync(Equipment equipment);
    Task<bool> UpdateEquipmentAsync(Equipment equipment);
    Task<bool> DeleteEquipmentAsync(int id);
    Task<List<Equipment>> GetAllEquipmentAsync(string filter = "");

    Task<List<Driver>> GetAllDriversAsync(string filter = "");
    Task<int> CreateDriverAsync(Driver driver);
    Task<bool> UpdateDriverAsync(Driver driver);
    Task<bool> DeleteDriverAsync(int id);

    Task<List<DefectGroup>> GetAllDefectGroupsAsync(string filter = "");
    Task<int> CreateDefectGroupAsync(DefectGroup driver);
    Task<bool> UpdateDefectGroupAsync(DefectGroup driver);
    Task<bool> DeleteDefectGroupAsync(int id);

    Task<List<Defect>> GetAllDefectsAsync(string filter = "");
    Task<int> CreateDefectAsync(Defect driver);
    Task<bool> UpdateDefectAsync(Defect driver);
    Task<bool> DeleteDefectAsync(int id);

    Task<List<Nomenclature>> GetAllNomenclaturesAsync(string filter = "");
    Task<int> CreateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> UpdateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> DeleteNomenclatureAsync(int id);
}

//IStockService.cs
using RequestManagement.Common.Models;
using WpfClient.Models;

namespace RequestManagement.Common.Interfaces;

public interface IStockService
{
    Task<int> CreateStockAsync(Stock stock);
    Task<bool> UpdateStockAsync(Stock stock);
    Task<bool> DeleteStockAsync(int id);
    Task<List<Stock>> GetAllStocksAsync(int warehouseId,
        string filter = "",
        int initialQuantityFilterType = 0,
        double initialQuantityFilter = 0,
        int receivedQuantityFilterType = 0,
        double receivedQuantityFilter = 0,
        int consumedQuantityFilterType = 0,
        double consumedQuantityFilter = 0,
        int finalQuantityFilterType = 0,
        double finalQuantityFilter = 0
        );
    Task<bool> UploadMaterialsStockAsync(List<MaterialStock>? materials, int warehouseId, DateTime date);
}

//IUserService.cs
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Common.Interfaces;

/// <summary>
/// Интерфейс сервиса для работы с пользователями
/// </summary>
public interface IUserService
{
    /// <summary>
    /// Создает нового пользователя
    /// </summary>
    /// <param name="user">Модель пользователя для создания</param>
    /// <returns>Идентификатор созданного пользователя</returns>
    Task<int> CreateUserAsync(User user);

    /// <summary>
    /// Обновляет данные пользователя
    /// </summary>
    /// <param name="user">Обновленная модель пользователя</param>
    /// <returns>Признак успешного обновления</returns>
    Task<bool> UpdateUserAsync(User user);

    /// <summary>
    /// Удаляет пользователя по идентификатору
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <returns>Признак успешного удаления</returns>
    Task<bool> DeleteUserAsync(int userId);

    /// <summary>
    /// Получает пользователя по идентификатору
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <returns>Модель пользователя или null, если пользователь не найден</returns>
    Task<User> GetUserByIdAsync(int userId);

    /// <summary>
    /// Получает пользователя по логину
    /// </summary>
    /// <param name="login">Логин пользователя</param>
    /// <returns>Модель пользователя или null, если пользователь не найден</returns>
    Task<User> GetUserByLoginAsync(string login);

    /// <summary>
    /// Проверяет, имеет ли пользователь указанную роль
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <param name="role">Роль для проверки</param>
    /// <returns>Признак соответствия роли</returns>
    Task<bool> HasRoleAsync(int userId, UserRole role);
}

//IWarehouseService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IWarehouseService
{
    Task<List<Warehouse>> GetAllWarehousesAsync(string filter = "");
    Task<Warehouse> GetOrCreateWarehousesAsync(string filter);
    Task<int> CreateWarehouseAsync(Warehouse warehouse);
    Task<bool> UpdateWarehouseAsync(Warehouse warehouse);
    Task<bool> DeleteWarehouseAsync(int id);
}

//Defect.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Defect : IEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public int DefectGroupId { get; set; }      // Группа дефекта (внешний ключ)
    public DefectGroup DefectGroup { get; set; }
}

//DefectGroup.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class DefectGroup : IEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public List<Defect> Defects { get; set; } = [];
}

//Driver.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Driver : IEntity
{
    public int Id { get; set; }
    public string FullName { get; set; } = string.Empty;
    public string ShortName { get; set; } = string.Empty;
    public string Position { get; set; } = string.Empty;
}

//Equipment.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

/// <summary>
/// Модель единицы техники (назначения) для заявки
/// </summary>
public class Equipment : IEntity
{
    /// <summary>
    /// Уникальный идентификатор единицы техники
    /// </summary>
    public int Id { get; set; }

    /// <summary>
    /// Название единицы техники
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Государственный номер (может отсутствовать)
    /// </summary>
    public string? StateNumber { get; set; } = string.Empty;
}

//Expense.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class Expense : IEntity
    {
        [NotMapped]
        public bool IsSelected { get; set; }
        public int Id { get; set; }
        public int StockId { get; set; }
        public Stock Stock { get; set; } = null!;
        public decimal Quantity { get; set; }
        public int EquipmentId { get; set; }
        public Equipment Equipment { get; set; } = null!;
        public int DriverId { get; set; }
        public Driver Driver { get; set; } = null!;
        public int DefectId { get; set; }
        public Defect Defect { get; set; } = null!;
        public DateTime Date { get; set; }
    }
}


//Helpers.cs
namespace RequestManagement.Common.Models;

public static class Helpers
{
    public record QuantityFilter(decimal Value, ComparisonOperator Operator)
    {
        private static QuantityFilter GreaterThan(decimal value) => new(value, ComparisonOperator.GreaterThan);
        private static QuantityFilter EqualTo(decimal value) => new(value, ComparisonOperator.EqualTo);
        private static QuantityFilter LessThan(decimal value) => new(value, ComparisonOperator.LessThan);
        public static QuantityFilter? GetQuantityFilter(decimal value, int type) => type switch { 1 => EqualTo(value), 2 => GreaterThan(value), 3 => LessThan(value), _ => null };
    }

    public enum ComparisonOperator
    {
        GreaterThan,
        EqualTo,
        LessThan
    }
}

//Incoming.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models;
public class Incoming : IEntity
{
    [NotMapped]
    public bool IsSelected { get; set; }
    public int Id { get; set; }
    public int StockId { get; set; }
    public Stock Stock { get; set; } = null!;
    public decimal Quantity { get; set; }
    public DateTime Date { get; set; }
}


//MaterialStock.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WpfClient.Models
{
    public class MaterialStock
    {
        public string ItemName { get; set; }
        public string Code { get; set; }
        public string Article { get; set; }
        public string Unit { get; set; }
        public double FinalBalance { get; set; }
    }
}


//Nomenclature.cs
using RequestManagement.Common.Models.Interfaces;
using System.ComponentModel.DataAnnotations.Schema;
using System.ComponentModel.DataAnnotations;

namespace RequestManagement.Common.Models;

public class Nomenclature : IEntity
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string? Article { get; set; } = string.Empty;
    public string UnitOfMeasure { get; set; } = string.Empty;
    public List<Stock> Stocks { get; set; } = []; // Связь один-ко-многим
}

//NomenclatureDefectMapping.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class NomenclatureDefectMapping : IEntity
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public User User { get; set; } = null!;
        public int NomenclatureId { get; set; }
        public Nomenclature Nomenclature { get; set; } = null!;
        public int DefectId { get; set; }
        public Defect Defect { get; set; } = null!;
        public DateTime LastUsed { get; set; }
    }
}


//Stock.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Stock : IEntity
{
    public int Id { get; set; }
    public int WarehouseId { get; set; }
    public Warehouse Warehouse { get; set; } = null!; // Внешний ключ на таблицу Warehouse
    public int NomenclatureId { get; set; }
    public Nomenclature Nomenclature { get; set; } = null!; // Внешний ключ на таблицу Nomenclature
    public decimal InitialQuantity { get; set; } // Начальное количество
    public decimal ReceivedQuantity { get; set; } // Количество поступления
    public decimal ConsumedQuantity { get; set; }
    public decimal FinalQuantity => InitialQuantity + ReceivedQuantity - ConsumedQuantity;
}

//User.cs
using RequestManagement.Common.Models.Enums;
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

/// <summary>
/// Модель пользователя системы
/// </summary>
public class User : IEntity
{
    /// <summary>
    /// Уникальный идентификатор пользователя
    /// </summary>
    public int Id { get; set; }

    /// <summary>
    /// Логин пользователя
    /// </summary>
    public string Login { get; set; }

    /// <summary>
    /// Пароль пользователя (хранится в зашифрованном виде)
    /// </summary>
    public string Password { get; set; }

    /// <summary>
    /// Роль пользователя в системе
    /// </summary>
    public UserRole Role { get; set; }
}

//UserLastSelection.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class UserLastSelection : IEntity
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public User User { get; set; } = null!;
        public int? DriverId { get; set; }
        public Driver? Driver { get; set; }
        public int? EquipmentId { get; set; }
        public Equipment? Equipment { get; set; }
        public DateTime LastUpdated { get; set; }
    }
}


//Warehouse.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Warehouse : IEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public DateTime LastUpdated { get; set; }
    // Другие поля склада, если нужно
    public List<Stock> Stocks { get; set; } = []; // Связь один-ко-многим
}

//UserRole.cs
namespace RequestManagement.Common.Models.Enums;

/// <summary>
/// Перечисление ролей пользователей
/// </summary>
public enum UserRole
{
    /// <summary>
    /// Администратор с полными правами
    /// </summary>
    Administrator = 0,

    /// <summary>
    /// Пользователь с ограниченными правами
    /// </summary>
    User = 1,

    /// <summary>
    /// Наблюдатель с правами только на чтение
    /// </summary>
    Observer = 2
}

//IEntity.cs
namespace RequestManagement.Common.Models.Interfaces
{
    public interface IEntity
    {
        public int Id { get; set; }
    }
}


//Program.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Server.Data;
using RequestManagement.Server.Services;
using RequestManagement.Common.Interfaces;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;

var builder = WebApplication.CreateBuilder(args);

// ����������� ��������� ��
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

// ����������� ��������
builder.Services.AddScoped<IRequestService, RequestService>();
builder.Services.AddScoped<IStockService, StockService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IExpenseService, ExpenseService>();
builder.Services.AddScoped<IIncomingService, IncomingService>();
builder.Services.AddScoped<IWarehouseService, WarehouseService>();

// ��������� JWT
var key = Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"] ?? throw new InvalidOperationException());
builder.Services.AddAuthorization();

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(key)
        };
    });

// ���������� gRPC
builder.Services.AddGrpc();

var app = builder.Build();
AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);
// ��������� ��������� ��������� ��������
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.MapGrpcService<RequestManagement.Server.Controllers.RequestController>();
app.MapGrpcService<RequestManagement.Server.Controllers.StockController>();
app.MapGrpcService<RequestManagement.Server.Controllers.AuthController>();
app.MapGrpcService<RequestManagement.Server.Controllers.ExpenseController>();
app.MapGrpcService<RequestManagement.Server.Controllers.IncomingController>();
app.MapGrpcService<RequestManagement.Server.Controllers.WarehouseController>();

app.Run();

//AuthController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Controllers
{
    /// <summary>
    /// gRPC-контроллер для аутентификации
    /// </summary>
    public class AuthController : AuthService.AuthServiceBase
    {
        private readonly IAuthService _authService;
        private readonly ILogger<AuthController> _logger;
        private readonly IConfiguration _configuration;

        public AuthController(IAuthService authService, ILogger<AuthController> logger, IConfiguration configuration)
        {
            _authService = authService;
            _logger = logger;
            _configuration = configuration;
        }

        /// <summary>
        /// Аутентифицирует пользователя и возвращает JWT-токен
        /// </summary>
        public override async Task<AuthenticateResponse> Authenticate(AuthenticateRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Authenticating user with login: {Login}", request.Login);

            var user = await _authService.AuthenticateAsync(request.Login, request.Password);
            if (user == null)
            {
                return new AuthenticateResponse
                {
                    UserId = 0,
                    Login = "",
                    Role = 0,
                    Token = ""
                };
            }

            // Генерация JWT-токена
            var token = GenerateJwtToken(user);

            return new AuthenticateResponse
            {
                UserId = user.Id,
                Login = user.Login,
                Role = (int)user.Role,
                Token = token
            };
        }

        /// <summary>
        /// Проверяет права доступа пользователя
        /// </summary>
        public override async Task<AuthorizeResponse> Authorize(AuthorizeRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Authorizing user {UserId} for role {Role}", request.UserId, request.RequiredRole);

            bool isAuthorized = await _authService.AuthorizeAsync(request.UserId, (UserRole)request.RequiredRole);
            return new AuthorizeResponse { IsAuthorized = isAuthorized };
        }

        /// <summary>
        /// Генерирует JWT-токен для пользователя
        /// </summary>
        private string GenerateJwtToken(User user)
        {
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
            var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var claims = new[]
            {
                new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
                new Claim(JwtRegisteredClaimNames.UniqueName, user.Login),
                new Claim(ClaimTypes.Role, user.Role.ToString()),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            };

            var token = new JwtSecurityToken(
                issuer: _configuration["Jwt:Issuer"],
                audience: _configuration["Jwt:Audience"],
                claims: claims,
                expires: DateTime.Now.AddHours(1), // Токен действителен 1 час
                signingCredentials: credentials
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}

//ExpenseController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using System.Security.Claims;

namespace RequestManagement.Server.Controllers
{
    public class ExpenseController(IExpenseService expenseService, ILogger<RequestController> logger) : ExpenseService.ExpenseServiceBase
    {
        private readonly IExpenseService _expenseService = expenseService ?? throw new ArgumentNullException(nameof(expenseService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        public override async Task<GetNomenclatureMapingResponse> GetNomenclatureMaping(
            GetNomenclatureMapingRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            var value = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var response = new GetNomenclatureMapingResponse();
            if (value != null)
            {
                var userId = int.Parse(value);
                var mapping = await _expenseService.GetLastNomenclatureDefectMappingAsync(userId, request.NomenclatureId);
                if (mapping != null)
                {
                    response.Defect = new ExpenseDefect
                    {
                        Id = mapping.Defect.Id,
                        Name = mapping.Defect.Name,
                    };
                }
            }
            return response;
        }

        public override async Task<GetLastSelectionResponse> GetLastSelection(GetLastSelectionRequest request,
            ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            var value = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var response = new GetLastSelectionResponse();
            if (value != null)
            {
                var userId = int.Parse(value);
                var lastSelection = await _expenseService.GetUserLastSelectionAsync(userId);
                if (lastSelection != null)
                {
                    if (lastSelection is { DriverId: not null, Driver: not null })
                        response.Driver = new ExpenseDriver
                        {
                            Id = lastSelection.Driver.Id,
                            FullName = lastSelection.Driver.FullName,
                            ShortName = lastSelection.Driver.ShortName,
                            Position = lastSelection.Driver.Position
                        };
                    if (lastSelection is { EquipmentId: not null, Equipment: not null })
                        response.Equipment = new ExpenseEquipment
                        {
                            Id = lastSelection.Equipment.Id,
                            Name = lastSelection.Equipment.Name,
                            LicensePlate = lastSelection.Equipment.StateNumber
                        };
                }
                var mapping = await _expenseService.GetLastNomenclatureDefectMappingAsync(userId, request.NomenclatureId);
                if (mapping != null)
                {
                    response.Defect = new ExpenseDefect
                    {
                        Id = mapping.Defect.Id,
                        Name = mapping.Defect.Name,
                    };
                }
            }
            return response;
        }

        public override async Task<GetAllExpensesResponse> GetAllExpenses(GetAllExpensesRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all expenses");

            var expenseList = await _expenseService.GetAllExpensesAsync(request.Filter,request.WarehouseId,request.EquipmentId,request.DriverId,request.DefectId,request.FromDate,request.ToDate);
            var response = new GetAllExpensesResponse();
            response.Expenses.AddRange(expenseList.Select(e => new Expense
            {
                Id = e.Id,
                Stock = new ExpenseStock
                {
                    Id = e.StockId,
                    Warehouse = new ExpenseWarehouse
                    {
                        Id = e.Stock.Warehouse.Id,
                        Name = e.Stock.Warehouse.Name
                    },
                    Nomenclature = new ExpenseNomenclature
                    {
                        Id = e.Stock.Nomenclature.Id,
                        Name = e.Stock.Nomenclature.Name,
                        Code = e.Stock.Nomenclature.Code,
                        UnitOfMeasure = e.Stock.Nomenclature.UnitOfMeasure,
                        Article = e.Stock.Nomenclature.Article
                    },
                    InitialQuantity = (double)e.Stock.InitialQuantity,
                    ReceivedQuantity = (double)e.Stock.ReceivedQuantity,
                    ConsumedQuantity = (double)e.Stock.ConsumedQuantity
                },
                Quantity = (double)e.Quantity,
                Equipment = new ExpenseEquipment
                {
                    Id = e.Equipment.Id,
                    Name = e.Equipment.Name,
                    LicensePlate = e.Equipment.StateNumber
                },
                Driver = new ExpenseDriver
                {
                    Id = e.Driver.Id,
                    FullName = e.Driver.FullName,
                    ShortName = e.Driver.ShortName,
                    Position = e.Driver.Position
                },
                Defect = new ExpenseDefect
                {
                    Id = e.Defect.Id,
                    Name = e.Defect.Name,
                    DefectGroup = new ExpenseDefectGroup
                    {
                        Id = e.Defect.DefectGroupId,
                        Name = e.Defect.DefectGroup.Name
                    }
                },
                Date = e.Date.ToString("o") // ISO 8601 format
            }));

            return response;
        }

        public override async Task<CreateExpenseResponse> CreateExpense(CreateExpenseRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new expense");
            var expense = new RequestManagement.Common.Models.Expense
            {
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                EquipmentId = request.EquipmentId,
                DriverId = request.DriverId,
                DefectId = request.DefectId,
                Date = DateTime.Parse(request.Date)
            };

            var newExpense = await _expenseService.CreateExpenseAsync(expense);
            var user = context.GetHttpContext().User;
            var value = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (value != null)
            {
                var userId = int.Parse(value);
                await _expenseService.SaveUserLastSelectionAsync(userId, request.DriverId, request.EquipmentId);
                await _expenseService.SaveNomenclatureDefectMappingAsync(userId, newExpense.Stock.NomenclatureId, request.DefectId);
            }

            return new CreateExpenseResponse { Id = newExpense.Id };
        }

        public override async Task<UpdateExpenseResponse> UpdateExpense(UpdateExpenseRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating expense with ID: {Id}", request.Id);

            var expense = new RequestManagement.Common.Models.Expense
            {
                Id = request.Id,
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                EquipmentId = request.EquipmentId,
                DriverId = request.DriverId,
                DefectId = request.DefectId,
                Date = DateTime.Parse(request.Date)
            };

            var success = await _expenseService.UpdateExpenseAsync(expense);
            return new UpdateExpenseResponse { Success = success };
        }

        public override async Task<DeleteExpenseResponse> DeleteExpense(DeleteExpenseRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting expense with ID: {Id}", request.Id);

            var success = await _expenseService.DeleteExpenseAsync(request.Id);
            return new DeleteExpenseResponse { Success = success };
        }
        public override async Task<DeleteExpenseResponse> DeleteExpenses(DeleteExpensesRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting expense with IDs : {Id}", request.Id.ToList());

            var success = await _expenseService.DeleteExpensesAsync(request.Id.ToList());
            return new DeleteExpenseResponse { Success = success };
        }
    }
}


//IncomingController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;

namespace RequestManagement.Server.Controllers
{
    public class IncomingController(IIncomingService incomingService, ILogger<RequestController> logger) : IncomingService.IncomingServiceBase
    {
        private readonly IIncomingService _incomingService = incomingService ?? throw new ArgumentNullException(nameof(incomingService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

       

      

        public override async Task<GetAllIncomingsResponse> GetAllIncomings(GetAllIncomingsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all incomings");

            var incomingList = await _incomingService.GetAllIncomingsAsync(request.Filter,request.WarehouseId,request.FromDate,request.ToDate);
            var response = new GetAllIncomingsResponse();
            response.Incoming.AddRange(incomingList.Select(e => new Incoming
            {
                Id = e.Id,
                Stock = new IncomingStock
                {
                    Id = e.StockId,
                    Warehouse = new IncomingWarehouse
                    {
                        Id = e.Stock.Warehouse.Id,
                        Name = e.Stock.Warehouse.Name
                    },
                    Nomenclature = new IncomingNomenclature
                    {
                        Id = e.Stock.Nomenclature.Id,
                        Name = e.Stock.Nomenclature.Name,
                        Code = e.Stock.Nomenclature.Code,
                        UnitOfMeasure = e.Stock.Nomenclature.UnitOfMeasure,
                        Article = e.Stock.Nomenclature.Article
                    },
                    InitialQuantity = (double)e.Stock.InitialQuantity,
                    ReceivedQuantity = (double)e.Stock.ReceivedQuantity,
                    ConsumedQuantity = (double)e.Stock.ConsumedQuantity
                },
                Quantity = (double)e.Quantity,
                Date = e.Date.ToString("o") // ISO 8601 format
            }));

            return response;
        }

        public override async Task<CreateIncomingResponse> CreateIncoming(CreateIncomingRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new incoming");
            var incoming = new RequestManagement.Common.Models.Incoming
            {
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                Date = DateTime.Parse(request.Date)
            };
            var newIncoming = await _incomingService.CreateIncomingAsync(incoming);
            return new CreateIncomingResponse { Id = newIncoming.Id };
        }

        public override async Task<UpdateIncomingResponse> UpdateIncoming(UpdateIncomingRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating incoming with ID: {Id}", request.Id);

            var incoming = new RequestManagement.Common.Models.Incoming
            {
                Id = request.Id,
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                Date = DateTime.Parse(request.Date)
            };
            var success = await _incomingService.UpdateIncomingAsync(incoming);
            return new UpdateIncomingResponse { Success = success };
        }

        public override async Task<DeleteIncomingResponse> DeleteIncoming(DeleteIncomingRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting incoming with ID: {Id}", request.Id);

            var success = await _incomingService.DeleteIncomingAsync(request.Id);
            return new DeleteIncomingResponse { Success = success };
        }
        public override async Task<DeleteIncomingResponse> DeleteIncomings(DeleteIncomingsRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting incoming with IDs : {Id}", request.Id.ToList());

            var success = await _incomingService.DeleteIncomingsAsync(request.Id.ToList());
            return new DeleteIncomingResponse { Success = success };
        }
    }
}


//RequestController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;

namespace RequestManagement.Server.Controllers
{
    /// <summary>
    /// gRPC-контроллер для работы с оборудованием
    /// </summary>
    public class RequestController(IRequestService requestService, ILogger<RequestController> logger)
        : RequestService.RequestServiceBase
    {
        private readonly IRequestService _requestService = requestService ?? throw new ArgumentNullException(nameof(requestService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        /// <summary>
        /// Получает список всех единиц оборудования
        /// </summary>
        public override async Task<GetAllEquipmentResponse> GetAllEquipment(GetAllEquipmentRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (!user.Identity.IsAuthenticated)
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all equipment");

            var equipmentList = await _requestService.GetAllEquipmentAsync(request.Filter);
            var response = new GetAllEquipmentResponse();
            response.Equipment.AddRange(equipmentList.Select(e => new Equipment
            {
                Id = e.Id,
                Name = e.Name,
                LicensePlate = e.StateNumber ?? ""
            }));

            return response;
        }

        /// <summary>
        /// Создает новую единицу оборудования
        /// </summary>
        public override async Task<CreateEquipmentResponse> CreateEquipment(CreateEquipmentRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new equipment with name: {Name}", request.Name);

            var equipment = new RequestManagement.Common.Models.Equipment
            {
                Name = request.Name,
                StateNumber = request.LicensePlate
            };

            var id = await _requestService.CreateEquipmentAsync(equipment);
            return new CreateEquipmentResponse { Id = id };
        }

        /// <summary>
        /// Обновляет существующую единицу оборудования
        /// </summary>
        public override async Task<UpdateEquipmentResponse> UpdateEquipment(UpdateEquipmentRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating equipment with ID: {Id}", request.Id);

            var equipment = new RequestManagement.Common.Models.Equipment
            {
                Id = request.Id,
                Name = request.Name,
                StateNumber = request.LicensePlate
            };

            var success = await _requestService.UpdateEquipmentAsync(equipment);
            return new UpdateEquipmentResponse { Success = success };
        }

        /// <summary>
        /// Удаляет единицу оборудования
        /// </summary>
        public override async Task<DeleteEquipmentResponse> DeleteEquipment(DeleteEquipmentRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting equipment with ID: {Id}", request.Id);

            var success = await _requestService.DeleteEquipmentAsync(request.Id);
            return new DeleteEquipmentResponse { Success = success };
        }

        public override async Task<GetAllDriversResponse> GetAllDrivers(GetAllDriversRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all drivers by filter");

            var equipmentList = await _requestService.GetAllDriversAsync(request.Filter);
            var response = new GetAllDriversResponse();
            response.Drivers.AddRange(equipmentList.Select(e => new Driver
            {
                Id = e.Id,
                FullName = e.FullName,
                ShortName = e.ShortName,
                Position = e.Position
            }));

            return response;
        }

        public override async Task<CreateDriverResponse> CreateDriver(CreateDriverRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new driver with full name and position: {Name} - {Position}", request.Driver.FullName, request.Driver.Position);

            var driver = new RequestManagement.Common.Models.Driver
            {
                FullName = request.Driver.FullName,
                ShortName = request.Driver.ShortName,
                Position = request.Driver.Position
            };

            var id = await _requestService.CreateDriverAsync(driver);
            return new CreateDriverResponse { Id = id };
        }

        public override async Task<UpdateDriverResponse> UpdateDriver(UpdateDriverRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating driver with ID: {Id}", request.Driver.Id);

            var driver = new RequestManagement.Common.Models.Driver
            {
                Id = request.Driver.Id,
                FullName = request.Driver.FullName,
                ShortName = request.Driver.ShortName,
                Position = request.Driver.Position
            };

            var success = await _requestService.UpdateDriverAsync(driver);
            return new UpdateDriverResponse { Success = success };
        }

        public override async Task<DeleteDriverResponse> DeleteDriver(DeleteDriverRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting driver with ID: {Id}", request.Id);

            var success = await _requestService.DeleteDriverAsync(request.Id);
            return new DeleteDriverResponse { Success = success };
        }

        public override async Task<GetAllDefectGroupsResponse> GetAllDefectGroups(GetAllDefectGroupsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all drivers by filter");

            var defectGroupList = await _requestService.GetAllDefectGroupsAsync(request.Filter);
            var response = new GetAllDefectGroupsResponse();
            response.DefectGroup.AddRange(defectGroupList.Select(e => new DefectGroup
            {
                Id = e.Id,
                Name = e.Name,
            }));

            return response;
        }
        public override async Task<CreateDefectGroupResponse> CreateDefectGroup(CreateDefectGroupRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new defectGroup with full name: {Name}", request.DefectGroup.Name);

            var defectGroup = new Common.Models.DefectGroup
            {
                Name = request.DefectGroup.Name,
            };

            var id = await _requestService.CreateDefectGroupAsync(defectGroup);
            return new CreateDefectGroupResponse { Id = id };
        }
        public override async Task<UpdateDefectGroupResponse> UpdateDefectGroup(UpdateDefectGroupRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating defectGroup with ID: {Id}", request.DefectGroup.Id);

            var defectGroup = new Common.Models.DefectGroup
            {
                Id = request.DefectGroup.Id,
                Name = request.DefectGroup.Name,
            };

            var success = await _requestService.UpdateDefectGroupAsync(defectGroup);
            return new UpdateDefectGroupResponse { Success = success };
        }
        public override async Task<DeleteDefectGroupResponse> DeleteDefectGroup(DeleteDefectGroupRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting defectGroup with ID: {Id}", request.Id);

            var success = await _requestService.DeleteDefectGroupAsync(request.Id);
            return new DeleteDefectGroupResponse { Success = success };
        }

        public override async Task<GetAllDefectsResponse> GetAllDefects(GetAllDefectsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all defects by filter");

            var defectList = await _requestService.GetAllDefectsAsync(request.Filter);
            var response = new GetAllDefectsResponse();
            response.Defect.AddRange(defectList.Select(e => new Defect
            {
                Id = e.Id,
                Name = e.Name,
                DefectGroupId = e.DefectGroupId
            }));

            return response;
        }

        public override async Task<CreateDefectResponse> CreateDefect(CreateDefectRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new defect with name: {Name}", request.Defect.Name);

            var defect = new Common.Models.Defect
            {
                Name = request.Defect.Name,
                DefectGroupId = request.Defect.DefectGroupId
            };

            var id = await _requestService.CreateDefectAsync(defect);
            return new CreateDefectResponse { Id = id };
        }
        public override async Task<UpdateDefectResponse> UpdateDefect(UpdateDefectRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating defect with ID: {Id}", request.Defect.Id);

            var defect = new Common.Models.Defect
            {
                Id = request.Defect.Id,
                Name = request.Defect.Name,
                DefectGroupId = request.Defect.DefectGroupId
            };

            var success = await _requestService.UpdateDefectAsync(defect);
            return new UpdateDefectResponse { Success = success };
        }

        public override async Task<DeleteDefectResponse> DeleteDefect(DeleteDefectRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting defect with ID: {Id}", request.Id);

            var success = await _requestService.DeleteDefectAsync(request.Id);
            return new DeleteDefectResponse { Success = success };
        }

        public override async Task<GetAllNomenclaturesResponse> GetAllNomenclatures(GetAllNomenclaturesRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all nomenclatures by filter");

            var nomenclatureList = await requestService.GetAllNomenclaturesAsync(request.Filter);
            var response = new GetAllNomenclaturesResponse();
            response.Nomenclature.AddRange(nomenclatureList.Select(e => new Nomenclature
            {
                Id = e.Id,
                Name = e.Name,
                Code = e.Code,
                UnitOfMeasure = e.UnitOfMeasure,
                Article = e.Article
            }));

            return response;
        }
        public override async Task<CreateNomenclatureResponse> CreateNomenclature(CreateNomenclatureRequest request, ServerCallContext context)
        {
            logger.LogInformation("Creating new nomenclature with name: {Name}", request.Nomenclature.Name);

            var nomenclature = new RequestManagement.Common.Models.Nomenclature
            {
                Name = request.Nomenclature.Name,
                Code = request.Nomenclature.Code,
                UnitOfMeasure = request.Nomenclature.UnitOfMeasure,
                Article = request.Nomenclature.Article
            };

            var id = await requestService.CreateNomenclatureAsync(nomenclature);
            return new CreateNomenclatureResponse { Id = id };
        }

        public override async Task<UpdateNomenclatureResponse> UpdateNomenclature(UpdateNomenclatureRequest request, ServerCallContext context)
        {
            logger.LogInformation("Updating nomenclature with ID: {Id}", request.Nomenclature.Id);

            var nomenclature = new RequestManagement.Common.Models.Nomenclature
            {
                Id = request.Nomenclature.Id,
                Name = request.Nomenclature.Name,
                Code = request.Nomenclature.Code,
                UnitOfMeasure = request.Nomenclature.UnitOfMeasure,
                Article = request.Nomenclature.Article
            };

            var success = await requestService.UpdateNomenclatureAsync(nomenclature);
            return new UpdateNomenclatureResponse { Success = success };
        }

        public override async Task<DeleteNomenclatureResponse> DeleteNomenclature(DeleteNomenclatureRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting nomenclature with ID: {Id}", request.Id);

            var success = await requestService.DeleteNomenclatureAsync(request.Id);
            return new DeleteNomenclatureResponse { Success = success };
        }
    }
}

//StockController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using WpfClient.Models;

namespace RequestManagement.Server.Controllers
{
    public class StockController(IStockService requestService, ILogger<RequestController> logger) : StockService.StockServiceBase
    {
        private readonly IStockService _requestService = requestService ?? throw new ArgumentNullException(nameof(requestService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        public override async Task<UploadMaterialStockResponse> UploadMaterialStock(UploadMaterialStockRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Upload Materials to stock");
            var materialList = request.Materials.Select(e => new MaterialStock { ItemName = e.Name, Code = e.Code,Article = e.Article,Unit = e.Unit,FinalBalance = e.FinalBalance}).ToList();
            var result = await _requestService.UploadMaterialsStockAsync(materialList, request.WarehouseId, DateTime.Parse(request.Date));
            return new UploadMaterialStockResponse{ Success = result };
        }

        public override async Task<GetAllStocksResponse> GetAllStock(GetAllStocksRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all stock");

            var stockList = await _requestService.GetAllStocksAsync(
                request.WarehouseId, 
                request.Filter,
                request.InitialQuantityFilterType,
                request.InitialQuantity,
                request.ReceivedQuantityFilterType,
                request.ReceivedQuantity,
                request.ConsumedQuantityFilterType,
                request.ConsumedQuantity,
                request.FinalQuantityFilterType,
                request.FinalQuantity
                );
            var response = new GetAllStocksResponse();
            response.Stocks.AddRange(stockList.Select(e => new Stock
            {
                Id = e.Id,
                WarehouseId = e.WarehouseId,
                NomenclatureId = e.NomenclatureId,
                InitialQuantity = (double)e.InitialQuantity,
                ReceivedQuantity = (double)e.ReceivedQuantity,
                ConsumedQuantity = (double)e.ConsumedQuantity,
                Nomenclature = new StockNomenclature{Code = e.Nomenclature.Code,Article = e.Nomenclature.Article, Name = e.Nomenclature.Name, UnitOfMeasure = e.Nomenclature.UnitOfMeasure},
            }));

            return response;
        }
        public override async Task<CreateStockResponse> CreateStock(CreateStockRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new stock");

            var stock = new Common.Models.Stock
            {
                WarehouseId = request.WarehouseId,
                NomenclatureId = request.NomenclatureId,
                InitialQuantity = (decimal)request.InitialQuantity
            };
            var id = await _requestService.CreateStockAsync(stock);
            return new CreateStockResponse { Id = id };
        }

        public override async Task<UpdateStockResponse> UpdateStock(UpdateStockRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating stock");
            var stock = new RequestManagement.Common.Models.Stock
            {
                Id = request.Id,
                NomenclatureId = request.NomenclatureId,
                InitialQuantity = (decimal)request.InitialQuantity
            };
            var success = await requestService.UpdateStockAsync(stock);
            return new UpdateStockResponse { Success = success };
        }

        public override async Task<DeleteStockResponse> DeleteStock(DeleteStockRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting stock with ID: {Id}", request.Id);
            var success = await requestService.DeleteStockAsync(request.Id);
            return new DeleteStockResponse { Success = success };
        }
    }
}


//WarehouseController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;

namespace RequestManagement.Server.Controllers
{
    public class WarehouseController(IWarehouseService warehouseService, ILogger<RequestController> logger)
        : WarehouseService.WarehouseServiceBase
    {
        public override async Task<GetAllWarehousesResponse> GetAllWarehouses(GetAllWarehousesRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all warehouses by filter");

            var warehouseList = await warehouseService.GetAllWarehousesAsync(request.Filter);
            var response = new GetAllWarehousesResponse();
            response.Warehouse.AddRange(warehouseList.Select(e => new Warehouse
            {
                Id = e.Id,
                Name = e.Name,
                LastUpdated = e.LastUpdated.ToString("o")
            }));

            return response;
        }

        public override async Task<GetOrCreateWarehouseResponse> GetOrCreateWarehouse(
            GetOrCreateWarehouseRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all warehouses by filter");
            var warehouse = await warehouseService.GetOrCreateWarehousesAsync(request.Filter);
            var response = new GetOrCreateWarehouseResponse
            {
                Warehouse = new Warehouse { Id = warehouse.Id, Name = warehouse.Name, LastUpdated = warehouse.LastUpdated.ToString("o") }
            };
            return response;
        }

        public override async Task<CreateWarehouseResponse> CreateWarehouse(CreateWarehouseRequest request, ServerCallContext context)
        {
            logger.LogInformation("Creating new warehouse with name: {Name}", request.Warehouse.Name);

            var warehouse = new RequestManagement.Common.Models.Warehouse
            {
                Name = request.Warehouse.Name,
                LastUpdated = DateTime.Parse(request.Warehouse.LastUpdated)
            };

            var id = await warehouseService.CreateWarehouseAsync(warehouse);
            return new CreateWarehouseResponse { Id = id };
        }

        public override async Task<UpdateWarehouseResponse> UpdateWarehouse(UpdateWarehouseRequest request, ServerCallContext context)
        {
            logger.LogInformation("Updating warehouse with ID: {Id}", request.Warehouse.Id);

            var warehouse = new RequestManagement.Common.Models.Warehouse
            {
                Id = request.Warehouse.Id,
                Name = request.Warehouse.Name,
                LastUpdated = DateTime.Parse(request.Warehouse.LastUpdated)
            };

            var success = await warehouseService.UpdateWarehouseAsync(warehouse);
            return new UpdateWarehouseResponse { Success = success };
        }

        public override async Task<DeleteWarehouseResponse> DeleteWarehouse(DeleteWarehouseRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting warehouse with ID: {Id}", request.Id);

            var success = await warehouseService.DeleteWarehouseAsync(request.Id);
            return new DeleteWarehouseResponse { Success = success };
        }
    }
}


//ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<User> Users { get; set; }
        public DbSet<Equipment> Equipments { get; set; }
        public DbSet<Warehouse> Warehouses { get; set; }
        public DbSet<Nomenclature> Nomenclature { get; set; }
        public DbSet<DefectGroup> DefectGroups { get; set; }
        public DbSet<Defect> Defects { get; set; }
        public DbSet<Driver> Drivers { get; set; }
        public DbSet<Stock> Stocks { get; set; }
        public DbSet<Expense> Expenses { get; set; }
        public DbSet<Incoming> Incoming { get; set; }
        public DbSet<UserLastSelection> UserLastSelections { get; set; }
        public DbSet<NomenclatureDefectMapping> NomenclatureDefectMappings { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<UserLastSelection>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.HasOne(e => e.User)
                    .WithMany()
                    .HasForeignKey(e => e.UserId);
                entity.HasOne(e => e.Driver)
                    .WithMany()
                    .HasForeignKey(e => e.DriverId)
                    .IsRequired(false);
                entity.HasOne(e => e.Equipment)
                    .WithMany()
                    .HasForeignKey(e => e.EquipmentId)
                    .IsRequired(false);
            });
            modelBuilder.Entity<NomenclatureDefectMapping>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.HasOne(e => e.User)
                    .WithMany()
                    .HasForeignKey(e => e.UserId);
                entity.HasOne(e => e.Nomenclature)
                    .WithMany()
                    .HasForeignKey(e => e.NomenclatureId);
                entity.HasOne(e => e.Defect)
                    .WithMany()
                    .HasForeignKey(e => e.DefectId);
            });
            modelBuilder.Entity<Expense>(entity =>
            {
                entity.Ignore(e => e.IsSelected);
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Quantity)
                    .HasColumnType("decimal(18,2)");
                entity.Property(e => e.Date)
                    .HasColumnType("timestamp with time zone");
                entity.HasOne(e => e.Stock)
                    .WithMany() 
                    .HasForeignKey(e => e.StockId)
                    .OnDelete(DeleteBehavior.Restrict);
            });
            modelBuilder.Entity<Expense>(entity =>
            {
                entity.Ignore(e=>e.IsSelected);
                entity.HasKey(e => e.Id);

                entity.Property(e => e.Quantity)
                    .HasColumnType("decimal(18,2)");

                entity.Property(e => e.Date)
                    .HasColumnType("timestamp with time zone");

                entity.HasOne(e => e.Stock)
                    .WithMany() // Если нужно, можно добавить коллекцию Expenses в Stock
                    .HasForeignKey(e => e.StockId)
                    .OnDelete(DeleteBehavior.Restrict);

                entity.HasOne(e => e.Equipment)
                    .WithMany()
                    .HasForeignKey(e => e.EquipmentId)
                    .OnDelete(DeleteBehavior.Restrict);

                entity.HasOne(e => e.Driver)
                    .WithMany()
                    .HasForeignKey(e => e.DriverId)
                    .OnDelete(DeleteBehavior.Restrict);

                entity.HasOne(e => e.Defect)
                    .WithMany()
                    .HasForeignKey(e => e.DefectId)
                    .OnDelete(DeleteBehavior.Restrict);
            });
            modelBuilder.Entity<Stock>(entity =>
            {
                entity.HasKey(s => s.Id);
                entity.Property(s => s.InitialQuantity).HasColumnType("decimal(18,2)");
                entity.Property(s => s.ReceivedQuantity).HasColumnType("decimal(18,2)");
                entity.Property(s => s.ConsumedQuantity).HasColumnType("decimal(18,2)");

                entity.HasOne(s => s.Warehouse)
                    .WithMany(w => w.Stocks)
                    .HasForeignKey(s => s.WarehouseId)
                    .OnDelete(DeleteBehavior.Restrict); // Запрет удаления склада, если есть запасы

                entity.HasOne(s => s.Nomenclature)
                    .WithMany(n => n.Stocks)
                    .HasForeignKey(s => s.NomenclatureId)
                    .OnDelete(DeleteBehavior.Restrict); // Запрет удаления номенклатуры, если есть запасы
            });
            // Отношения для DefectGroup и Defect
            modelBuilder.Entity<DefectGroup>()
                .HasMany(dg => dg.Defects)
                .WithOne(d => d.DefectGroup)
                .HasForeignKey(d => d.DefectGroupId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<Expense>().HasData(
                new Expense
                {
                    Id = 1,
                    StockId = 1,
                    Quantity = 5,
                    EquipmentId = 1,
                    DriverId = 1,
                    DefectId = 1,
                    Date = DateTime.SpecifyKind(DateTime.Parse("12.04.2025"), DateTimeKind.Utc)
                }
            );
            modelBuilder.Entity<Incoming>().HasData(
                new Incoming
                {
                    Id = 1,
                    StockId = 1,
                    Quantity = 5,
                    Date = DateTime.SpecifyKind(DateTime.Parse("15.04.2025"), DateTimeKind.Utc)
                });
            // Начальные данные для Users
            modelBuilder.Entity<User>().HasData(
                new User
                {
                    Id = 1,
                    Login = "admin",
                    Password = "$2a$11$IeKuyvG/5SoDYP0NFz3kouC3CPUIuUa6ShTfgVVf9oUlfqbXq8LrC",
                    Role = UserRole.Administrator
                }
            );

            // Начальные данные для Warehouses
            modelBuilder.Entity<Warehouse>().HasData(
                new Warehouse { Id = 1, Name = "Основной склад" },
                new Warehouse { Id = 2, Name = "Резервный склад" }
            );

            // Начальные данные для Nomenclature
            modelBuilder.Entity<Nomenclature>().HasData(
                new Nomenclature
                {
                    Id = 1,
                    Code = "ТКР001",
                    Name = "Турбокомпрессор ТКР 7С-6 левый КАМАЗ Евро 2",
                    Article = "7406.1118013",
                    UnitOfMeasure = "шт",
                },
                new Nomenclature
                {
                    Id = 2,
                    Code = "АКБ001",
                    Name = "Аккумулятор 6СТ-190",
                    Article = "6СТ-190",
                    UnitOfMeasure = "шт",
                },
                new Nomenclature
                {
                    Id = 3,
                    Code = "АКБ002",
                    Name = "Аккумулятор 6СТ-200 (аналог 6СТ-190)",
                    Article = "6СТ-200",
                    UnitOfMeasure = "шт",
                }
            );
            modelBuilder.Entity<Stock>().HasData(
                new Stock
                {
                    Id = 1,
                    NomenclatureId = 1,
                    WarehouseId = 1,
                    InitialQuantity = 70,
                    ReceivedQuantity = 0,
                    ConsumedQuantity = 0
                },
                new Stock
                {
                    Id = 2,
                    NomenclatureId = 2,
                    WarehouseId = 1,
                    InitialQuantity = 10,
                    ReceivedQuantity = 0,
                    ConsumedQuantity = 0
                },
            new Stock
            {
                Id = 3,
                NomenclatureId = 1,
                WarehouseId = 2,
                InitialQuantity = 40,
                ReceivedQuantity = 0,
                ConsumedQuantity = 0
            },
            new Stock
            {
                Id = 4,
                NomenclatureId = 2,
                WarehouseId = 2,
                InitialQuantity = 20,
                ReceivedQuantity = 0,
                ConsumedQuantity = 0
            }
            );

            // Начальные данные для Drivers
            modelBuilder.Entity<Driver>().HasData(
                new Driver
                {
                    Id = 1,
                    FullName = "Иванов Иван Иванович",
                    ShortName = "Иванов И.И.",
                    Position = "Водитель"
                },
                new Driver
                {
                    Id = 2,
                    FullName = "Петров Петр Петрович",
                    ShortName = "Петров П.П.",
                    Position = "Водитель"
                }
            );

            // Начальные данные для Equipment
            modelBuilder.Entity<Equipment>().HasData(
                new Equipment
                {
                    Id = 1,
                    Name = "КАМАЗ 53215-15",
                    StateNumber = "Н 507 СН"
                }
            );

            // Начальные данные для DefectGroups
            modelBuilder.Entity<DefectGroup>().HasData(
                new DefectGroup { Id = 1, Name = "Механические повреждения" },
                new DefectGroup { Id = 2, Name = "Электрические неисправности" }
            );

            // Начальные данные для Defects
            modelBuilder.Entity<Defect>().HasData(
                new Defect { Id = 1, Name = "Трещина корпуса", DefectGroupId = 1 },
                new Defect { Id = 2, Name = "Короткое замыкание", DefectGroupId = 2 }
            );

            // Индексы
            modelBuilder.Entity<User>()
                .HasIndex(u => u.Login)
                .IsUnique();
        }
    }
}

//auth.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

package auth;

// Сервис аутентификации
service AuthService {
    rpc Authenticate (AuthenticateRequest) returns (AuthenticateResponse);
    rpc Authorize (AuthorizeRequest) returns (AuthorizeResponse);
}

// Сообщения для запросов и ответов

// Запрос на аутентификацию
message AuthenticateRequest {
    string login = 1;         // Логин пользователя
    string password = 2;      // Пароль пользователя
}

// Ответ на аутентификацию
message AuthenticateResponse {
    int32 user_id = 1;        // ID пользователя (0, если аутентификация не удалась)
    string login = 2;         // Логин пользователя
    int32 role = 3;           // Роль пользователя (enum UserRole)
    string token = 4;         // JWT-токен для дальнейших запросов
}

// Запрос на проверку прав доступа
message AuthorizeRequest {
    int32 user_id = 1;        // ID пользователя
    int32 required_role = 2;  // Требуемая роль (enum UserRole)
}

// Ответ на проверку прав доступа
message AuthorizeResponse {
    bool is_authorized = 1;   // Признак наличия прав
}

//expense.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service ExpenseService {
  rpc GetAllExpenses (GetAllExpensesRequest) returns (GetAllExpensesResponse);
  rpc CreateExpense (CreateExpenseRequest) returns (CreateExpenseResponse);
  rpc UpdateExpense (UpdateExpenseRequest) returns (UpdateExpenseResponse);
  rpc DeleteExpense (DeleteExpenseRequest) returns (DeleteExpenseResponse);
  rpc DeleteExpenses (DeleteExpensesRequest) returns (DeleteExpenseResponse);
  rpc GetLastSelection (GetLastSelectionRequest) returns (GetLastSelectionResponse);
  rpc GetNomenclatureMaping (GetNomenclatureMapingRequest) returns (GetNomenclatureMapingResponse);
}

message GetAllExpensesRequest {
  string filter = 1;
  int32 warehouse_id = 2;
  int32 equipment_id = 3;
  int32 driver_id = 4;
  int32 defect_id = 5;
  string from_date = 6;
  string to_date = 7;
}

message GetAllExpensesResponse {
  repeated Expense expenses = 1;
}

message Expense {
  int32 id = 1;
  ExpenseStock stock = 2;
  double quantity = 3;
  ExpenseEquipment equipment = 4;
  ExpenseDriver driver = 5;
  ExpenseDefect defect = 6;
  string date = 7;
}

message ExpenseDefectGroup {
    int32 id = 1;
    string name = 2;   
}

message ExpenseDefect {
    int32 id = 1;
    string name = 2;
    ExpenseDefectGroup defectGroup = 3;
}

message ExpenseDriver {
    int32 id = 1;
    string full_name = 2;
    string short_name = 3; 
    string position = 4;
}

message ExpenseEquipment {
    int32 id = 1;
    string name = 2;
    string license_plate = 3;
}

message ExpenseWarehouse {
    int32 id = 1;
    string name = 2;
}

message ExpenseStock {
    int32 id = 1;
    ExpenseWarehouse warehouse = 2;
    double initial_quantity = 3;
    double received_quantity = 4;
    double consumed_quantity = 5;
    ExpenseNomenclature nomenclature = 6;
}

message ExpenseNomenclature {
    int32 id = 1;
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

message CreateExpenseRequest {
  int32 stock_id = 1;
  double quantity = 2;
  int32 equipment_id = 3;
  int32 driver_id = 4;
  int32 defect_id = 5;
  string date = 6;
}

message CreateExpenseResponse {
  int32 id = 1;
}

message UpdateExpenseRequest {
  int32 id = 1;
  int32 stock_id = 2;
  double quantity = 3;
  int32 equipment_id = 4;
  int32 driver_id = 5;
  int32 defect_id = 6;
  string date = 7;
}

message UpdateExpenseResponse {
  bool success = 1;
}

message DeleteExpenseRequest {
  int32 id = 1;
}

message DeleteExpensesRequest {
  repeated int32 id = 1;
}

message DeleteExpenseResponse {
  bool success = 1;
}

message GetLastSelectionResponse {
  ExpenseDriver driver = 1;
  ExpenseEquipment equipment = 2;
  ExpenseDefect defect = 3;
}

message GetLastSelectionRequest {
  int32 nomenclature_id = 1;
}

message GetNomenclatureMapingRequest {
  int32 nomenclature_id = 1;
}

message GetNomenclatureMapingResponse {
  ExpenseDefect defect = 1;
}

//incoming.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service IncomingService {
  rpc GetAllIncomings (GetAllIncomingsRequest) returns (GetAllIncomingsResponse);
  rpc CreateIncoming (CreateIncomingRequest) returns (CreateIncomingResponse);
  rpc UpdateIncoming (UpdateIncomingRequest) returns (UpdateIncomingResponse);
  rpc DeleteIncoming (DeleteIncomingRequest) returns (DeleteIncomingResponse);
  rpc DeleteIncomings (DeleteIncomingsRequest) returns (DeleteIncomingResponse);
}

message GetAllIncomingsRequest {
  string filter = 1;
  int32 warehouse_id = 2;
  string from_date = 3;
  string to_date = 4;
}

message GetAllIncomingsResponse {
  repeated Incoming incoming = 1;
}

message CreateIncomingRequest {
  int32 stock_id = 1;
  double quantity = 2;
  string date = 3;
}

message CreateIncomingResponse {
  int32 id = 1;
}

message UpdateIncomingRequest {
  int32 id = 1;
  int32 stock_id = 2;
  double quantity = 3;
  string date = 4;
}

message UpdateIncomingResponse {
  bool success = 1;
}

message DeleteIncomingRequest {
  int32 id = 1;
}

message DeleteIncomingsRequest {
  repeated int32 id = 1;
}

message DeleteIncomingResponse {
  bool success = 1;
}

message Incoming {
  int32 id = 1;
  IncomingStock stock = 2;
  double quantity = 3;
  string date = 4;
}

message IncomingWarehouse {
    int32 id = 1;
    string name = 2;
}

message IncomingStock {
    int32 id = 1;
    IncomingWarehouse warehouse = 2;
    double initial_quantity = 3;
    double received_quantity = 4;
    double consumed_quantity = 5;
    IncomingNomenclature nomenclature = 6;
}

message IncomingNomenclature {
    int32 id = 1;
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

//request.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service RequestService {
    rpc GetAllEquipment (GetAllEquipmentRequest) returns (GetAllEquipmentResponse);
    rpc CreateEquipment (CreateEquipmentRequest) returns (CreateEquipmentResponse);
    rpc UpdateEquipment (UpdateEquipmentRequest) returns (UpdateEquipmentResponse);
    rpc DeleteEquipment (DeleteEquipmentRequest) returns (DeleteEquipmentResponse);

    rpc GetAllDrivers (GetAllDriversRequest) returns (GetAllDriversResponse);
    rpc CreateDriver (CreateDriverRequest) returns (CreateDriverResponse);
    rpc UpdateDriver (UpdateDriverRequest) returns (UpdateDriverResponse);
    rpc DeleteDriver (DeleteDriverRequest) returns (DeleteDriverResponse);

    rpc GetAllDefectGroups (GetAllDefectGroupsRequest) returns (GetAllDefectGroupsResponse);
    rpc CreateDefectGroup (CreateDefectGroupRequest) returns (CreateDefectGroupResponse);
    rpc UpdateDefectGroup (UpdateDefectGroupRequest) returns (UpdateDefectGroupResponse);
    rpc DeleteDefectGroup (DeleteDefectGroupRequest) returns (DeleteDefectGroupResponse);

    rpc GetAllDefects (GetAllDefectsRequest) returns (GetAllDefectsResponse);
    rpc CreateDefect(CreateDefectRequest) returns (CreateDefectResponse);
    rpc UpdateDefect (UpdateDefectRequest) returns (UpdateDefectResponse);
    rpc DeleteDefect (DeleteDefectRequest) returns (DeleteDefectResponse);

    rpc GetAllNomenclatures (GetAllNomenclaturesRequest) returns (GetAllNomenclaturesResponse);
    rpc CreateNomenclature(CreateNomenclatureRequest) returns (CreateNomenclatureResponse);
    rpc UpdateNomenclature (UpdateNomenclatureRequest) returns (UpdateNomenclatureResponse);
    rpc DeleteNomenclature (DeleteNomenclatureRequest) returns (DeleteNomenclatureResponse);
}

// Сообщения для оборудования
message GetAllEquipmentRequest {
    string filter = 1;
}

message GetAllEquipmentResponse {
    repeated Equipment equipment = 1;
}

message CreateEquipmentRequest {
    string name = 1;
    string license_plate = 2;
}

message CreateEquipmentResponse {
    int32 id = 1;
}

message UpdateEquipmentRequest {
    int32 id = 1;
    string name = 2;
    string license_plate = 3;
}

message UpdateEquipmentResponse {
    bool success = 1;
}

message DeleteEquipmentRequest {
    int32 id = 1;
}

message DeleteEquipmentResponse {
    bool success = 1;
}

message Equipment {
    int32 id = 1;
    string name = 2;
    string license_plate = 3;
}

message GetAllDriversRequest {
    string filter = 1; // Фильтр для поиска по имени или должности
}

message GetAllDriversResponse {
    repeated Driver drivers = 1;
}

message CreateDriverRequest {
    Driver driver = 1;
}

message CreateDriverResponse {
    int32 id = 1; // ID созданного водителя
}

message UpdateDriverRequest {
    Driver driver = 1;
}

message UpdateDriverResponse {
    bool success = 1;
}

message DeleteDriverRequest {
    int32 id = 1;
}

message DeleteDriverResponse {
    bool success = 1;
}

message Driver {
    int32 id = 1;
    string full_name = 2;   // Полное ФИО
    string short_name = 3;  // Фамилия с инициалами
    string position = 4;    // Должность
}

message GetAllDefectGroupsRequest {
    string filter = 1;
}

message GetAllDefectGroupsResponse {
    repeated DefectGroup defectGroup = 1;
}

message CreateDefectGroupRequest {
    DefectGroup defectGroup = 1;
}

message CreateDefectGroupResponse {
    int32 id = 1;
}

message UpdateDefectGroupRequest {
    DefectGroup defectGroup = 1;
}

message UpdateDefectGroupResponse {
    bool success = 1;
}

message DeleteDefectGroupRequest {
    int32 id = 1;
}

message DeleteDefectGroupResponse {
    bool success = 1;
}

message DefectGroup {
    int32 id = 1;
    string name = 2;   
}

message GetAllDefectsRequest {
    string filter = 1;
}

message GetAllDefectsResponse {
    repeated Defect defect = 1;
}

message CreateDefectRequest {
    Defect defect = 1;
}

message CreateDefectResponse {
    int32 id = 1;
}

message UpdateDefectRequest {
    Defect defect = 1;
}

message UpdateDefectResponse {
    bool success = 1;
}

message DeleteDefectRequest {
    int32 id = 1;
}

message DeleteDefectResponse {
    bool success = 1;
}

message Defect {
    int32 id = 1;
    string name = 2;
    int32 defectGroupId = 3;
}

message GetAllNomenclaturesRequest {
    string filter = 1;
}

message GetAllNomenclaturesResponse {
    repeated Nomenclature nomenclature = 1;
}

message CreateNomenclatureRequest {
    Nomenclature nomenclature = 1;
}

message CreateNomenclatureResponse {
    int32 id = 1;
}

message UpdateNomenclatureRequest {
    Nomenclature nomenclature = 1;
}

message UpdateNomenclatureResponse {
    bool success = 1;
}

message DeleteNomenclatureRequest {
    int32 id = 1;
}

message DeleteNomenclatureResponse {
    bool success = 1;
}

message Nomenclature {
    int32 id = 1;
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

//stock.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service StockService {
    rpc GetAllStock (GetAllStocksRequest) returns (GetAllStocksResponse);
    rpc CreateStock (CreateStockRequest) returns (CreateStockResponse);
    rpc UpdateStock (UpdateStockRequest) returns (UpdateStockResponse);
    rpc DeleteStock (DeleteStockRequest) returns (DeleteStockResponse);
    rpc UploadMaterialStock (UploadMaterialStockRequest) returns (UploadMaterialStockResponse);
}

message GetAllStocksRequest {
    int32 warehouseId = 1;
    string filter = 2;
    int32 initialQuantityFilterType = 3;
    double initialQuantity = 4;
    int32 receivedQuantityFilterType = 5;
    double receivedQuantity = 6;
    int32 consumedQuantityFilterType = 7;
    double consumedQuantity = 8;
    int32 finalQuantityFilterType = 9;
    double finalQuantity = 10;
}

message GetAllStocksResponse {
    repeated Stock stocks = 1;
}

message CreateStockRequest {
    int32 warehouse_id = 1;
    int32 nomenclature_id = 2;
    double initial_quantity = 3;
}

message CreateStockResponse {
    int32 id = 1;
}

message UpdateStockRequest {
    int32 id = 1;
    int32 nomenclature_id = 3;
    double initial_quantity = 4;
}

message UpdateStockResponse {
    bool success = 1;
}

message DeleteStockRequest {
    int32 id = 1;
}

message DeleteStockResponse {
    bool success = 1;
}

message UploadMaterialStockRequest{
    int32 warehouse_id = 1;
    string date = 2;
    repeated MaterialStockMessage materials = 3;
}

message UploadMaterialStockResponse{
     bool success = 1;
}

message Stock {
    int32 id = 1;
    int32 warehouse_id = 2;
    int32 nomenclature_id = 3;
    double initial_quantity = 4;
    double received_quantity = 5;
    double consumed_quantity = 6;
    StockNomenclature nomenclature = 7;
}

message StockNomenclature {
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

message MaterialStockMessage {
    string name = 1;
    string code = 2;
    string article = 3;
    string unit = 4;
    double finalBalance = 5;
}

//warehouse.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service WarehouseService {
    rpc GetAllWarehouses (GetAllWarehousesRequest) returns (GetAllWarehousesResponse);
    rpc CreateWarehouse(CreateWarehouseRequest) returns (CreateWarehouseResponse);
    rpc UpdateWarehouse (UpdateWarehouseRequest) returns (UpdateWarehouseResponse);
    rpc DeleteWarehouse (DeleteWarehouseRequest) returns (DeleteWarehouseResponse);
    rpc GetOrCreateWarehouse (GetOrCreateWarehouseRequest) returns (GetOrCreateWarehouseResponse);
}

message GetOrCreateWarehouseRequest{
    string filter = 1;
}

message GetOrCreateWarehouseResponse{
    Warehouse warehouse = 1;
}

message GetAllWarehousesRequest {
    string filter = 1;
}

message GetAllWarehousesResponse {
    repeated Warehouse warehouse = 1;
}

message CreateWarehouseRequest {
    Warehouse warehouse = 1;
}

message CreateWarehouseResponse {
    int32 id = 1;
}

message UpdateWarehouseRequest {
    Warehouse warehouse = 1;
}

message UpdateWarehouseResponse {
    bool success = 1;
}

message DeleteWarehouseRequest {
    int32 id = 1;
}

message DeleteWarehouseResponse {
    bool success = 1;
}

message Warehouse {
    int32 id = 1;
    string name = 2;
    string last_updated = 3;
}

//AuthService.cs
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Services
{
    /// <summary>
    /// Сервис авторизации
    /// </summary>
    public class AuthService : IAuthService
    {
        private readonly IUserService _userService;

        public AuthService(IUserService userService)
        {
            _userService = userService ?? throw new ArgumentNullException(nameof(userService));
        }

        /// <summary>
        /// Аутентифицирует пользователя по логину и паролю
        /// </summary>
        public async Task<User> AuthenticateAsync(string login, string password)
        {
            if (string.IsNullOrWhiteSpace(login))
                throw new ArgumentException("Login cannot be null or empty", nameof(login));
            if (string.IsNullOrWhiteSpace(password))
                throw new ArgumentException("Password cannot be null or empty", nameof(password));
            var tmp_pass = BCrypt.Net.BCrypt.HashPassword(password);
            Console.WriteLine(tmp_pass);
            var user = await _userService.GetUserByLoginAsync(login);
            if (user == null || !BCrypt.Net.BCrypt.Verify(password, user.Password))
                return null;

            return user;
        }

        /// <summary>
        /// Проверяет, имеет ли пользователь права на выполнение действия
        /// </summary>
        public async Task<bool> AuthorizeAsync(int userId, UserRole requiredRole)
        {
            return await _userService.HasRoleAsync(userId, requiredRole);
        }
    }
}

//ExpenseService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class ExpenseService(ApplicationDbContext dbContext) : IExpenseService
    {
        public async Task<List<Expense>> GetAllExpensesAsync(string filter, int requestWarehouseId, int requestEquipmentId, int requestDriverId,
            int requestDefectId, string requestFromDate, string requestToDate)
        {
            var query = dbContext.Expenses
                .Include(e => e.Stock)
                .ThenInclude(s => s.Nomenclature)
                .Include(e => e.Stock)
                .ThenInclude(s => s.Warehouse)
                .Include(e => e.Equipment)
                .Include(e => e.Driver)
                .Include(e => e.Defect)
                .ThenInclude(s => s.DefectGroup)
                .AsQueryable();

            if (!string.IsNullOrWhiteSpace(filter))
            {
                query = query.Where(e => EF.Functions.Like(e.Stock.Nomenclature.Name, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Article, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Code, $"%{filter}%"));
            }
            if (requestWarehouseId != 0)
            {
                query = query.Where(e => e.Stock.WarehouseId == requestWarehouseId);
            }
            if (requestEquipmentId != 0)
            {
                query = query.Where(e => e.EquipmentId == requestEquipmentId);
            }
            if (requestDriverId != 0)
            {
                query = query.Where(e => e.DriverId == requestDriverId);
            }
            if (requestDefectId != 0)
            {
                query = query.Where(e => e.DefectId == requestDefectId);
            }
            if (DateTime.TryParse(requestFromDate, out var fromDate) &&
                DateTime.TryParse(requestToDate, out var toDate))
            {
                query = query.Where(e => e.Date >= fromDate && e.Date < toDate.AddDays(1));
            }
            else
            {
                if (DateTime.TryParse(requestFromDate, out fromDate))
                {
                    query = query.Where(e => e.Date >= fromDate);
                }

                if (DateTime.TryParse(requestToDate, out toDate))
                {
                    query = query.Where(e => e.Date < toDate.AddDays(1));
                }
            }
            return await query.ToListAsync();
        }
        public async Task<Expense> CreateExpenseAsync(Expense expense)
        {
            try
            {
                if (expense == null) throw new ArgumentNullException(nameof(expense));

                // Проверка наличия записи в Stock
                var stock = await dbContext.Stocks
                    .FirstOrDefaultAsync(s => s.Id == expense.StockId);

                if (stock == null)
                {
                    throw new InvalidOperationException("Stock with the given ID does not exist.");
                }

                // Обновление ConsumedQuantity
                stock.ConsumedQuantity += expense.Quantity;

                dbContext.Expenses.Add(expense);
                await dbContext.SaveChangesAsync();

                return expense;
            }
            catch
            {
                return new Expense();
            }

        }
        public async Task<bool> UpdateExpenseAsync(Expense expense)
        {
            if (expense == null) throw new ArgumentNullException(nameof(expense));

            var existingExpense = await dbContext.Expenses
                .FirstOrDefaultAsync(e => e.Id == expense.Id);

            if (existingExpense == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var oldStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == existingExpense.StockId);
            var newStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == expense.StockId);

            if (oldStock == null || newStock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }

            // Корректировка ConsumedQuantity
            oldStock.ConsumedQuantity -= existingExpense.Quantity; // Убираем старое значение
            newStock.ConsumedQuantity += expense.Quantity; // Добавляем новое значение

            existingExpense.StockId = expense.StockId;
            existingExpense.Quantity = expense.Quantity;
            existingExpense.EquipmentId = expense.EquipmentId;
            existingExpense.DriverId = expense.DriverId;
            existingExpense.DefectId = expense.DefectId;
            existingExpense.Date = expense.Date;

            await dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteExpenseAsync(int id)
        {
            var expense = await dbContext.Expenses
                .FirstOrDefaultAsync(e => e.Id == id);

            if (expense == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var stock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == expense.StockId);

            if (stock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }

            // Уменьшение ConsumedQuantity
            stock.ConsumedQuantity -= expense.Quantity;

            dbContext.Expenses.Remove(expense);
            await dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<UserLastSelection?> GetUserLastSelectionAsync(int userId)
        {
            return await dbContext.UserLastSelections
                .Include(s => s.Driver)
                .Include(s => s.Equipment)
                .FirstOrDefaultAsync(s => s.UserId == userId);
        }

        public async Task<NomenclatureDefectMapping?> GetLastNomenclatureDefectMappingAsync(int userId, int nomenclatureId)
        {
            return await dbContext.NomenclatureDefectMappings
                .Include(m => m.Nomenclature)
                .Include(m => m.Defect)
                .FirstOrDefaultAsync(m => m.UserId == userId && m.NomenclatureId == nomenclatureId);
        }

        public async Task SaveUserLastSelectionAsync(int userId, int? driverId, int? equipmentId)
        {
            var existing = await dbContext.UserLastSelections
                .FirstOrDefaultAsync(s => s.UserId == userId);

            if (existing == null)
            {
                existing = new UserLastSelection
                {
                    UserId = userId,
                    DriverId = driverId,
                    EquipmentId = equipmentId,
                    LastUpdated = DateTime.UtcNow
                };
                dbContext.UserLastSelections.Add(existing);
            }
            else
            {
                existing.DriverId = driverId;
                existing.EquipmentId = equipmentId;
                existing.LastUpdated = DateTime.UtcNow;
            }

            await dbContext.SaveChangesAsync();
        }

        public async Task SaveNomenclatureDefectMappingAsync(int userId, int nomenclatureId, int defectId)
        {
            var existing = await dbContext.NomenclatureDefectMappings
                .FirstOrDefaultAsync(m => m.UserId == userId && m.NomenclatureId == nomenclatureId);

            if (existing == null)
            {
                existing = new NomenclatureDefectMapping
                {
                    UserId = userId,
                    NomenclatureId = nomenclatureId,
                    DefectId = defectId,
                    LastUsed = DateTime.UtcNow
                };
                dbContext.NomenclatureDefectMappings.Add(existing);
            }
            else
            {
                existing.DefectId = defectId;
                existing.LastUsed = DateTime.UtcNow;
            }

            await dbContext.SaveChangesAsync();
        }

        public async Task<bool> DeleteExpensesAsync(List<int> requestIds)
        {
            var expenses = await dbContext.Expenses
                .Where(e => requestIds.Contains(e.Id))
                .Include(e => e.Stock)
                .ToListAsync();
            if (!expenses.Any())
            {
                return false;
            }

            foreach (var expense in expenses)
            {
                expense.Stock.ConsumedQuantity -= expense.Quantity;
            }
            dbContext.Expenses.RemoveRange(expenses);
            var deletedCount = await dbContext.SaveChangesAsync();
            return deletedCount > 0;
        }
    }
}


//IncomingService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class IncomingService(ApplicationDbContext dbContext) : IIncomingService
    {
        public async Task<List<Incoming>> GetAllIncomingsAsync(string filter, int requestWarehouseId,  string requestFromDate, string requestToDate)
        {
            var query = dbContext.Incoming
                .Include(e => e.Stock)
                .ThenInclude(s => s.Nomenclature)
                .Include(e => e.Stock)
                .ThenInclude(s => s.Warehouse)
                .AsQueryable();

            if (!string.IsNullOrWhiteSpace(filter))
            {
                query = query.Where(e => EF.Functions.Like(e.Stock.Nomenclature.Name, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Article, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Code, $"%{filter}%"));
            }
            if (requestWarehouseId != 0)
            {
                query = query.Where(e => e.Stock.WarehouseId == requestWarehouseId);
            }
            if (DateTime.TryParse(requestFromDate, out var fromDate) &&
                DateTime.TryParse(requestToDate, out var toDate))
            {
                query = query.Where(e => e.Date >= fromDate && e.Date < toDate.AddDays(1));
            }
            else
            {
                if (DateTime.TryParse(requestFromDate, out fromDate))
                {
                    query = query.Where(e => e.Date >= fromDate);
                }

                if (DateTime.TryParse(requestToDate, out toDate))
                {
                    query = query.Where(e => e.Date < toDate.AddDays(1));
                }
            }
            return await query.ToListAsync();
        }
        public async Task<Incoming> CreateIncomingAsync(Incoming incoming)
        {
            try
            {
                if (incoming == null) throw new ArgumentNullException(nameof(incoming));

                // Проверка наличия записи в Stock
                var stock = await dbContext.Stocks
                    .FirstOrDefaultAsync(s => s.Id == incoming.StockId);

                if (stock == null)
                {
                    throw new InvalidOperationException("Stock with the given ID does not exist.");
                }

                // Обновление ReceivedQuantity
                stock.ReceivedQuantity += incoming.Quantity;

                dbContext.Incoming.Add(incoming);
                await dbContext.SaveChangesAsync();

                return incoming;
            }
            catch
            {
                return new Incoming();
            }

        }
        public async Task<bool> UpdateIncomingAsync(Incoming incoming)
        {
            if (incoming == null) throw new ArgumentNullException(nameof(incoming));

            var existingIncoming = await dbContext.Incoming
                .FirstOrDefaultAsync(e => e.Id == incoming.Id);

            if (existingIncoming == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var oldStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == existingIncoming.StockId);
            var newStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == incoming.StockId);

            if (oldStock == null || newStock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }

            // Корректировка ReceivedQuantity
            oldStock.ReceivedQuantity -= existingIncoming.Quantity; // Убираем старое значение
            newStock.ReceivedQuantity += incoming.Quantity; // Добавляем новое значение

            existingIncoming.StockId = incoming.StockId;
            existingIncoming.Quantity = incoming.Quantity;
            existingIncoming.Date = incoming.Date;

            await dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteIncomingAsync(int id)
        {
            var incoming = await dbContext.Incoming
                .FirstOrDefaultAsync(e => e.Id == id);

            if (incoming == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var stock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == incoming.StockId);

            if (stock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }

            // Уменьшение ReceivedQuantity
            stock.ReceivedQuantity -= incoming.Quantity;

            dbContext.Incoming.Remove(incoming);
            await dbContext.SaveChangesAsync();
            return true;
        }

     

        public async Task<bool> DeleteIncomingsAsync(List<int> requestIds)
        {
            var incomings = await dbContext.Incoming
                .Where(e => requestIds.Contains(e.Id))
                .Include(e => e.Stock)
                .ToListAsync();
            if (!incomings.Any())
            {
                return false;
            }

            foreach (var incoming in incomings)
            {
                incoming.Stock.ReceivedQuantity -= incoming.Quantity;
            }
            dbContext.Incoming.RemoveRange(incomings);
            var deletedCount = await dbContext.SaveChangesAsync();
            return deletedCount > 0;
        }
    }
}


//RequestService.cs


using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class RequestService(ApplicationDbContext dbContext) : IRequestService
    {
        private readonly ApplicationDbContext _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));

        public async Task<int> CreateEquipmentAsync(Equipment equipment)
        {
            _dbContext.Equipments.Add(equipment);
            await _dbContext.SaveChangesAsync();
            return equipment.Id;
        }

        public async Task<bool> UpdateEquipmentAsync(Equipment equipment)
        {
            var existingEquipment = await _dbContext.Equipments
                .FirstOrDefaultAsync(e => e.Id == equipment.Id);

            if (existingEquipment == null)
                return false;

            existingEquipment.Name = equipment.Name;
            existingEquipment.StateNumber = equipment.StateNumber;

            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteEquipmentAsync(int id)
        {
            try
            {
                var equipment = await _dbContext.Equipments
                .FirstOrDefaultAsync(e => e.Id == id);

                if (equipment == null)
                    return false;

                _dbContext.Equipments.Remove(equipment);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<Equipment>> GetAllEquipmentAsync(string filter = "")
        {
            var query = _dbContext.Equipments.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase) || e.StateNumber!.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Equipment
                {
                    Id = e.Id,
                    Name = e.Name,
                    StateNumber = e.StateNumber ?? ""
                })
                .ToListAsync();
        }

        public async Task<List<Driver>> GetAllDriversAsync(string filter = "")
        {
            var query = _dbContext.Drivers.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.FullName.ToLower().Contains(phrase) || e.Position.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Driver
                {
                    Id = e.Id,
                    FullName = e.FullName,
                    ShortName = e.ShortName,
                    Position = e.Position
                })
                .ToListAsync();
        }

        public async Task<int> CreateDriverAsync(Driver driver)
        {
            _dbContext.Drivers.Add(driver);
            await _dbContext.SaveChangesAsync();
            return driver.Id;
        }

        public async Task<bool> UpdateDriverAsync(Driver driver)
        {
            var existDriver = await _dbContext.Drivers
                .FirstOrDefaultAsync(e => e.Id == driver.Id);

            if (existDriver == null)
                return false;

            existDriver.FullName = driver.FullName;
            existDriver.ShortName = driver.ShortName;
            existDriver.Position = driver.Position;

            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteDriverAsync(int id)
        {
            try
            {
                var driver = await _dbContext.Drivers
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (driver == null)
                    return false;

                _dbContext.Drivers.Remove(driver);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<DefectGroup>> GetAllDefectGroupsAsync(string filter = "")
        {
            var query = _dbContext.DefectGroups.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new DefectGroup
                {
                    Id = e.Id,
                    Name = e.Name,
                })
                .ToListAsync();
        }
        public async Task<int> CreateDefectGroupAsync(DefectGroup defectGroup)
        {
            _dbContext.DefectGroups.Add(defectGroup);
            await _dbContext.SaveChangesAsync();
            return defectGroup.Id;
        }
        public async Task<bool> UpdateDefectGroupAsync(DefectGroup defectGroup)
        {
            var existDefectGroup = await _dbContext.DefectGroups
                .FirstOrDefaultAsync(e => e.Id == defectGroup.Id);

            if (existDefectGroup == null)
                return false;

            existDefectGroup.Name = defectGroup.Name;
            await _dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteDefectGroupAsync(int id)
        {
            try
            {
                var defectGroup = await _dbContext.DefectGroups
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (defectGroup == null)
                    return false;

                _dbContext.DefectGroups.Remove(defectGroup);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<Defect>> GetAllDefectsAsync(string filter = "")
        {
            var query = _dbContext.Defects.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase) || e.DefectGroup.Name.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Defect
                {
                    Id = e.Id,
                    Name = e.Name,
                    DefectGroupId = e.DefectGroupId
                })
                .ToListAsync();
        }

        public async Task<int> CreateDefectAsync(Defect defect)
        {
            _dbContext.Defects.Add(defect);
            await _dbContext.SaveChangesAsync();
            return defect.Id;
        }
        public async Task<bool> UpdateDefectAsync(Defect defect)
        {
            var existDefect = await _dbContext.Defects
                .FirstOrDefaultAsync(e => e.Id == defect.Id);

            if (existDefect == null)
                return false;

            existDefect.Name = defect.Name;
            existDefect.DefectGroupId = defect.DefectGroupId;
            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteDefectAsync(int id)
        {
            try
            {
                var defect = await _dbContext.Defects
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (defect == null)
                    return false;

                _dbContext.Defects.Remove(defect);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<Nomenclature>> GetAllNomenclaturesAsync(string filter = "")
        {
            var query = _dbContext.Nomenclature.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase) || e.Article.ToLower().Contains(phrase) || e.Code.ToLower().Contains(phrase) || e.UnitOfMeasure.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Nomenclature
                {
                    Id = e.Id,
                    Name = e.Name,
                    Article = e.Article,
                    Code = e.Code,
                    UnitOfMeasure = e.UnitOfMeasure
                })
                .ToListAsync();
        }

        public async Task<int> CreateNomenclatureAsync(Nomenclature nomenclature)
        {
            _dbContext.Nomenclature.Add(nomenclature);
            await _dbContext.SaveChangesAsync();
            return nomenclature.Id;
        }

        public async Task<bool> UpdateNomenclatureAsync(Nomenclature nomenclature)
        {
            var existNomenclature = await _dbContext.Nomenclature
                .FirstOrDefaultAsync(e => e.Id == nomenclature.Id);

            if (existNomenclature == null)
                return false;

            existNomenclature.Name = nomenclature.Name;
            existNomenclature.Article = nomenclature.Article;
            existNomenclature.Code = nomenclature.Code;
            existNomenclature.UnitOfMeasure = nomenclature.UnitOfMeasure;
            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteNomenclatureAsync(int id)
        {
            try
            {
                var nomenclature = await _dbContext.Nomenclature
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (nomenclature == null)
                    return false;

                _dbContext.Nomenclature.Remove(nomenclature);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

//StockService.cs
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;
using WpfClient.Models;
using EFCore.BulkExtensions;

namespace RequestManagement.Server.Services
{
    public class StockService(ApplicationDbContext dbContext) : IStockService
    {
        private readonly ApplicationDbContext _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        private static IQueryable<Stock> ApplyQuantityFilter(
            IQueryable<Stock> query,
            Expression<Func<Stock, decimal>> quantitySelector,
            Helpers.QuantityFilter? filter)
        {
            if (filter is null) return query;

            return filter.Operator switch
            {
                Helpers.ComparisonOperator.GreaterThan => query.Where(BuildComparisonExpression(quantitySelector, filter.Value, ">")),
                Helpers.ComparisonOperator.EqualTo => query.Where(BuildComparisonExpression(quantitySelector, filter.Value, "==")),
                Helpers.ComparisonOperator.LessThan => query.Where(BuildComparisonExpression(quantitySelector, filter.Value, "<")),
                _ => query // Невозможный случай, если enum ограничен
            };
        }
        private static Expression<Func<Stock, bool>> BuildComparisonExpression(
            Expression<Func<Stock, decimal>> quantitySelector,
            decimal value,
            string comparisonOperator)
        {
            var parameter = quantitySelector.Parameters[0];
            var constant = Expression.Constant(value, typeof(decimal));

            var comparison = comparisonOperator switch
            {
                ">" => Expression.GreaterThan(quantitySelector.Body, constant),
                "==" => Expression.Equal(quantitySelector.Body, constant),
                "<" => Expression.LessThan(quantitySelector.Body, constant),
                _ => throw new ArgumentException("Неподдерживаемый оператор сравнения")
            };

            return Expression.Lambda<Func<Stock, bool>>(comparison, parameter);
        }

        public async Task<List<Stock>> GetAllStocksAsync(
            int warehouseId,
            string filter = "",
            int initialQuantityFilterType = 0,
            double initialQuantity = 0,
            int receivedQuantityFilterType = 0,
            double receivedQuantity = 0,
            int consumedQuantityFilterType = 0,
            double consumedQuantity = 0,
            int finalQuantityFilterType = 0,
            double finalQuantity = 0
            )
        {
            var query = _dbContext.Stocks
                .AsQueryable()
                .Where(s => s.WarehouseId == warehouseId);
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) =>
                    current.Where(s => EF.Functions.ILike(s.Nomenclature.Name, $"%{phrase}%") ||
                                       EF.Functions.ILike(s.Nomenclature.Article, $"%{phrase}%") ||
                                       EF.Functions.ILike(s.Nomenclature.Code, $"%{phrase}%")));
            }
            query = ApplyQuantityFilter(query, s => s.InitialQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)initialQuantity, initialQuantityFilterType));
            query = ApplyQuantityFilter(query, s => s.ReceivedQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)receivedQuantity, receivedQuantityFilterType));
            query = ApplyQuantityFilter(query, s => s.ConsumedQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)consumedQuantity, consumedQuantityFilterType));
            query = ApplyQuantityFilter(query, s => s.InitialQuantity + s.ReceivedQuantity - s.ConsumedQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)finalQuantity, finalQuantityFilterType));
            return await query
                .Select(s => new Stock
                {
                    Id = s.Id,
                    NomenclatureId = s.NomenclatureId,
                    WarehouseId = s.WarehouseId,
                    InitialQuantity = s.InitialQuantity,
                    ReceivedQuantity = s.ReceivedQuantity,
                    ConsumedQuantity = s.ConsumedQuantity,
                    Nomenclature = s.Nomenclature
                })
                .ToListAsync();
        }

        public async Task<bool> UploadMaterialsStockAsync(List<MaterialStock> materials, int warehouseId, DateTime date)
        {
            
        }

        public async Task<int> CreateStockAsync(Stock stock)
        {
            _dbContext.Stocks.Add(stock);
            await _dbContext.SaveChangesAsync();
            return stock.Id;
        }

        public async Task<bool> UpdateStockAsync(Stock stock)
        {
            var existingStock = await _dbContext.Stocks.FirstOrDefaultAsync(e => e.Id == stock.Id);
            if (existingStock == null)
                return false;
            existingStock.NomenclatureId = stock.NomenclatureId;
            existingStock.InitialQuantity = stock.InitialQuantity;
            await _dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteStockAsync(int id)
        {
            try
            {
                var stock = await _dbContext.Stocks.FirstOrDefaultAsync(e => e.Id == id);
                if (stock == null)
                    return false;
                _dbContext.Stocks.Remove(stock);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}


//UserService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Services
{
    /// <summary>
    /// Сервис для работы с пользователями
    /// </summary>
    public class UserService : IUserService
    {
        private readonly ApplicationDbContext _dbContext;

        public UserService(ApplicationDbContext dbContext)
        {
            _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        }

        /// <summary>
        /// Создает нового пользователя
        /// </summary>
        public async Task<int> CreateUserAsync(User user)
        {
            if (user == null)
                throw new ArgumentNullException(nameof(user));

            // Проверка на уникальность логина
            if (await _dbContext.Users.AnyAsync(u => u.Login == user.Login))
                throw new InvalidOperationException($"User with login '{user.Login}' already exists");

            // Хэшируем пароль перед сохранением
            user.Password = BCrypt.Net.BCrypt.HashPassword(user.Password);

            _dbContext.Users.Add(user);
            await _dbContext.SaveChangesAsync();
            return user.Id;
        }

        /// <summary>
        /// Обновляет данные пользователя
        /// </summary>
        public async Task<bool> UpdateUserAsync(User user)
        {
            if (user == null)
                throw new ArgumentNullException(nameof(user));

            var existingUser = await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == user.Id);

            if (existingUser == null)
                return false;

            // Проверка на уникальность логина (исключая текущего пользователя)
            if (await _dbContext.Users.AnyAsync(u => u.Login == user.Login && u.Id != user.Id))
                throw new InvalidOperationException($"Login '{user.Login}' is already taken by another user");

            existingUser.Login = user.Login;
            // Хэшируем новый пароль только если он изменился
            if (existingUser.Password != user.Password)
            {
                existingUser.Password = BCrypt.Net.BCrypt.HashPassword(user.Password);
            }
            existingUser.Role = user.Role;

            await _dbContext.SaveChangesAsync();
            return true;
        }

        /// <summary>
        /// Удаляет пользователя по идентификатору
        /// </summary>
        public async Task<bool> DeleteUserAsync(int userId)
        {
            var user = await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return false;

            _dbContext.Users.Remove(user);
            await _dbContext.SaveChangesAsync();
            return true;
        }

        /// <summary>
        /// Получает пользователя по идентификатору
        /// </summary>
        public async Task<User> GetUserByIdAsync(int userId)
        {
            return await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == userId);
        }

        /// <summary>
        /// Получает пользователя по логину
        /// </summary>
        public async Task<User> GetUserByLoginAsync(string login)
        {
            if (string.IsNullOrWhiteSpace(login))
                throw new ArgumentException("Login cannot be null or empty", nameof(login));

            return await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Login == login);
        }

        /// <summary>
        /// Проверяет, имеет ли пользователь указанную роль
        /// </summary>
        public async Task<bool> HasRoleAsync(int userId, UserRole role)
        {
            var user = await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == userId);

            return user != null && user.Role == role;
        }
    }
}

//WarehouseService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class WarehouseService(ApplicationDbContext dbContext) : IWarehouseService
    {
        private readonly ApplicationDbContext _dbContext =
            dbContext ?? throw new ArgumentNullException(nameof(dbContext));

        public async Task<List<Warehouse>> GetAllWarehousesAsync(string filter = "")
        {
            var query = _dbContext.Warehouses.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Warehouse
                {
                    Id = e.Id,
                    Name = e.Name,
                    LastUpdated = e.LastUpdated
                })
                .ToListAsync();
        }

        public async Task<Warehouse> GetOrCreateWarehousesAsync(string filter)
        {
            var query = _dbContext.Warehouses.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var normalizedFilter = filter.Trim().ToLower();
                query = query.Where(e => e.Name.ToLower() == normalizedFilter);
            }
            var result = await query
                .Select(e => new Warehouse
                {
                    Id = e.Id,
                    Name = e.Name,
                    LastUpdated = e.LastUpdated
                })
                .ToListAsync();
            if (result.Count != 0) return result[0];
            var newWarehouse = new Warehouse { Name = filter, LastUpdated = DateTime.Now };
            await _dbContext.Warehouses.AddAsync(newWarehouse);
            await _dbContext.SaveChangesAsync();
            return newWarehouse;
        }

        public async Task<int> CreateWarehouseAsync(Warehouse warehouse)
        {
            _dbContext.Warehouses.Add(warehouse);
            await _dbContext.SaveChangesAsync();
            return warehouse.Id;
        }

        public async Task<bool> UpdateWarehouseAsync(Warehouse warehouse)
        {
            var existWarehouse = await _dbContext.Warehouses
                .FirstOrDefaultAsync(e => e.Id == warehouse.Id);

            if (existWarehouse == null)
                return false;

            existWarehouse.Name = warehouse.Name;
            existWarehouse.LastUpdated = warehouse.LastUpdated;
            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteWarehouseAsync(int id)
        {
            try
            {
                var warehouse = await _dbContext.Warehouses
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (warehouse == null)
                    return false;

                _dbContext.Warehouses.Remove(warehouse);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}


//App.xaml
<Application x:Class="WpfClient.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
</Application>

//App.xaml.cs
// App.xaml.cs
using Microsoft.Extensions.DependencyInjection;
using System.Windows;
using WpfClient.ViewModels;
using WpfClient.Views;

namespace WpfClient;

public partial class App : Application
{
    public IServiceProvider ServiceProvider { get; private set; }

    protected override void OnStartup(StartupEventArgs e)
    {
        ServiceProvider = ServiceConfigurator.ConfigureServices();

        var viewModel = ServiceProvider.GetRequiredService<LoginViewModel>();
        var mainWindow = new MainWindow(viewModel);
        mainWindow.Show();
    }
}

//AssemblyInfo.cs
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]


//ServiceConfigurator.cs
// ServiceConfigurator.cs
using Microsoft.Extensions.DependencyInjection;
using RequestManagement.Common.Interfaces;
using RequestManagement.Server.Controllers;
using WpfClient.Services;
using WpfClient.Services.Interfaces;
using WpfClient.ViewModels;
using WpfClient.Views;

namespace WpfClient;

public class ServiceConfigurator
{
    public static IServiceProvider ConfigureServices()
    {
        var serviceCollection = new ServiceCollection();

        // gRPC клиенты
        serviceCollection.AddGrpcClient<AuthService.AuthServiceClient>(o => {o.Address = new Uri("http://localhost:5001"); });
        serviceCollection.AddGrpcClient<RequestService.RequestServiceClient>(o => {o.Address = new Uri("http://localhost:5001");});
        serviceCollection.AddGrpcClient<StockService.StockServiceClient>(o => { o.Address = new Uri("http://localhost:5001"); });
        serviceCollection.AddGrpcClient<ExpenseService.ExpenseServiceClient>(o => { o.Address = new Uri("http://localhost:5001"); });
        serviceCollection.AddGrpcClient<IncomingService.IncomingServiceClient>(o => { o.Address = new Uri("http://localhost:5001"); });
        serviceCollection.AddGrpcClient<WarehouseService.WarehouseServiceClient>(o => { o.Address = new Uri("http://localhost:5001"); });

        // Сервисы и ViewModel'ы
        serviceCollection.AddSingleton<AuthTokenStore>();
        serviceCollection.AddSingleton<IMessageBus, MessageBusService>();
        serviceCollection.AddSingleton<IGrpcClientFactory, GrpcClientFactory>();
        serviceCollection.AddSingleton<IExcelReaderService, ExcelReaderService>();

        serviceCollection.AddScoped<GrpcAuthService>();
        serviceCollection.AddScoped<LoginViewModel>();
        serviceCollection.AddScoped<EquipmentViewModel>();
        serviceCollection.AddScoped<MainMenuViewModel>();
        serviceCollection.AddScoped<DriverViewModel>();
        serviceCollection.AddScoped<DefectGroupViewModel>();
        serviceCollection.AddScoped<DefectViewModel>();
        serviceCollection.AddScoped<WarehouseViewModel>();
        serviceCollection.AddScoped<NomenclatureViewModel>();
        serviceCollection.AddScoped<StockViewModel>();
        serviceCollection.AddScoped<ExpenseViewModel>();
        serviceCollection.AddScoped<ExpenseListViewModel>();
        serviceCollection.AddScoped<IncomingListViewModel>();
        serviceCollection.AddScoped<StartDataLoadViewModel>();
        serviceCollection.AddScoped<IEquipmentService, GrpcEquipmentService>();
        serviceCollection.AddScoped<IDriverService, GrpcDriverService>();
        serviceCollection.AddScoped<IDefectService, GrpcDefectService>();
        serviceCollection.AddScoped<IWarehouseService, GrpcWarehouseService>();
        serviceCollection.AddScoped<INomenclatureService, GrpcNomenclatureService>();
        serviceCollection.AddScoped<IStockService, GrpcStockService>();
        serviceCollection.AddScoped<IExpenseService, GrpcExpenseService>();
        serviceCollection.AddScoped<IIncomingService, GrpcIncomingService>();
        serviceCollection.AddScoped<IWarehouseService, GrpcWarehouseService>();

        // Представления
        serviceCollection.AddTransient<MainWindow>();
        serviceCollection.AddTransient<DriverView>();
        serviceCollection.AddTransient<MainMenu>();
        serviceCollection.AddTransient<EquipmentView>();
        serviceCollection.AddTransient<DefectGroupView>();
        serviceCollection.AddTransient<DefectView>();
        serviceCollection.AddTransient<WarehouseView>();
        serviceCollection.AddTransient<NomenclatureView>();
        serviceCollection.AddTransient<StockView>();
        serviceCollection.AddTransient<ExpenseView>();
        serviceCollection.AddTransient<ExpenseListView>();
        serviceCollection.AddTransient<IncomingListView>();
        serviceCollection.AddTransient<StartDataLoadView>();

        return serviceCollection.BuildServiceProvider();
    }
}

//MessagesEnum.cs
namespace WpfClient.Messages;

public enum MessagesEnum
{
    DefectGroupUpdated,
    EquipmentUpdated,
    DriverUpdated,
    DefectUpdated,
    WarehouseUpdated,
    NomenclatureUpdated,
    StockUpdated,
    SelectNomenclature,
    SelectWarehouse,
    ShowExpenseDialog,
    SelectEquipment,
    SelectDriver,
    SelectDefect,
    SelectDefectGroup
}

//UpdatedMessage.cs
using RequestManagement.Common.Models.Interfaces;

namespace WpfClient.Messages;

public class UpdatedMessage(MessagesEnum message, Type? caller = null)
{
    public MessagesEnum Message { get; } = message;
}
public class SelectTaskMessage(MessagesEnum message, Type caller)
{
    public MessagesEnum Message { get; } = message;
    public Type Caller { get; } = caller;
}

public class ShowTaskMessage(MessagesEnum message, Type caller, bool editMode, int id, DateTime? date, decimal quantity, params IEntity?[] items)
{
    public MessagesEnum Message { get; } = message;
    public Type Caller { get; } = caller;
    public bool EditMode { get; } = editMode;
    public int Id { get; } = id;
    public DateTime? Date { get; } = date;
    public decimal Quantity { get; } = quantity;
    public IEntity?[] Item { get; } = items;
}
public class SelectResultMessage(MessagesEnum message, Type caller, IEntity? item = null)
{
    public MessagesEnum Message { get; } = message;
    public Type Caller { get; } = caller;
    public IEntity? Item { get; } = item;
}
public class ShowResultMessage(MessagesEnum message, Type caller)
{
    public MessagesEnum Message { get; } = message;
    public Type Caller { get; } = caller;
}

//AuthTokenStore.cs
using RequestManagement.Common.Models.Enums;

namespace WpfClient.Services;

public class AuthTokenStore
{
    private string _token;
    private UserRole _role;
    public void SetToken(string token) => _token = token;

    public string GetToken() => _token;

    public void ClearToken() => _token = null;

    public void SetRole(UserRole role) => _role = role;
    public UserRole GetRole() => _role;
}

//ExcelReaderService.cs
using OfficeOpenXml;
using System.IO;
using WpfClient.Models;
using WpfClient.Services.Interfaces;

namespace WpfClient.Services
{
    public class ExcelReaderService : IExcelReaderService
    {
        public ExcelReaderService()
        {
            ExcelPackage.License.SetNonCommercialPersonal("Thron41k");
        }
        public (List<MaterialStock> materialStocks, string? date, string? warehouse) ReadMaterialStock(string filePath)
        {
            if (!File.Exists(filePath))
                throw new FileNotFoundException("Excel file not found.", filePath);
            var materialStocks = new List<MaterialStock>();
            using var package = new ExcelPackage(new FileInfo(filePath));
            var worksheet = package.Workbook.Worksheets[0];
            var rowCount = worksheet.Dimension?.Rows + 2 ?? 0;
            const int startRow = 11;
            var date = worksheet.Cells[4, 3].Value.ToString()?.Split('-')[1].Trim();
            var warehouse = worksheet.Cells[10, 1].Value.ToString()?.Trim();
            for (var row = startRow; row < rowCount; row++)
            {
                if (worksheet.Cells[row, 1].Value == null && worksheet.Cells[row, 2].Value == null)
                    continue;
                try
                {
                    var material = new MaterialStock
                    {
                        ItemName = worksheet.Cells[row, 1].Value?.ToString()?.Trim() ?? string.Empty,
                        Code = worksheet.Cells[row, 5].Value?.ToString()?.Trim() ?? string.Empty,
                        Article = worksheet.Cells[row, 7].Value?.ToString()?.Trim() ?? string.Empty,
                        Unit = worksheet.Cells[row, 8].Value?.ToString()?.Trim() ?? string.Empty,
                        FinalBalance = double.TryParse(worksheet.Cells[row, 9].Value?.ToString()?.Trim(), out var balance) ? balance : 0
                    };
                    materialStocks.Add(material);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error processing row {row}: {ex.Message}");
                }
            }
            return (materialStocks, date, warehouse);
        }
    }
}


//GrpcAuthService.cs
using Grpc.Core;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;

namespace WpfClient.Services;

public class GrpcAuthService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore)
{
    private readonly AuthTokenStore _tokenStore = tokenStore ?? throw new ArgumentNullException(nameof(tokenStore));

    public async Task<AuthenticateResponse> AuthenticateAsync(string login, string password)
    {
        try
        {
            var request = new AuthenticateRequest { Login = login, Password = password };
            var authClient = clientFactory.CreateAuthClient();
            var response = await authClient.AuthenticateAsync(request);
            var token = response.Token;

            // Сохраняем токен в AuthTokenStore
            if (!string.IsNullOrEmpty(token))
            {
                _tokenStore.SetToken(token);
            }
            return (response.UserId == 0 ? null : response)!;
        }
        catch (RpcException ex)
        {
            throw new Exception($"Ошибка аутентификации: {ex.Status.Detail}", ex);
        }
    }
}

//GrpcClientFactory.cs
using Microsoft.Extensions.DependencyInjection;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;

namespace WpfClient.Services;

public class GrpcClientFactory(IServiceProvider serviceProvider) : IGrpcClientFactory
{
    public AuthService.AuthServiceClient CreateAuthClient()
    {
        return serviceProvider.GetRequiredService<AuthService.AuthServiceClient>();
    }

    public RequestService.RequestServiceClient CreateRequestClient()
    {
        return serviceProvider.GetRequiredService<RequestService.RequestServiceClient>();
    }
    public StockService.StockServiceClient CreateStockClient()
    {
        return serviceProvider.GetRequiredService<StockService.StockServiceClient>();
    }

    public ExpenseService.ExpenseServiceClient CreateExpenseClient()
    {
        return serviceProvider.GetRequiredService<ExpenseService.ExpenseServiceClient>();
    }

    public IncomingService.IncomingServiceClient CreateIncomingClient()
    {
        return serviceProvider.GetRequiredService<IncomingService.IncomingServiceClient>();
    }

    public WarehouseService.WarehouseServiceClient CreateWarehouseClient()
    {
        return serviceProvider.GetRequiredService<WarehouseService.WarehouseServiceClient>();
    }
}

//GrpcDefectService.cs
using RequestManagement.Common.Interfaces;
using RequestManagement.Server.Controllers;
using Defect = RequestManagement.Common.Models.Defect;
using DefectGroup = RequestManagement.Common.Models.DefectGroup;
using Grpc.Core;
using WpfClient.Services.Interfaces;

namespace WpfClient.Services;

public class GrpcDefectService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore) : IDefectService
{
    public async Task<List<DefectGroup>> GetAllDefectGroupsAsync(string filter = "")
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var response = await client.GetAllDefectGroupsAsync(new GetAllDefectGroupsRequest { Filter = filter }, headers);
        return response.DefectGroup.Select(defectGroup => new DefectGroup { Id = defectGroup.Id, Name = defectGroup.Name }).ToList();
    }

    public async Task<int> CreateDefectGroupAsync(DefectGroup defectGroup)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.CreateDefectGroupAsync(new CreateDefectGroupRequest { DefectGroup = new RequestManagement.Server.Controllers.DefectGroup { Name = defectGroup.Name } }, headers);
        return result.Id;
    }

    public async Task<bool> UpdateDefectGroupAsync(DefectGroup defectGroup)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.UpdateDefectGroupAsync(new UpdateDefectGroupRequest { DefectGroup = new RequestManagement.Server.Controllers.DefectGroup { Name = defectGroup.Name } }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteDefectGroupAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.DeleteDefectGroupAsync(new DeleteDefectGroupRequest { Id = id }, headers);
        return result.Success;
    }

    public async Task<List<Defect>> GetAllDefectsAsync(string filter = "")
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var response = await client.GetAllDefectsAsync(new GetAllDefectsRequest { Filter = filter }, headers);
        return response.Defect.Select(defect => new Defect { Id = defect.Id, Name = defect.Name, DefectGroupId = defect.DefectGroupId }).ToList();
    }

    public async Task<int> CreateDefectAsync(Defect defect)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.CreateDefectAsync(new CreateDefectRequest { Defect = new RequestManagement.Server.Controllers.Defect { Name = defect.Name, DefectGroupId = defect.DefectGroupId } }, headers);
        return result.Id;
    }

    public async Task<bool> UpdateDefectAsync(Defect defect)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.UpdateDefectAsync(new UpdateDefectRequest { Defect = new RequestManagement.Server.Controllers.Defect { Name = defect.Name, DefectGroupId = defect.DefectGroupId } }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteDefectAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.DeleteDefectAsync(new DeleteDefectRequest { Id = id }, headers);
        return result.Success;
    }
}

//GrpcDriverService.cs
using RequestManagement.Common.Interfaces;
using Grpc.Core;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;

namespace WpfClient.Services;

internal class GrpcDriverService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore) : IDriverService
{
    public async Task<List<RequestManagement.Common.Models.Driver>> GetAllDriversAsync(string filter = "")
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var response = await client.GetAllDriversAsync(new GetAllDriversRequest { Filter = filter }, headers);
        return response.Drivers.Select(driver => new RequestManagement.Common.Models.Driver { Id = driver.Id, FullName = driver.FullName, ShortName = driver.ShortName, Position = driver.Position}).ToList();
    }

    public async Task<int> CreateDriverAsync(RequestManagement.Common.Models.Driver driver)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.CreateDriverAsync(new CreateDriverRequest { Driver = new RequestManagement.Server.Controllers.Driver { FullName = driver.FullName, ShortName = driver.ShortName, Position = driver.Position }}, headers);
        return result.Id;
    }

    public async Task<bool> UpdateDriverAsync(RequestManagement.Common.Models.Driver driver)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.UpdateDriverAsync(new UpdateDriverRequest { Driver = new RequestManagement.Server.Controllers.Driver { Id = driver.Id, FullName = driver.FullName, ShortName = driver.ShortName, Position = driver.Position } }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteDriverAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.DeleteDriverAsync(new DeleteDriverRequest { Id = id }, headers);
        return result.Success;
    }
}

//GrpcEquipmentService.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;

namespace WpfClient.Services;

public class GrpcEquipmentService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore)
    : IEquipmentService
{
    public async Task<int> CreateEquipmentAsync(RequestManagement.Common.Models.Equipment equipment)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var request = new CreateEquipmentRequest { Name = equipment.Name, LicensePlate = equipment.StateNumber };
        var client = clientFactory.CreateRequestClient();
        var result = await client.CreateEquipmentAsync(request, headers);
        return result.Id;
    }

    public async Task<bool> UpdateEquipmentAsync(RequestManagement.Common.Models.Equipment equipment)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var request = new UpdateEquipmentRequest { Name = equipment.Name, LicensePlate = equipment.StateNumber };
        var client = clientFactory.CreateRequestClient();
        var result = await client.UpdateEquipmentAsync(request, headers);
        return result.Success;
    }

    public async Task<bool> DeleteEquipmentAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var request = new DeleteEquipmentRequest { Id = id};
        var client = clientFactory.CreateRequestClient();
        var result = await client.DeleteEquipmentAsync(request, headers);
        return result.Success;
    }

    public async Task<List<RequestManagement.Common.Models.Equipment>> GetAllEquipmentAsync(string filter = "")
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var response = await client.GetAllEquipmentAsync(new GetAllEquipmentRequest { Filter = filter }, headers);
        return response.Equipment.Select(equipment => new RequestManagement.Common.Models.Equipment { Id = equipment.Id, Name = equipment.Name, StateNumber = equipment.LicensePlate }).ToList();
    }
}

//GrpcExpenseService.cs
using System.Globalization;
using RequestManagement.Common.Interfaces;
using Grpc.Core;
using RequestManagement.Common.Models;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;
using Expense = RequestManagement.Common.Models.Expense;
using Stock = RequestManagement.Common.Models.Stock;

namespace WpfClient.Services;

internal class GrpcExpenseService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore) : IExpenseService
{
    public async Task<List<Expense>> GetAllExpensesAsync(string filter, int requestWarehouseId, int requestEquipmentId, int requestDriverId,
        int requestDefectId, string requestFromDate, string requestToDate)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateExpenseClient();
        var response = await client.GetAllExpensesAsync(
            new GetAllExpensesRequest
            {
                Filter = filter,
                WarehouseId = requestWarehouseId,
                EquipmentId = requestEquipmentId,
                DriverId = requestDriverId,
                DefectId = requestDefectId,
                FromDate = requestFromDate,
                ToDate = requestToDate
            }, headers);
        return response.Expenses.Select(expense => new Expense
        {
            Id = expense.Id,
            StockId = expense.Stock.Id,
            Stock = new Stock
            {
                Id = expense.Stock.Id,
                WarehouseId = expense.Stock.Warehouse.Id,
                Warehouse = new RequestManagement.Common.Models.Warehouse
                {
                    Id = expense.Stock.Warehouse.Id,
                    Name = expense.Stock.Warehouse.Name
                },
                NomenclatureId = expense.Stock.Nomenclature.Id,
                Nomenclature = new RequestManagement.Common.Models.Nomenclature
                {
                    Id = expense.Stock.Nomenclature.Id,
                    Name = expense.Stock.Nomenclature.Name,
                    Code = expense.Stock.Nomenclature.Code,
                    Article = expense.Stock.Nomenclature.Article,
                    UnitOfMeasure = expense.Stock.Nomenclature.UnitOfMeasure
                },
                InitialQuantity = (decimal)expense.Stock.InitialQuantity,
                ReceivedQuantity = (decimal)expense.Stock.ReceivedQuantity,
                ConsumedQuantity = (decimal)expense.Stock.ConsumedQuantity
            },
            EquipmentId = expense.Equipment.Id,
            Equipment = new RequestManagement.Common.Models.Equipment
            {
                Id = expense.Equipment.Id,
                Name = expense.Equipment.Name,
                StateNumber = expense.Equipment.LicensePlate
            },
            DriverId = expense.Driver.Id,
            Driver = new RequestManagement.Common.Models.Driver
            {
                Id = expense.Driver.Id,
                FullName = expense.Driver.FullName,
                ShortName = expense.Driver.ShortName,
                Position = expense.Driver.Position
            },
            DefectId = expense.Defect.Id,
            Defect = new RequestManagement.Common.Models.Defect
            {
                Id = expense.Defect.Id,
                Name = expense.Defect.Name,
                DefectGroupId = expense.Defect.DefectGroup.Id,
                DefectGroup = new RequestManagement.Common.Models.DefectGroup
                {
                    Id = expense.Defect.DefectGroup.Id,
                    Name = expense.Defect.DefectGroup.Name
                }
            },
            Date = Convert.ToDateTime(expense.Date),
            Quantity = (decimal)expense.Quantity
        }).ToList();
    }

    public async Task<Expense> CreateExpenseAsync(Expense expense)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateExpenseClient();
        var result = await client.CreateExpenseAsync(
            new CreateExpenseRequest
            { 
                StockId = expense.StockId,
                EquipmentId = expense.EquipmentId,
                DriverId = expense.DriverId,
                DefectId = expense.DefectId,
                Date = expense.Date.ToString(CultureInfo.CurrentCulture),
                Quantity = (double)expense.Quantity
            }, headers);
        expense.Id = result.Id;
        return expense;
    }

    public async Task<bool> UpdateExpenseAsync(Expense expense)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateExpenseClient();
        var result = await client.UpdateExpenseAsync(
            new UpdateExpenseRequest
            {
                Id = expense.Id,
                StockId = expense.StockId,
                EquipmentId = expense.EquipmentId,
                DriverId = expense.DriverId,
                DefectId = expense.DefectId,
                Date = expense.Date.ToString(CultureInfo.CurrentCulture),
                Quantity = (double)expense.Quantity
            }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteExpenseAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateExpenseClient();
        var result = await client.DeleteExpenseAsync(new DeleteExpenseRequest { Id = id }, headers);
        return result.Success;
    }

    public async Task<UserLastSelection?> GetUserLastSelectionAsync(int userId)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateExpenseClient();
        var result = await client.GetLastSelectionAsync(new GetLastSelectionRequest { NomenclatureId = userId }, headers);
        return new UserLastSelection
        {
            Driver = new RequestManagement.Common.Models.Driver { Id = result.Driver.Id, FullName = result.Driver.FullName, ShortName = result.Driver.ShortName, Position = result.Driver.Position },
            Equipment = new RequestManagement.Common.Models.Equipment { Id = result.Equipment.Id, Name = result.Equipment.Name, StateNumber = result.Equipment.LicensePlate },
            
        };
    }

    public Task SaveUserLastSelectionAsync(int userId, int? driverId, int? equipmentId)
    {
        throw new NotImplementedException();
    }

    public async Task<NomenclatureDefectMapping?> GetLastNomenclatureDefectMappingAsync(int userId, int nomenclatureId)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateExpenseClient();
        var result = await client.GetNomenclatureMapingAsync(new GetNomenclatureMapingRequest { NomenclatureId = nomenclatureId }, headers);
        var mapping = new NomenclatureDefectMapping();
        if (result is { Defect: not null })
        {
            mapping.Defect = new RequestManagement.Common.Models.Defect
                { Id = result.Defect.Id, Name = result.Defect.Name };
        }
        return mapping;
    }

    public Task SaveNomenclatureDefectMappingAsync(int userId, int nomenclatureId, int defectId)
    {
        throw new NotImplementedException();
    }

    public async Task<bool> DeleteExpensesAsync(List<int> requestIds)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateExpenseClient();
        var result = await client.DeleteExpensesAsync(new DeleteExpensesRequest {Id = { requestIds } }, headers);
        return result.Success;
    }
}

//GrpcIncomingService.cs
using System.Globalization;
using RequestManagement.Common.Interfaces;
using Grpc.Core;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;
using Incoming = RequestManagement.Common.Models.Incoming;
using Stock = RequestManagement.Common.Models.Stock;

namespace WpfClient.Services;

internal class GrpcIncomingService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore) : IIncomingService
{
    public async Task<List<Incoming>> GetAllIncomingsAsync(string filter, int requestWarehouseId, string requestFromDate, string requestToDate)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateIncomingClient();
        var response = await client.GetAllIncomingsAsync(
            new GetAllIncomingsRequest
            {
                Filter = filter,
                WarehouseId = requestWarehouseId,
                FromDate = requestFromDate,
                ToDate = requestToDate
            }, headers);
        return response.Incoming.Select(incoming => new Incoming
        {
            Id = incoming.Id,
            StockId = incoming.Stock.Id,
            Stock = new Stock
            {
                Id = incoming.Stock.Id,
                WarehouseId = incoming.Stock.Warehouse.Id,
                Warehouse = new RequestManagement.Common.Models.Warehouse
                {
                    Id = incoming.Stock.Warehouse.Id,
                    Name = incoming.Stock.Warehouse.Name
                },
                NomenclatureId = incoming.Stock.Nomenclature.Id,
                Nomenclature = new RequestManagement.Common.Models.Nomenclature
                {
                    Id = incoming.Stock.Nomenclature.Id,
                    Name = incoming.Stock.Nomenclature.Name,
                    Code = incoming.Stock.Nomenclature.Code,
                    Article = incoming.Stock.Nomenclature.Article,
                    UnitOfMeasure = incoming.Stock.Nomenclature.UnitOfMeasure
                },
                InitialQuantity = (decimal)incoming.Stock.InitialQuantity,
                ReceivedQuantity = (decimal)incoming.Stock.ReceivedQuantity,
                ConsumedQuantity = (decimal)incoming.Stock.ConsumedQuantity
            },
            Date = Convert.ToDateTime(incoming.Date),
            Quantity = (decimal)incoming.Quantity
        }).ToList();
    }

    public async Task<Incoming> CreateIncomingAsync(Incoming incoming)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateIncomingClient();
        var result = await client.CreateIncomingAsync(
            new CreateIncomingRequest
            { 
                StockId = incoming.StockId,
                Date = incoming.Date.ToString(CultureInfo.CurrentCulture),
                Quantity = (double)incoming.Quantity
            }, headers);
        incoming.Id = result.Id;
        return incoming;
    }

    public async Task<bool> UpdateIncomingAsync(Incoming incoming)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateIncomingClient();
        var result = await client.UpdateIncomingAsync(
            new UpdateIncomingRequest
            {
                Id = incoming.Id,
                StockId = incoming.StockId,
                Date = incoming.Date.ToString(CultureInfo.CurrentCulture),
                Quantity = (double)incoming.Quantity
            }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteIncomingAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateIncomingClient();
        var result = await client.DeleteIncomingAsync(new DeleteIncomingRequest { Id = id }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteIncomingsAsync(List<int> requestIds)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateIncomingClient();
        var result = await client.DeleteIncomingsAsync(new DeleteIncomingsRequest {Id = { requestIds } }, headers);
        return result.Success;
    }
}

//GrpcNomenclatureService.cs
using RequestManagement.Common.Interfaces;
using Grpc.Core;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;

namespace WpfClient.Services;

internal class GrpcNomenclatureService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore) : INomenclatureService
{
    public async Task<List<RequestManagement.Common.Models.Nomenclature>> GetAllNomenclaturesAsync(string filter = "")
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var response = await client.GetAllNomenclaturesAsync(new GetAllNomenclaturesRequest { Filter = filter }, headers);
        return response.Nomenclature.Select(nomenclature => new RequestManagement.Common.Models.Nomenclature { Id = nomenclature.Id, Name = nomenclature.Name,Code = nomenclature.Code,Article = nomenclature.Article,UnitOfMeasure = nomenclature.UnitOfMeasure}).ToList();
    }

    public async Task<int> CreateNomenclatureAsync(RequestManagement.Common.Models.Nomenclature nomenclature)
    {
        try
        {
            var headers = new Metadata();
            if (!string.IsNullOrEmpty(tokenStore.GetToken()))
            {
                headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
            }
            var client = clientFactory.CreateRequestClient();
            var result = await client.CreateNomenclatureAsync(new CreateNomenclatureRequest { Nomenclature = new RequestManagement.Server.Controllers.Nomenclature { Name = nomenclature.Name,Code = nomenclature.Code,Article = nomenclature.Article,UnitOfMeasure = nomenclature.UnitOfMeasure } }, headers);
            return result.Id;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            return -1;
        }
    }

    public async Task<bool> UpdateNomenclatureAsync(RequestManagement.Common.Models.Nomenclature nomenclature)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.UpdateNomenclatureAsync(new UpdateNomenclatureRequest { Nomenclature = new RequestManagement.Server.Controllers.Nomenclature { Id = nomenclature.Id, Name = nomenclature.Name,Code = nomenclature.Code,Article = nomenclature.Article,UnitOfMeasure = nomenclature.UnitOfMeasure } }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteNomenclatureAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateRequestClient();
        var result = await client.DeleteNomenclatureAsync(new DeleteNomenclatureRequest { Id = id }, headers);
        return result.Success;
    }
}

//GrpcStockService.cs
using RequestManagement.Common.Interfaces;
using Grpc.Core;
using RequestManagement.Server.Controllers;
using WpfClient.Models;
using WpfClient.Services.Interfaces;
using RequestManagement.Common.Models;
using System.Globalization;

namespace WpfClient.Services;

internal class GrpcStockService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore) : IStockService
{
    public async Task<List<RequestManagement.Common.Models.Stock>> GetAllStocksAsync(
        int warehouseId,
        string filter = "",
        int initialQuantityFilterType = 0,
        double initialQuantity = 0,
        int receivedQuantityFilterType = 0,
        double receivedQuantity = 0,
        int consumedQuantityFilterType = 0,
        double consumedQuantity = 0,
        int finalQuantityFilterType = 0,
        double finalQuantity = 0
        )
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateStockClient();
        var response = await client.GetAllStockAsync(
            new GetAllStocksRequest
            {
                WarehouseId = warehouseId,
                Filter = filter,
                InitialQuantityFilterType = initialQuantityFilterType,
                InitialQuantity = initialQuantity,
                ReceivedQuantityFilterType = receivedQuantityFilterType,
                ReceivedQuantity = receivedQuantity,
                ConsumedQuantityFilterType = consumedQuantityFilterType,
                ConsumedQuantity = consumedQuantity,
                FinalQuantityFilterType = finalQuantityFilterType,
                FinalQuantity = finalQuantity
            }, headers);
        return response.Stocks.Select(stock => new RequestManagement.Common.Models.Stock
        {
            Id = stock.Id,
            WarehouseId = stock.WarehouseId,
            NomenclatureId = stock.NomenclatureId,
            InitialQuantity = (decimal)stock.InitialQuantity,
            ReceivedQuantity = (decimal)stock.ReceivedQuantity,
            ConsumedQuantity = (decimal)stock.ConsumedQuantity,
            Nomenclature = new RequestManagement.Common.Models.Nomenclature{Code = stock.Nomenclature.Code, Name = stock.Nomenclature.Name, Article = stock.Nomenclature.Article, UnitOfMeasure = stock.Nomenclature.UnitOfMeasure},
        }).ToList();
    }

    public async Task<bool> UploadMaterialsStockAsync(List<MaterialStock>? materials, int warehouseId, DateTime date)
    {
        if(materials == null) return false;
        if (materials.Count == 0) return false;
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateStockClient();
        var result = await client.UploadMaterialStockAsync(new UploadMaterialStockRequest { Materials = { materials.Select(material => new MaterialStockMessage { Name = material.ItemName, Article = material.Article, Code = material.Code, Unit = material.Unit, FinalBalance = material.FinalBalance}) }, WarehouseId = warehouseId, Date = date.ToString(CultureInfo.CurrentCulture) }, headers);
        return result.Success;
    }

    public async Task<int> CreateStockAsync(RequestManagement.Common.Models.Stock stock)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateStockClient();
        var result = await client.CreateStockAsync(new CreateStockRequest { WarehouseId = stock.WarehouseId, NomenclatureId = stock.NomenclatureId, InitialQuantity = (double)stock.InitialQuantity }, headers);
        return result.Id;
    }

    public async Task<bool> UpdateStockAsync(RequestManagement.Common.Models.Stock stock)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateStockClient();
        var result = await client.UpdateStockAsync(new UpdateStockRequest { Id = stock.Id, NomenclatureId = stock.NomenclatureId, InitialQuantity = (double)stock.InitialQuantity }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteStockAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateStockClient();
        var result = await client.DeleteStockAsync(new DeleteStockRequest { Id = id }, headers);
        return result.Success;
    }
}

//GrpcWarehouseService.cs
using System.Globalization;
using RequestManagement.Common.Interfaces;
using Grpc.Core;
using RequestManagement.Server.Controllers;
using WpfClient.Services.Interfaces;
using Warehouse = RequestManagement.Common.Models.Warehouse;

namespace WpfClient.Services;

internal class GrpcWarehouseService(IGrpcClientFactory clientFactory, AuthTokenStore tokenStore) : IWarehouseService
{
    public async Task<List<Warehouse>> GetAllWarehousesAsync(string filter = "")
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateWarehouseClient();
        var response = await client.GetAllWarehousesAsync(new GetAllWarehousesRequest { Filter = filter }, headers);
        return response.Warehouse.Select(warehouse => new Warehouse { Id = warehouse.Id, Name = warehouse.Name, LastUpdated = DateTime.Parse(warehouse.LastUpdated) }).ToList();
    }

    public async Task<Warehouse> GetOrCreateWarehousesAsync(string filter)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateWarehouseClient();
        var response = await client.GetOrCreateWarehouseAsync(new GetOrCreateWarehouseRequest { Filter = filter }, headers);
        return new Warehouse { Id = response.Warehouse.Id, Name = response.Warehouse.Name, LastUpdated = DateTime.Parse(response.Warehouse.LastUpdated) };
    }

    public async Task<int> CreateWarehouseAsync(Warehouse warehouse)
    {
        try
        {
            var headers = new Metadata();
            if (!string.IsNullOrEmpty(tokenStore.GetToken()))
            {
                headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
            }
            var client = clientFactory.CreateWarehouseClient();
            var result = await client.CreateWarehouseAsync(new CreateWarehouseRequest { Warehouse = new RequestManagement.Server.Controllers.Warehouse { Name = warehouse.Name, LastUpdated = DateTime.Now.ToString(CultureInfo.CurrentCulture) } }, headers);
            return result.Id;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            return -1;
        }
    }

    public async Task<bool> UpdateWarehouseAsync(Warehouse warehouse)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateWarehouseClient();
        var result = await client.UpdateWarehouseAsync(new UpdateWarehouseRequest { Warehouse = new RequestManagement.Server.Controllers.Warehouse { Id = warehouse.Id, Name = warehouse.Name, LastUpdated = DateTime.Now.ToString(CultureInfo.CurrentCulture) } }, headers);
        return result.Success;
    }

    public async Task<bool> DeleteWarehouseAsync(int id)
    {
        var headers = new Metadata();
        if (!string.IsNullOrEmpty(tokenStore.GetToken()))
        {
            headers.Add("Authorization", $"Bearer {tokenStore.GetToken()}");
        }
        var client = clientFactory.CreateWarehouseClient();
        var result = await client.DeleteWarehouseAsync(new DeleteWarehouseRequest { Id = id }, headers);
        return result.Success;
    }
}

//MessageBusService.cs
using WpfClient.Services.Interfaces;

namespace WpfClient.Services;

public class MessageBusService : IMessageBus
{
    private readonly Dictionary<Type, List<object>> _subscribers = new();
    public void Subscribe<TMessage>(Func<TMessage, Task> handler)
    {
        if (handler == null) throw new ArgumentNullException(nameof(handler));

        var messageType = typeof(TMessage);
        if (!_subscribers.ContainsKey(messageType))
        {
            _subscribers[messageType] = [];
        }

        _subscribers[messageType].Add(handler);
    }
    public void Unsubscribe<TMessage>(Func<TMessage, Task> handler)
    {
        if (handler == null) throw new ArgumentNullException(nameof(handler));

        var messageType = typeof(TMessage);
        if (!_subscribers.TryGetValue(messageType, out var subscriber)) return;
        subscriber.Remove(handler);
        if (_subscribers[messageType].Count == 0)
        {
            _subscribers.Remove(messageType);
        }
    }
    public async Task Publish<TMessage>(TMessage message)
    {
        if (message == null) throw new ArgumentNullException(nameof(message));

        var messageType = typeof(TMessage);
        if (_subscribers.TryGetValue(messageType, out var subscriber))
        {
            var tasks = (from Func<TMessage, Task> asyncHandler in subscriber.ToArray() select asyncHandler(message)).ToList();
            await Task.WhenAll(tasks);
        }
    }
}

//BaseViewModel.cs
namespace WpfClient.ViewModels;

public class BaseViewModel : System.ComponentModel.INotifyPropertyChanged
{
    public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged([System.Runtime.CompilerServices.CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
    }
}

//DefectGroupViewModel.cs
using System.Collections.ObjectModel;
using System.ComponentModel;
using Timer = System.Timers.Timer;
using System.Windows.Input;
using System.Windows.Threading;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Server.Controllers;
using System.Runtime.CompilerServices;
using RequestManagement.Common.Interfaces;
using WpfClient.Services.Interfaces;
using WpfClient.Messages;

namespace WpfClient.ViewModels;

public class DefectGroupViewModel : INotifyPropertyChanged
{
    private readonly IMessageBus _messageBus;
    public event PropertyChangedEventHandler? PropertyChanged;
    private readonly IDefectService _requestService;
    private DefectGroup ? _selectedDefectGroup;
    private string _newDefectGroupName;
    private readonly Timer _filterTimer;
    private string _filterText;
    private readonly Dispatcher _dispatcher;
    public event EventHandler CloseWindowRequested;
    public ObservableCollection<DefectGroup> DefectGroupList { get; } = [];
    public ICommand LoadDefectGroupCommand { get; }
    public ICommand AddDefectGroupCommand { get; }
    public ICommand UpdateDefectGroupCommand { get; }
    public ICommand DeleteDefectGroupCommand { get; }
    public ICommand SelectRowCommand { get; }
    public DefectGroupViewModel(IDefectService requestService, IMessageBus messageBus)
    {
        _requestService = requestService;
        _messageBus = messageBus;
        LoadDefectGroupCommand = new RelayCommand(Execute1);
        AddDefectGroupCommand = new RelayCommand(Execute2);
        UpdateDefectGroupCommand = new RelayCommand(Execute3);
        DeleteDefectGroupCommand = new RelayCommand(Execute4);
        SelectRowCommand = new RelayCommand(Execute5);
        _dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new Timer(1000) { AutoReset = false }; // Задержка 1 секунда
        _filterTimer.Elapsed += async (s, e) => await LoadDefectGroupAsync();
        return;
        async void Execute4() => await DeleteDefectGroupAsync();
        async void Execute3() => await UpdateDefectGroupAsync();
        async void Execute2() => await AddDefectGroupAsync();
        async void Execute1() => await LoadDefectGroupAsync();
        void Execute5() => SelectAndClose();
    }

    public string NewDefectGroupName
    {
        get => _newDefectGroupName;
        set
        {
            if (_newDefectGroupName == value) return;
            _newDefectGroupName = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }

    public async Task Load()
    {
        await LoadDefectGroupAsync();
    }
    private async Task DeleteDefectGroupAsync()
    {
        if (_selectedDefectGroup != null)
        {
            await _requestService.DeleteDefectGroupAsync(_selectedDefectGroup.Id);
            await LoadDefectGroupAsync(); // Обновляем список после удаления
            NewDefectGroupName = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DefectGroupUpdated));
        }
    }
    private async Task LoadDefectGroupAsync()
    {
        var filter = string.IsNullOrWhiteSpace(_filterText) ? "" : _filterText.Trim();
        var defectGroupList = await _requestService.GetAllDefectGroupsAsync(filter.ToLower());
        await _dispatcher.InvokeAsync(() =>
        {
            DefectGroupList.Clear();
            foreach (var item in defectGroupList)
            {
                DefectGroupList.Add(new DefectGroup { Id = item.Id, Name = item.Name });
            }
            return Task.CompletedTask;
        });
    }
    private async Task UpdateDefectGroupAsync()
    {
        if (_selectedDefectGroup != null && !string.IsNullOrEmpty(NewDefectGroupName.Trim()))
        {
            await _requestService.UpdateDefectGroupAsync(new RequestManagement.Common.Models.DefectGroup
            {
                Id = _selectedDefectGroup.Id,
                Name = _selectedDefectGroup.Name,
            });
            await LoadDefectGroupAsync();
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DefectGroupUpdated));
        }
    }
    private async Task AddDefectGroupAsync()
    {
        if (!string.IsNullOrWhiteSpace(NewDefectGroupName.Trim()))
        {
            await _requestService.CreateDefectGroupAsync(new RequestManagement.Common.Models.DefectGroup
            {
                Name = NewDefectGroupName
            });
            await LoadDefectGroupAsync();
            NewDefectGroupName = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DefectGroupUpdated));
        }
    }
    public DefectGroup? SelectedDefectGroup
    {
        get => _selectedDefectGroup ?? null;
        set
        {
            _selectedDefectGroup = value;
            AddToEdit();
        }
    }

    public string FilterText
    {
        get => _filterText;
        set
        {
            if (_filterText == value) return;
            _filterText = value;
            OnPropertyChanged();
            _filterTimer.Stop(); // Сбрасываем таймер при каждом вводе
            _filterTimer.Start(); // Запускаем таймер заново
        }
    }
    private void AddToEdit()
    {
        if (_selectedDefectGroup != null)
        {
            NewDefectGroupName = _selectedDefectGroup.Name;
        }
    }
    private void SelectAndClose()
    {
        if (_selectedDefectGroup != null)
        {
            CloseWindowRequested.Invoke(this, EventArgs.Empty);
        }
    }

    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

//DefectViewModel.cs
using System.Collections.ObjectModel;
using System.ComponentModel;
using Timer = System.Timers.Timer;
using System.Windows.Input;
using System.Windows.Threading;
using CommunityToolkit.Mvvm.Input;
using System.Runtime.CompilerServices;
using RequestManagement.Common.Interfaces;
using WpfClient.Services.Interfaces;
using WpfClient.Messages;

namespace WpfClient.ViewModels;

public class DefectViewModel : INotifyPropertyChanged
{
    private readonly IMessageBus _messageBus;
    public event PropertyChangedEventHandler? PropertyChanged;
    private readonly IDefectService _requestService;
    private DefectViewItem? _selectedDefect;
    private int _selectedDefectGroupIndex;
    private List<RequestManagement.Common.Models.DefectGroup> _defectGroupList = [];
    private List<RequestManagement.Common.Models.Defect> _defectList = [];
    private string _newDefectName;
    private readonly Timer _filterTimer;
    private string _filterText;
    private readonly Dispatcher _dispatcher;
    public event EventHandler CloseWindowRequested;
    public ObservableCollection<DefectViewItem> DefectList { get; } = [];
    public ObservableCollection<string> DefectGroupList { get; } = [];
    public ICommand LoadDefectCommand { get; }
    public ICommand AddDefectCommand { get; }
    public ICommand UpdateDefectCommand { get; }
    public ICommand DeleteDefectCommand { get; }
    public ICommand SelectRowCommand { get; }
    public ICommand UpdateDefectGroupListCommand { get; }

    public DefectViewModel(IDefectService requestService, IMessageBus messageBus)
    {
        _requestService = requestService;
        _messageBus = messageBus;
        _messageBus.Subscribe<UpdatedMessage>(OnUpdated);
        LoadDefectCommand = new RelayCommand(Execute1);
        AddDefectCommand = new RelayCommand(Execute2);
        UpdateDefectCommand = new RelayCommand(Execute3);
        DeleteDefectCommand = new RelayCommand(Execute4);
        SelectRowCommand = new RelayCommand(Execute5);
        UpdateDefectGroupListCommand = new RelayCommand(Execute6);
        _dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new Timer(1000) { AutoReset = false }; // Задержка 1 секунда
        _filterTimer.Elapsed += async (s, e) => await LoadDefectAsync();
        return;
        async void Execute4() => await DeleteDefectAsync();
        async void Execute3() => await UpdateDefectAsync();
        async void Execute2() => await AddDefectAsync();
        async void Execute1() => await LoadDefectAsync();
        void Execute5() => SelectAndClose();
        async void Execute6() => await LoadDefectGroupAsync();
    }

    private async Task OnUpdated(UpdatedMessage obj)
    {
        if (obj.Message == MessagesEnum.DefectGroupUpdated)
        {
            await LoadDefectGroupAsync();
        }
    }

    public string NewDefectName
    {
        get => _newDefectName;
        set
        {
            if (_newDefectName == value) return;
            _newDefectName = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }

    public async Task Load()
    {
        await LoadDefectGroupAsync();
        await LoadDefectAsync();
    }
    private async Task DeleteDefectAsync()
    {
        if (_selectedDefect != null)
        {
            await _requestService.DeleteDefectAsync(_selectedDefect.Id);
            await LoadDefectAsync(); // Обновляем список после удаления
            NewDefectName = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DefectUpdated));
        }
    }

    private async Task LoadDefectGroupAsync()
    {
        var filter = string.IsNullOrWhiteSpace(_filterText) ? "" : _filterText.Trim();
        _defectGroupList = await _requestService.GetAllDefectGroupsAsync(filter.ToLower());
        await _dispatcher.InvokeAsync(() =>
        {
            DefectGroupList.Clear();
            foreach (var item in _defectGroupList)
            {
                DefectGroupList.Add(item.Name);
            }
            SelectedDefectGroupIndex = -1;
            return Task.CompletedTask;
        });
    }
    private async Task LoadDefectAsync()
    {
        var filter = string.IsNullOrWhiteSpace(_filterText) ? "" : _filterText.Trim();
        _defectList = await _requestService.GetAllDefectsAsync(filter.ToLower());
        await _dispatcher.InvokeAsync(() =>
        {
            DefectList.Clear();
            foreach (var item in _defectList)
            {
                DefectList.Add(new DefectViewItem(item, _defectGroupList.First(x => x.Id == item.DefectGroupId).Name));
            }
            return Task.CompletedTask;
        });
    }
    private async Task UpdateDefectAsync()
    {
        if (_selectedDefect != null && !string.IsNullOrEmpty(NewDefectName.Trim()) && SelectedDefectGroupIndex != -1)
        {
            await _requestService.UpdateDefectAsync(new RequestManagement.Common.Models.Defect
            {
                Id = _selectedDefect.Id,
                Name = _selectedDefect.Name,
                DefectGroupId = _defectGroupList[_selectedDefectGroupIndex].Id
            });
            await LoadDefectAsync();
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DefectUpdated));
        }
    }
    private async Task AddDefectAsync()
    {
        if (!string.IsNullOrWhiteSpace(NewDefectName.Trim()) && SelectedDefectGroupIndex != -1)
        {
            await _requestService.CreateDefectAsync(new RequestManagement.Common.Models.Defect
            {
                Name = NewDefectName,
                DefectGroupId = _defectGroupList[_selectedDefectGroupIndex].Id
            });
            await LoadDefectAsync();
            NewDefectName = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DefectUpdated));
        }
    }
    public DefectViewItem? SelectedDefect
    {
        get => _selectedDefect ?? null;
        set
        {
            _selectedDefect = value;
            AddToEdit();
        }
    }

    public int SelectedDefectGroupIndex
    {
        get => _selectedDefectGroupIndex;
        set
        {
            _selectedDefectGroupIndex = value;
            OnPropertyChanged();
        }
    }

    public string FilterText
    {
        get => _filterText;
        set
        {
            if (_filterText == value) return;
            _filterText = value;
            OnPropertyChanged();
            _filterTimer.Stop(); // Сбрасываем таймер при каждом вводе
            _filterTimer.Start(); // Запускаем таймер заново
        }
    }

    public bool EditMode { get; set; }

    private void AddToEdit()
    {
        if (_selectedDefect != null)
        {
            NewDefectName = _selectedDefect.Name;
            SelectedDefectGroupIndex = _defectGroupList.FindIndex(x => x.Id == _selectedDefect.DefectGroupId);
        }
    }
    private void SelectAndClose()
    {
        if (!EditMode &&  _selectedDefect != null)
        {
            CloseWindowRequested.Invoke(this, EventArgs.Empty);
        }
    }

    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }



    public class DefectViewItem(RequestManagement.Common.Models.Defect defect, string defectGroupName)
    {
        public int Id { get; set; } = defect.Id;
        public string Name { get; set; } = defect.Name;
        public int DefectGroupId { get; set; } = defect.DefectGroupId;
        public string DefectGroupName { get; set; } = defectGroupName;
    }
}

//DriverViewModel.cs
using System.ComponentModel;
using RequestManagement.Server.Controllers;
using System.Windows.Threading;
using System.Collections.ObjectModel;
using System.Windows.Input;
using Timer = System.Timers.Timer;
using System.Runtime.CompilerServices;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Interfaces;
using WpfClient.Services.Interfaces;
using WpfClient.Messages;

namespace WpfClient.ViewModels;

public class DriverViewModel : INotifyPropertyChanged
{
    private readonly IMessageBus _messageBus;
    public event PropertyChangedEventHandler? PropertyChanged;
    private readonly IDriverService _requestService;
    private Driver? _selectedDriver;
    private string _newDriverFullName;
    private string _newDriverShortName;
    private string _newDriverPosition;
    private readonly Timer _filterTimer;
    private string _filterText;
    private readonly Dispatcher _dispatcher;
    public event EventHandler CloseWindowRequested;
    public ObservableCollection<Driver> DriverList { get; } = [];
    public ICommand LoadDriverCommand { get; }
    public ICommand AddDriverCommand { get; }
    public ICommand UpdateDriverCommand { get; }
    public ICommand DeleteDriverCommand { get; }
    public ICommand SelectRowCommand { get; }

    public DriverViewModel(IDriverService requestService, IMessageBus messageBus)
    {
        _requestService = requestService;
        _messageBus = messageBus;
        LoadDriverCommand = new RelayCommand(Execute1);
        AddDriverCommand = new RelayCommand(Execute2);
        UpdateDriverCommand = new RelayCommand(Execute3);
        DeleteDriverCommand = new RelayCommand(Execute4);
        SelectRowCommand = new RelayCommand(Execute5);
        _dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new Timer(1000) { AutoReset = false }; // Задержка 1 секунда
        _filterTimer.Elapsed += async (s, e) => await LoadDriverAsync();
        return;
        async void Execute4() => await DeleteDriverAsync();
        async void Execute3() => await UpdateDriverAsync();
        async void Execute2() => await AddDriverAsync();
        async void Execute1() => await LoadDriverAsync();
        void Execute5() => SelectAndClose();
    }

    public string FilterText
    {
        get => _filterText;
        set
        {
            if (_filterText == value) return;
            _filterText = value;
            OnPropertyChanged();
            _filterTimer.Stop(); // Сбрасываем таймер при каждом вводе
            _filterTimer.Start(); // Запускаем таймер заново
        }
    }
    public async Task Load()
    {
        await LoadDriverAsync();
    }
    private async Task DeleteDriverAsync()
    {
        if (_selectedDriver != null)
        {
            await _requestService.DeleteDriverAsync(_selectedDriver.Id);
            await LoadDriverAsync(); // Обновляем список после удаления
            NewDriverFullName = string.Empty;
            NewDriverShortName = string.Empty;
            NewDriverPosition = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DriverUpdated));
        }
    }
    private async Task LoadDriverAsync()
    {
        var filter = string.IsNullOrWhiteSpace(_filterText) ? "" : _filterText.Trim();
        var driverList = await _requestService.GetAllDriversAsync(filter.ToLower());
        await _dispatcher.InvokeAsync(() =>
        {
            DriverList.Clear();
            foreach (var item in driverList)
            {
                DriverList.Add(new Driver { Id = item.Id, FullName = item.FullName, ShortName = item.ShortName, Position = item.Position });
            }
            return Task.CompletedTask;
        });
    }
    private async Task UpdateDriverAsync()
    {
        if (_selectedDriver != null && !string.IsNullOrEmpty(NewDriverFullName.Trim()) && !string.IsNullOrEmpty(NewDriverShortName.Trim()) && !string.IsNullOrEmpty(NewDriverPosition.Trim()))
        {
            await _requestService.UpdateDriverAsync(new RequestManagement.Common.Models.Driver { Id = _selectedDriver.Id, FullName = NewDriverFullName, ShortName = NewDriverShortName, Position = NewDriverPosition });
            await LoadDriverAsync();
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DriverUpdated));
        }
    }
    private async Task AddDriverAsync()
    {
        if (!string.IsNullOrWhiteSpace(NewDriverFullName.Trim()) && !string.IsNullOrWhiteSpace(NewDriverShortName.Trim()) && !string.IsNullOrWhiteSpace(NewDriverPosition.Trim()))
        {
            await _requestService.CreateDriverAsync(new RequestManagement.Common.Models.Driver { FullName = NewDriverFullName, ShortName = NewDriverShortName, Position = NewDriverPosition });
            await LoadDriverAsync();
            NewDriverFullName = string.Empty;
            NewDriverShortName = string.Empty;
            NewDriverPosition = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.DriverUpdated));
        }
    }

    public string NewDriverFullName
    {
        get => _newDriverFullName;
        set
        {
            if (_newDriverFullName == value) return;
            _newDriverFullName = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }

    public string NewDriverShortName
    {
        get => _newDriverShortName;
        set
        {
            if (_newDriverShortName == value) return;
            _newDriverShortName = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }

    public string NewDriverPosition
    {
        get => _newDriverPosition;
        set
        {
            if (_newDriverPosition == value) return;
            _newDriverPosition = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }

    public Driver? SelectedDriver
    {
        get => _selectedDriver ?? null;
        set
        {
            _selectedDriver = value;
            AddToEdit();
        }
    }

    public bool EditMode { get; set; }

    private void AddToEdit()
    {
        if (_selectedDriver != null)
        {
            NewDriverFullName = _selectedDriver.FullName;
            NewDriverShortName = _selectedDriver.ShortName;
            NewDriverPosition = _selectedDriver.Position;
        }
    }

    private void SelectAndClose()
    {
        if (!EditMode && _selectedDriver != null)
        {
            CloseWindowRequested?.Invoke(this, EventArgs.Empty);
        }
    }

    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

//EquipmentViewModel.cs
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Input;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Interfaces;
using RequestManagement.Server.Controllers;
using WpfClient.Messages;
using WpfClient.Services.Interfaces;
using Dispatcher = System.Windows.Threading.Dispatcher;
using Timer = System.Timers.Timer;


namespace WpfClient.ViewModels;

public class EquipmentViewModel : INotifyPropertyChanged
{
    private readonly IMessageBus _messageBus;
    public event PropertyChangedEventHandler PropertyChanged;
    private readonly IEquipmentService _requestService;
    private Equipment? _selectedEquipment;
    private string _newEquipmentLicensePlate;
    private string _newEquipmentName;
    private readonly Timer _filterTimer;
    private string _filterText;
    private readonly Dispatcher _dispatcher;
    public event EventHandler CloseWindowRequested;
    public ObservableCollection<Equipment> EquipmentList { get; } = [];
    public ICommand LoadEquipmentCommand { get; }
    public ICommand AddEquipmentCommand { get; }
    public ICommand UpdateEquipmentCommand { get; }
    public ICommand DeleteEquipmentCommand { get; }
    public ICommand SelectRowCommand { get; }

    public string FilterText
    {
        get => _filterText;
        set
        {
            if (_filterText == value) return;
            _filterText = value;
            OnPropertyChanged();
            _filterTimer.Stop(); // Сбрасываем таймер при каждом вводе
            _filterTimer.Start(); // Запускаем таймер заново
        }
    }

    public string NewEquipmentName {
        get => _newEquipmentName;
        set
        {
            if (_newEquipmentName == value) return;
            _newEquipmentName = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }
    public string NewEquipmentLicensePlate {
        get => _newEquipmentLicensePlate;
        set
        {
            if (_newEquipmentLicensePlate == value) return;
            _newEquipmentLicensePlate = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }

    public Equipment? SelectedEquipment
    {
        get => _selectedEquipment ?? null;
        set
        {
            _selectedEquipment = value;
            AddToEdit();
        }
    }

    public bool EditMode { get; set; }

    public EquipmentViewModel(IEquipmentService requestService, IMessageBus messageBus)
    {
        _requestService = requestService;
        _messageBus = messageBus;
        LoadEquipmentCommand = new RelayCommand(Execute);
        AddEquipmentCommand = new RelayCommand(Action);
        UpdateEquipmentCommand = new RelayCommand(Execute1);
        DeleteEquipmentCommand = new RelayCommand(Action1);
        SelectRowCommand = new RelayCommand(Action2);
        _dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new Timer(1000) { AutoReset = false }; // Задержка 1 секунда
        _filterTimer.Elapsed += async (s, e) => await LoadEquipmentAsync();
        return;

        async void Action1() => await DeleteEquipmentAsync();
        async void Execute1() => await UpdateEquipmentAsync();
        async void Action() => await AddEquipmentAsync();
        async void Execute() => await LoadEquipmentAsync();
        async void Action2() => await SelectAndClose();
    }

    private async Task SelectAndClose()
    {
        if (!EditMode && SelectedEquipment != null)
        {
            CloseWindowRequested?.Invoke(this, EventArgs.Empty);
        }
    }

    public async Task Load()
    {
        await LoadEquipmentAsync();
    }
    private async Task LoadEquipmentAsync()
    {
        var filter = string.IsNullOrWhiteSpace(_filterText) ? "" : _filterText.Trim();
        var equipmentList = await _requestService.GetAllEquipmentAsync(filter.ToLower());
        await _dispatcher.InvokeAsync(() =>
        {
            EquipmentList.Clear();
            foreach (var item in equipmentList)
            {
                EquipmentList.Add(new Equipment { Id = item.Id, Name = item.Name, LicensePlate = item.StateNumber });
            }
            return Task.CompletedTask;
        });
    }

    private Task AddToEdit()
    {
        if (_selectedEquipment != null)
        {
            NewEquipmentName = _selectedEquipment.Name;
            NewEquipmentLicensePlate = _selectedEquipment.LicensePlate;
        }
        return Task.CompletedTask;
    }
    private async Task AddEquipmentAsync()
    {
        if (!string.IsNullOrWhiteSpace(NewEquipmentName))
        {
            await _requestService.CreateEquipmentAsync(new RequestManagement.Common.Models.Equipment { Name = NewEquipmentName, StateNumber = NewEquipmentLicensePlate });
            await LoadEquipmentAsync(); // Обновляем список после добавления
            NewEquipmentName = string.Empty;
            NewEquipmentLicensePlate = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.EquipmentUpdated));
        }
    }

    private async Task UpdateEquipmentAsync()
    {
        if (_selectedEquipment != null && !string.IsNullOrEmpty(NewEquipmentName.Trim()))
        {
            await _requestService.UpdateEquipmentAsync(new RequestManagement.Common.Models.Equipment { Name = NewEquipmentName, StateNumber = NewEquipmentLicensePlate });
            await LoadEquipmentAsync(); // Обновляем список после изменения
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.EquipmentUpdated));
        }
    }

    private async Task DeleteEquipmentAsync()
    {
        if (_selectedEquipment != null)
        {
            await _requestService.DeleteEquipmentAsync(_selectedEquipment.Id);
            await LoadEquipmentAsync(); // Обновляем список после удаления
            NewEquipmentName = "";
            NewEquipmentLicensePlate = "";
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.EquipmentUpdated));
        }
    }
    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

//ExpenseListViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Interfaces;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Windows.Data;
using System.Windows.Threading;
using RequestManagement.Common.Models;
using WpfClient.Messages;
using WpfClient.Services.Interfaces;
using System.Windows;

namespace WpfClient.ViewModels;

public partial class ExpenseListViewModel : ObservableObject
{
    public bool EditMode { get; set; }
    private readonly IMessageBus _messageBus;
    private readonly IExpenseService _expenseService;
    [ObservableProperty] private string _menuDeleteItemText = "Удалить отмеченные";
    [ObservableProperty] private Expense? _selectedExpense = new();
    [ObservableProperty] private ObservableCollection<Expense> _expenses = [];
    [ObservableProperty] private Warehouse _selectedWarehouse = new();
    [ObservableProperty] private Defect _selectedDefect = new();
    [ObservableProperty] private Equipment _selectedEquipment = new();
    [ObservableProperty] private Driver _selectedDriver = new();
    [ObservableProperty] private string _searchText = "";
    [ObservableProperty] private DateTime _fromDate = DateTime.Parse("01.04.2025");
    [ObservableProperty] private DateTime _toDate = DateTime.Parse("30.04.2025");
    [ObservableProperty] private CollectionViewSource _expensesViewSource;
    private readonly System.Timers.Timer _filterTimer;

    public ExpenseListViewModel() { }
    public ExpenseListViewModel(IMessageBus messageBus, IExpenseService expenseService)
    {
        _messageBus = messageBus;
        _expenseService = expenseService;
        _messageBus.Subscribe<SelectResultMessage>(OnSelect);
        _expensesViewSource = new CollectionViewSource { Source = Expenses };
        var dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new System.Timers.Timer(1000) { AutoReset = false };
        _filterTimer.Elapsed += async (_, _) =>
        {
            await dispatcher.InvokeAsync(async () => { await LoadExpensesAsync(); });
        };
    }

    private async Task OnSelect(SelectResultMessage arg)
    {
        if (arg.Caller != typeof(ExpenseListViewModel) || arg.Item == null) return;
        switch (arg.Message)
        {
            case MessagesEnum.SelectWarehouse:
                SelectedWarehouse = (Warehouse)arg.Item;
                await LoadExpensesAsync();
                break;
            case MessagesEnum.SelectDefect:
                SelectedDefect = (Defect)arg.Item;
                await LoadExpensesAsync();
                break;
            case MessagesEnum.SelectEquipment:
                SelectedEquipment = (Equipment)arg.Item;
                await LoadExpensesAsync();
                break;
            case MessagesEnum.SelectDriver:
                SelectedDriver = (Driver)arg.Item;
                await LoadExpensesAsync();
                break;
        }
    }
    [RelayCommand]
    private async Task LoadExpensesAsync()
    {
        if (!ValidateDates()) return;
        if (SelectedWarehouse.Id == 0) return;
        var currentSortDescriptions = ExpensesViewSource.View?.SortDescriptions.ToList() ?? [];
        var expenseList = await _expenseService.GetAllExpensesAsync(SearchText, SelectedWarehouse.Id, SelectedEquipment.Id, SelectedDriver.Id, SelectedDefect.Id, FromDate.ToString(CultureInfo.CurrentCulture), ToDate.ToString(CultureInfo.CurrentCulture));
        Expenses = new ObservableCollection<Expense>(expenseList);
        ExpensesViewSource.Source = Expenses;
        if (currentSortDescriptions.Any())
        {
            foreach (var sortDescription in currentSortDescriptions)
            {
                ExpensesViewSource.View?.SortDescriptions.Add(sortDescription);
            }
        }
        ExpenseListCheckedUpdate();
    }
    public async Task Load()
    {
        await LoadExpensesAsync();
    }
    [RelayCommand]
    private async Task DoubleClick()
    {
        if (SelectedExpense != null)
        {
            await _messageBus.Publish(new ShowTaskMessage(MessagesEnum.ShowExpenseDialog, typeof(ExpenseListViewModel), true, SelectedExpense.Id, SelectedExpense.Date, SelectedExpense.Quantity, SelectedExpense.Stock, SelectedExpense.Equipment, SelectedExpense.Driver, SelectedExpense.Defect));
        }
    }
    [RelayCommand]
    private void ExpenseListCheckedUpdate()
    {
        MenuDeleteItemText = $"Удалить отмеченные({Expenses.Count(x => x.IsSelected)})";
    }
    [RelayCommand]
    private async Task ExpenseDeleteAsync()
    {
        if (SelectedExpense != null)
        {
            var result = await _expenseService.DeleteExpenseAsync(SelectedExpense.Id);
            if (result)
            {
                await LoadExpensesAsync();
            }
        }
    }
    [RelayCommand]
    private async Task ExpenseDeleteRangeAsync()
    {
        var list = Expenses.Where(x => x.IsSelected).Select(x => x.Id).ToList();
        if (list.Count > 0)
        {
            var result = await _expenseService.DeleteExpensesAsync(list);
            if (result)
            {
                await LoadExpensesAsync();
            }
        }
    }
    [RelayCommand]
    private void SelectAll()
    {
        foreach (var expense in Expenses)
        {
            expense.IsSelected = true;
        }

        ExpensesViewSource.View.Refresh(); // Принудительно обновляем DataGrid
        ExpenseListCheckedUpdate();
    }
    [RelayCommand]
    private void DeselectAll()
    {
        foreach (var expense in Expenses)
        {
            expense.IsSelected = false;
        }
        ExpensesViewSource.View.Refresh(); // Принудительно обновляем DataGrid
        ExpenseListCheckedUpdate();
    }
    [RelayCommand]
    private void InvertSelected()
    {
        foreach (var expense in Expenses)
        {
            expense.IsSelected = !expense.IsSelected;
        }
        ExpensesViewSource.View.Refresh(); // Принудительно обновляем DataGrid
        ExpenseListCheckedUpdate();
    }
    [RelayCommand]
    private async Task SelectWarehouse()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectWarehouse, typeof(ExpenseListViewModel)));
    }
    [RelayCommand]
    private async Task SelectDefect()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectDefect, typeof(ExpenseListViewModel)));
    }
    [RelayCommand]
    private async Task SelectEquipment()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectEquipment, typeof(ExpenseListViewModel)));
    }
    [RelayCommand]
    private async Task SelectDriver()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectDriver, typeof(ExpenseListViewModel)));
    }
    [RelayCommand]
    private async Task ClearSelectedWarehouse()
    {
        SelectedWarehouse = new Warehouse();
        await LoadExpensesAsync();
    }
    [RelayCommand]
    private async Task ClearSelectedDefect()
    {
        SelectedDefect = new Defect();
        await LoadExpensesAsync();
    }
    [RelayCommand]
    private async Task ClearSelectedEquipment()
    {
        SelectedEquipment = new Equipment();
        await LoadExpensesAsync();
    }
    [RelayCommand]
    private async Task ClearSelectedDriver()
    {
        SelectedDriver = new Driver();
        await LoadExpensesAsync();
    }
    [RelayCommand]
    private async Task ClearSearchText()
    {
        SearchText = "";
        await LoadExpensesAsync();
    }
    partial void OnSearchTextChanged(string value)
    {
        _filterTimer.Stop();
        _filterTimer.Start();
    }
    private bool ValidateDates()
    {
        // Проверка на нулевые или экстремальные значения
        if (FromDate == DateTime.MinValue || ToDate == DateTime.MinValue ||
            FromDate == DateTime.MaxValue || ToDate == DateTime.MaxValue)
        {
            MessageBox.Show("Пожалуйста, выберите корректные даты.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        // Проверка, что FromDate не позже ToDate
        if (FromDate > ToDate)
        {
            MessageBox.Show("Дата начала не может быть позже даты окончания.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        // Проверка на разумный диапазон (например, не раньше 2000 года и не в будущем)
        if (FromDate.Year < 2000 || ToDate.Year < 2000)
        {
            MessageBox.Show("Даты не могут быть раньше 2000 года.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        // Проверка на слишком большой диапазон (например, не больше года)
        if ((ToDate - FromDate).TotalDays > 365)
        {
            MessageBox.Show("Диапазон дат не должен превышать одного года.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        return true;
    }
}

//ExpenseViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Interfaces;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using RequestManagement.Common.Models;
using WpfClient.Messages;
using WpfClient.Services.Interfaces;

namespace WpfClient.ViewModels;

public partial class ExpenseViewModel : ObservableObject
{
    public bool EditMode { get; set; }
    public bool DialogResult { get; set; }
    private int _expenseId;
    private decimal _currentQuantity;
    private readonly IMessageBus _messageBus;
    private readonly IExpenseService _expenseService;
    [ObservableProperty] private RequestManagement.Common.Models.Stock? _expenseStock = new();
    [ObservableProperty] private RequestManagement.Common.Models.Equipment? _selectedEquipment = new();
    [ObservableProperty] private string _selectedEquipmentText = string.Empty;
    [ObservableProperty] private RequestManagement.Common.Models.Driver? _selectedDriver = new();
    [ObservableProperty] private RequestManagement.Common.Models.Defect? _selectedDefect = new();
    [ObservableProperty] private string _quantityForExpense = string.Empty;
    [ObservableProperty] private DateTime _selectedDate = DateTime.Now;
    public ExpenseViewModel(IMessageBus messageBus, IExpenseService expenseService)
    {
        _messageBus = messageBus;
        _expenseService = expenseService;
        _messageBus.Subscribe<SelectResultMessage>(OnShowDialog);
    }

    private Task OnShowDialog(SelectResultMessage arg)
    {
        if (arg.Caller == typeof(IExpenseService) && arg.Item != null)
        {
            switch (arg.Message)
            {
                case MessagesEnum.SelectEquipment:
                    SelectedEquipment = (RequestManagement.Common.Models.Equipment)arg.Item;
                    SelectedEquipmentText = $"{SelectedEquipment.Name} ({SelectedEquipment.StateNumber})";
                    break;
                case MessagesEnum.SelectDriver:
                    SelectedDriver = (RequestManagement.Common.Models.Driver)arg.Item;
                    break;
                case MessagesEnum.SelectDefect:
                    SelectedDefect = (RequestManagement.Common.Models.Defect)arg.Item;
                    break;
            }
        }
        return Task.CompletedTask;
    }

    public ExpenseViewModel()
    {

    }
    [RelayCommand]
    private async Task SelectEquipment()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectEquipment, typeof(IExpenseService)));
    }
    [RelayCommand]
    private async Task SelectDriver()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectDriver, typeof(IExpenseService)));
    }
    [RelayCommand]
    private async Task SelectDefect()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectDefect, typeof(IExpenseService)));
    }

    [RelayCommand]
    private void SetMaxQuantity()
    {
        QuantityForExpense = ExpenseStock?.FinalQuantity.ToString();
    }

    public void SetCurrentQuantity(decimal quantity)
    {
        _currentQuantity = quantity;
        QuantityForExpense = _currentQuantity.ToString(CultureInfo.InvariantCulture);
    }
    public void SetExpenseId(int id)
    {
        _expenseId = id;
    }

    public async Task LoadNomenclatureMapingAsync()
    {
        if (ExpenseStock != null && !EditMode)
        {
            var result = await _expenseService.GetLastNomenclatureDefectMappingAsync(-1, ExpenseStock.NomenclatureId);
            if (result is { Defect: not null } && SelectedDefect != null && SelectedDefect.Id != result.Defect.Id)
            {
                SelectedDefect = result.Defect;
            }
        }
    }

    public void SetEquipment(Equipment? equipment)
    {
        SelectedEquipment = equipment;
        SelectedEquipmentText = $"{SelectedEquipment.Name} ({SelectedEquipment.StateNumber})";
    }

    [RelayCommand]
    private async Task SaveExpenseToDatabase(UserControl window)
    {
        if (SelectedEquipment != null &&
            !string.IsNullOrEmpty(SelectedEquipmentText.Trim()) &&
            !string.IsNullOrEmpty(SelectedDriver?.FullName.Trim()) &&
            !string.IsNullOrEmpty(SelectedDefect?.Name.Trim()) &&
            !string.IsNullOrEmpty(QuantityForExpense.Trim()))
        {
            var convertResul = decimal.TryParse(QuantityForExpense.Replace(".", ","), out var quantityForExpense);
            if (convertResul)
            {
                var result = false;
                if (EditMode)
                {
                    if (quantityForExpense <= _currentQuantity + ExpenseStock?.FinalQuantity)
                    {
                        result = await _expenseService.UpdateExpenseAsync(
                            new RequestManagement.Common.Models.Expense
                            {
                                Id = _expenseId,
                                Quantity = quantityForExpense,
                                DefectId = SelectedDefect.Id,
                                DriverId = SelectedDriver.Id,
                                EquipmentId = SelectedEquipment.Id,
                                StockId = (int)ExpenseStock?.Id!,
                                Date = SelectedDate
                            });
                    }
                    else
                    {
                        MessageBox.Show("Введенное количество больше остатка на складе!", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }
                else
                {
                    if (quantityForExpense <= ExpenseStock?.FinalQuantity)
                        result = (await _expenseService.CreateExpenseAsync(new RequestManagement.Common.Models.Expense
                        {
                            Quantity = quantityForExpense,
                            DefectId = SelectedDefect.Id,
                            DriverId = SelectedDriver.Id,
                            EquipmentId = SelectedEquipment.Id,
                            StockId = (int)ExpenseStock?.Id!,
                            Date = SelectedDate
                        })).Id != 0;
                    else
                    {
                        MessageBox.Show("Введенное количество больше остатка на складе!", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }
                if (result)
                {
                    DialogResult = true;
                    ((Window)window.Parent).Close();
                };
            }
        }
    }
}

//IncomingListViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using System.Collections.ObjectModel;
using System.Windows.Data;
using System.Windows.Threading;
using WpfClient.Services.Interfaces;
using RequestManagement.Common.Interfaces;
using WpfClient.Messages;
using Incoming = RequestManagement.Common.Models.Incoming;
using CommunityToolkit.Mvvm.Input;
using System.Globalization;
using Warehouse = RequestManagement.Common.Models.Warehouse;
using System.Windows;

namespace WpfClient.ViewModels;

public partial class IncomingListViewModel : ObservableObject
{
    private readonly IMessageBus _messageBus;
    private readonly IIncomingService _incomingService;
    private readonly System.Timers.Timer _filterTimer;
    [ObservableProperty] private CollectionViewSource _incomingsViewSource;
    [ObservableProperty] private Incoming? _selectedIncoming = new();
    [ObservableProperty] private Warehouse _selectedWarehouse = new();
    [ObservableProperty] private ObservableCollection<Incoming> _incomings = [];
    [ObservableProperty] private string _menuDeleteItemText = "Удалить отмеченные";
    [ObservableProperty] private string _searchText = "";
    [ObservableProperty] private DateTime _fromDate = DateTime.Parse("01.04.2025");
    [ObservableProperty] private DateTime _toDate = DateTime.Parse("30.04.2025");
    public IncomingListViewModel() { }

    public IncomingListViewModel(IMessageBus messageBus, IIncomingService incomingService)
    {
        _messageBus = messageBus;
        _incomingService = incomingService;
        _messageBus.Subscribe<SelectResultMessage>(OnSelect);
        _incomingsViewSource = new CollectionViewSource { Source = Incomings };
        var dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new System.Timers.Timer(1000) { AutoReset = false };
        _filterTimer.Elapsed += async (_, _) =>
        {
            await dispatcher.InvokeAsync(async () => { await LoadIncomingsAsync(); });
        };
    }
    public async Task Load()
    {
        await LoadIncomingsAsync();
    }
    private async Task OnSelect(SelectResultMessage arg)
    {
        if (arg.Caller != typeof(IncomingListViewModel) || arg.Item == null) return;
        switch (arg.Message)
        {
            case MessagesEnum.SelectWarehouse:
                SelectedWarehouse = (Warehouse)arg.Item;
                await LoadIncomingsAsync();
                break;
        }
    }
    [RelayCommand]
    private async Task IncomingDeleteAsync()
    {
        if (SelectedIncoming != null)
        {
            var result = await _incomingService.DeleteIncomingAsync(SelectedIncoming.Id);
            if (result)
            {
                await LoadIncomingsAsync();
            }
        }
    }
    [RelayCommand]
    private async Task IncomingDeleteRangeAsync()
    {
        var list = Incomings.Where(x => x.IsSelected).Select(x => x.Id).ToList();
        if (list.Count > 0)
        {
            var result = await _incomingService.DeleteIncomingsAsync(list);
            if (result)
            {
                await LoadIncomingsAsync();
            }
        }
    }
    [RelayCommand]
    private void SelectAll()
    {
        foreach (var incoming in Incomings)
        {
            incoming.IsSelected = true;
        }

        IncomingsViewSource.View.Refresh(); // Принудительно обновляем DataGrid
        IncomingListCheckedUpdate();
    }
    [RelayCommand]
    private void DeselectAll()
    {
        foreach (var incoming in Incomings)
        {
            incoming.IsSelected = false;
        }
        IncomingsViewSource.View.Refresh(); // Принудительно обновляем DataGrid
        IncomingListCheckedUpdate();
    }
    [RelayCommand]
    private void InvertSelected()
    {
        foreach (var incoming in Incomings)
        {
            incoming.IsSelected = !incoming.IsSelected;
        }
        IncomingsViewSource.View.Refresh(); // Принудительно обновляем DataGrid
        IncomingListCheckedUpdate();
    }
    [RelayCommand]
    private async Task DoubleClick()
    {
        if (SelectedIncoming != null)
        {
            //await _messageBus.Publish(new ShowTaskMessage(MessagesEnum.ShowExpenseDialog, typeof(ExpenseListViewModel), true, SelectedExpense.Id, SelectedExpense.Date, SelectedExpense.Quantity, SelectedExpense.Stock, SelectedExpense.Equipment, SelectedExpense.Driver, SelectedExpense.Defect));
        }
    }
    [RelayCommand]
    private async Task LoadIncomingsAsync()
    {
        if (!ValidateDates()) return;
        if (SelectedWarehouse.Id == 0) return;
        var currentSortDescriptions = IncomingsViewSource.View?.SortDescriptions.ToList() ?? [];
        var incomingList = await _incomingService.GetAllIncomingsAsync(SearchText, SelectedWarehouse.Id, FromDate.ToString(CultureInfo.CurrentCulture), ToDate.ToString(CultureInfo.CurrentCulture));
        Incomings = new ObservableCollection<Incoming>(incomingList);
        IncomingsViewSource.Source = Incomings;
        if (currentSortDescriptions.Any())
        {
            foreach (var sortDescription in currentSortDescriptions)
            {
                IncomingsViewSource.View?.SortDescriptions.Add(sortDescription);
            }
        }
        IncomingListCheckedUpdate();
    }
    [RelayCommand]
    private void IncomingListCheckedUpdate()
    {
        MenuDeleteItemText = $"Удалить отмеченные({Incomings.Count(x => x.IsSelected)})";
    }
    [RelayCommand]
    private async Task SelectWarehouse()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectWarehouse, typeof(IncomingListViewModel)));
    }
    [RelayCommand]
    private async Task ClearSelectedWarehouse()
    {
        SelectedWarehouse = new Warehouse();
        await LoadIncomingsAsync();
    }
    [RelayCommand]
    private async Task ClearSearchText()
    {
        SearchText = "";
        await LoadIncomingsAsync();
    }
    partial void OnSearchTextChanged(string value)
    {
        _filterTimer.Stop();
        _filterTimer.Start();
    }
    private bool ValidateDates()
    {
        // Проверка на нулевые или экстремальные значения
        if (FromDate == DateTime.MinValue || ToDate == DateTime.MinValue ||
            FromDate == DateTime.MaxValue || ToDate == DateTime.MaxValue)
        {
            MessageBox.Show("Пожалуйста, выберите корректные даты.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        // Проверка, что FromDate не позже ToDate
        if (FromDate > ToDate)
        {
            MessageBox.Show("Дата начала не может быть позже даты окончания.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        // Проверка на разумный диапазон (например, не раньше 2000 года и не в будущем)
        if (FromDate.Year < 2000 || ToDate.Year < 2000)
        {
            MessageBox.Show("Даты не могут быть раньше 2000 года.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        // Проверка на слишком большой диапазон (например, не больше года)
        if ((ToDate - FromDate).TotalDays > 365)
        {
            MessageBox.Show("Диапазон дат не должен превышать одного года.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return false;
        }

        return true;
    }
}

//LoginViewModel.cs
using System.Windows;
using System.Windows.Input;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Models.Enums;
using WpfClient.Services;
using WpfClient.Views;

namespace WpfClient.ViewModels;

public class LoginViewModel
{
    private readonly GrpcAuthService _authService;
    private readonly MainMenuViewModel _mainMenuViewModel;
    private readonly AuthTokenStore _authTokenStore;

    public string Login { get; set; } = "admin";
    public string Password { get; set; } = "12345";
    public ICommand LoginCommand { get; }

    public LoginViewModel(GrpcAuthService authService, MainMenuViewModel mainMenuViewModel,AuthTokenStore authTokenStore)
    {
        _authService = authService;
        _mainMenuViewModel = mainMenuViewModel;
        _authTokenStore = authTokenStore;
        LoginCommand = new RelayCommand(async () => await LoginAsync());
    }

    private async Task LoginAsync()
    {
        var passwordBox = (Application.Current.MainWindow as MainWindow)?.passwordBox;
        if (passwordBox == null || string.IsNullOrWhiteSpace(Login) || string.IsNullOrWhiteSpace(passwordBox.Password))
        {
            MessageBox.Show("Введите логин и пароль.");
            return;
        }

        var token = await _authService.AuthenticateAsync(Login, passwordBox.Password);
        if (token != null && !string.IsNullOrEmpty(token.Token))
        {
            _authTokenStore.SetToken(token.Token);
            _authTokenStore.SetRole((UserRole)token.Role);
            var mainMenu = new MainMenu(_mainMenuViewModel);
            mainMenu.Show();
            Application.Current.MainWindow.Close();
        }
        else
        {
            MessageBox.Show("Ошибка входа. Проверьте логин и пароль.");
        }
    }
}

//MainMenuViewModel.cs
using System.Windows;
using System.Windows.Input;
using RequestManagement.Common.Models;
using WpfClient.Messages;
using WpfClient.Services.Interfaces;
using WpfClient.Views;
using System.Windows.Controls;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Models.Interfaces;

namespace WpfClient.ViewModels;

public class MainMenuViewModel
{
    private readonly EquipmentViewModel _equipmentViewModel;
    private readonly DriverViewModel _driverViewModel;
    private readonly DefectGroupViewModel _defectGroupViewModel;
    private readonly DefectViewModel _defectViewModel;
    private readonly WarehouseViewModel _warehouseViewModel;
    private readonly NomenclatureViewModel _nomenclatureViewModel;
    private readonly StockViewModel _stockViewModel;
    private readonly ExpenseViewModel _expenseViewModel;
    private readonly ExpenseListViewModel _expenseListViewModel;
    private readonly IncomingListViewModel _incomingListViewModel;
    private readonly StartDataLoadViewModel _startDataLoadViewModel;
    private readonly IMessageBus _messageBus;
    public UserControl StockControlProperty { get; }
    public ICommand ShowEquipmentCommand { get; }
    public ICommand ShowDriverCommand { get; }
    public ICommand ShowDefectGroupCommand { get; }
    public ICommand ShowDefectCommand { get; }
    public ICommand ShowWarehouseCommand { get; }
    public ICommand ShowNomenclatureCommand { get; }
    public ICommand ShowStockCommand { get; }
    public ICommand ShowExpensesCommand { get; }
    public ICommand ShowIncomingListCommand { get; }
    public ICommand ShowStartDataLoadingCommand { get; }

    public MainMenuViewModel(EquipmentViewModel equipmentViewModel, DriverViewModel driverViewModel, DefectGroupViewModel defectGroupViewModel, DefectViewModel defectViewModel, WarehouseViewModel warehouseViewModel, NomenclatureViewModel nomenclatureViewModel, IMessageBus messageBus, StockViewModel stockViewModel, ExpenseViewModel expenseViewModel, ExpenseListViewModel expenseListViewModel, IncomingListViewModel incomingListViewModel, StartDataLoadViewModel startDataLoadViewModel)
    {
        _equipmentViewModel = equipmentViewModel;
        _driverViewModel = driverViewModel;
        _defectGroupViewModel = defectGroupViewModel;
        _defectViewModel = defectViewModel;
        _warehouseViewModel = warehouseViewModel;
        _nomenclatureViewModel = nomenclatureViewModel;
        _messageBus = messageBus;
        _stockViewModel = stockViewModel;
        _expenseViewModel = expenseViewModel;
        _expenseListViewModel = expenseListViewModel;
        _incomingListViewModel = incomingListViewModel;
        _startDataLoadViewModel = startDataLoadViewModel;
        StockControlProperty = new StockView(_stockViewModel, true);
        _messageBus.Subscribe<SelectTaskMessage>(OnSelect);
        _messageBus.Subscribe<ShowTaskMessage>(OnShowDialog);
        ShowEquipmentCommand = new RelayCommand(ShowEquipment);
        ShowDriverCommand = new RelayCommand(ShowDriver);
        ShowDefectGroupCommand = new RelayCommand(ShowDefectGroup);
        ShowDefectCommand = new RelayCommand(ShowDefect);
        ShowWarehouseCommand = new RelayCommand(ShowWarehouse);
        ShowNomenclatureCommand = new RelayCommand(ShowNomenclature);
        ShowStockCommand = new RelayCommand(ShowStock);
        ShowExpensesCommand = new RelayCommand(ShowExpenses);
        ShowIncomingListCommand = new RelayCommand(ShowIncomingList);
        ShowStartDataLoadingCommand = new RelayCommand(ShowStartDataLoading);
    }

    private void ShowStartDataLoading()
    {
        var startDataLoadView = new StartDataLoadView(_startDataLoadViewModel);
        var window = new Window
        {
            Content = startDataLoadView,
            Title = "Загрузка начальных остатков",
            Width = 520,
            Height = 240,
            ResizeMode = ResizeMode.NoResize
        };
        _startDataLoadViewModel.Init();
        window.ShowDialog();
    }

    private async void ShowIncomingList()
    {
        var incomingView = new IncomingListView(_incomingListViewModel);
        var window = new Window
        {
            Content = incomingView,
            Title = "Приходы",
            Width = 620,
            Height = 330
        };
        await _incomingListViewModel.Load();
        window.ShowDialog();
    }

    private async void ShowExpenses()
    {
        var expenseView = new ExpenseListView(_expenseListViewModel);
        var window = new Window
        {
            Content = expenseView,
            Title = "Расходы",
            Width = 620,
            Height = 330
        };
        await _expenseListViewModel.Load();
        window.ShowDialog();
    }
    private void ShowStock()
    {
        ShowStock(true);
    }
    private void ShowNomenclature()
    {
        ShowNomenclature(true);
    }
    private void ShowWarehouse()
    {
        ShowWarehouse(true);
    }
    private void ShowDefect()
    {
        ShowDefect(true);
    }
    private void ShowDefectGroup()
    {
        ShowDefectGroup(true);
    }
    private void ShowDriver()
    {
        ShowDriver(true);
    }
    private void ShowEquipment()
    {
        ShowEquipment(true);
    }
    private Task OnSelect(SelectTaskMessage arg)
    {
        switch (arg.Message)
        {
            case MessagesEnum.SelectNomenclature:
                ShowNomenclature(false, arg.Caller);
                break;
            case MessagesEnum.SelectWarehouse:
                ShowWarehouse(false, arg.Caller);
                break;
            case MessagesEnum.SelectDefect:
                ShowDefect(false, arg.Caller);
                break;
            case MessagesEnum.SelectDefectGroup:
                ShowDefectGroup(false, arg.Caller);
                break;
            case MessagesEnum.SelectDriver:
                ShowDriver(false, arg.Caller);
                break;
            case MessagesEnum.SelectEquipment:
                ShowEquipment(false, arg.Caller);
                break;
        }

        return Task.CompletedTask;
    }
    private async Task OnShowDialog(ShowTaskMessage arg)
    {
        switch (arg.Message)
        {
            case MessagesEnum.ShowExpenseDialog:
                await ShowExpenseDialog(arg.EditMode, arg.Caller, arg.Id, arg.Date, arg.Quantity, arg.Item);
                break;
        }
    }
    private async Task ShowExpenseDialog(bool editMode, Type argCaller, int id, DateTime? date, decimal quantity, params IEntity?[] entity)
    {
        var expenseView = new ExpenseView(_expenseViewModel);
        var window = new Window
        {
            Content = expenseView,
            Title = editMode ? "Редактирование расхода" : "Добавить расход",
            Width = 620,
            Height = 330,
            ResizeMode = ResizeMode.NoResize
        };
        _expenseViewModel.SetExpenseId(id);
        _expenseViewModel.DialogResult = false;
        _expenseViewModel.EditMode = editMode;
        _expenseViewModel.SelectedEquipmentText = "";
        _expenseViewModel.QuantityForExpense = "";
        if (date != null) _expenseViewModel.SelectedDate = date.Value;
        _expenseViewModel.SetCurrentQuantity(quantity);
        if (entity[0] != null) _expenseViewModel.ExpenseStock = entity[0] as Stock;
        _expenseViewModel.SetEquipment(entity[1] != null ? entity[1] as Equipment : new Equipment());
        _expenseViewModel.SelectedDriver = entity[2] != null ? entity[2] as Driver : new Driver();
        _expenseViewModel.SelectedDefect = entity[3] != null ? entity[3] as Defect : _expenseViewModel.SelectedDefect;
        await _expenseViewModel.LoadNomenclatureMapingAsync();
        window.ShowDialog();
        if (_expenseViewModel.DialogResult)
        {
            if (editMode)
            {
                await _expenseListViewModel.Load();
            }
            else
            {
                await _stockViewModel.LoadLastSelectionHistoryAsync();
                await _stockViewModel.LoadStocksAsync();
            }
        }
    }
    private void ShowStock(bool editMode, Type? argCaller = null)
    {
        var stockView = new StockView(_stockViewModel, editMode);
        var window = new Window
        {
            Content = stockView,
            Title = "Остатки на складах",
            Width = 1000,
            Height = 600
        };
        _stockViewModel.EditMode = editMode;
        window.ShowDialog();
    }
    private void ShowEquipment(bool editMode, Type? argCaller = null)
    {
        var equipmentView = new EquipmentView(_equipmentViewModel);
        var window = new Window
        {
            Content = equipmentView,
            Title = "Транспорт и ДСТ",
            Width = 800,
            Height = 600
        };
        _equipmentViewModel.EditMode = editMode;
        _ = _equipmentViewModel.Load();
        window.ShowDialog();
        if (_equipmentViewModel.SelectedEquipment != null && argCaller != null)
            _messageBus.Publish(
                new SelectResultMessage(
                    MessagesEnum.SelectEquipment, argCaller, new Equipment
                    {
                        Id = _equipmentViewModel.SelectedEquipment.Id,
                        Name = _equipmentViewModel.SelectedEquipment.Name,
                        StateNumber = _equipmentViewModel.SelectedEquipment.LicensePlate
                    }));
    }
    private void ShowDriver(bool editMode, Type? argCaller = null)
    {
        var driverView = new DriverView(_driverViewModel);
        var window = new Window
        {
            Content = driverView,
            Title = "Сотрудники",
            Width = 800,
            Height = 600
        };
        _ = _driverViewModel.Load();
        _driverViewModel.EditMode = editMode;
        window.ShowDialog();
        if (_driverViewModel.SelectedDriver != null && argCaller != null)
            _messageBus.Publish(
                new SelectResultMessage(
                    MessagesEnum.SelectDriver, argCaller, new Driver
                    {
                        Id = _driverViewModel.SelectedDriver.Id,
                        FullName = _driverViewModel.SelectedDriver.FullName,
                        ShortName = _driverViewModel.SelectedDriver.ShortName
                    }));
    }
    private void ShowDefectGroup(bool editMode, Type? argCaller = null)
    {
        var defectGroupView = new DefectGroupView(_defectGroupViewModel, editMode);
        var window = new Window
        {
            Content = defectGroupView,
            Title = "Группы дефектов",
            Width = 800,
            Height = 600
        };
        _ = _defectGroupViewModel.Load();
        window.ShowDialog();
    }
    private void ShowDefect(bool editMode, Type? argCaller = null)
    {
        var defectView = new DefectView(_defectViewModel);
        var window = new Window
        {
            Content = defectView,
            Title = "Дефекты",
            Width = 800,
            Height = 600
        };
        _ = _defectViewModel.Load();
        _defectViewModel.EditMode = editMode;
        window.ShowDialog();
        if (_defectViewModel.SelectedDefect != null && argCaller != null)
            _messageBus.Publish(
                new SelectResultMessage(
                    MessagesEnum.SelectDefect, argCaller, new Defect
                    {
                        Id = _defectViewModel.SelectedDefect.Id,
                        Name = _defectViewModel.SelectedDefect.Name
                    }));
    }
    private void ShowWarehouse(bool editMode, Type? argCaller = null)
    {
        var warehouseView = new WarehouseView(_warehouseViewModel, editMode);
        var window = new Window
        {
            Content = warehouseView,
            Title = "Склады",
            Width = 800,
            Height = 600
        };
        _ = _warehouseViewModel.Load();
        window.ShowDialog();
        if (_warehouseViewModel.SelectedWarehouse != null && argCaller != null)
        {
            _messageBus.Publish(
                new SelectResultMessage(
                    MessagesEnum.SelectWarehouse, argCaller, new Warehouse
                    {
                        Id = _warehouseViewModel.SelectedWarehouse.Id,
                        Name = _warehouseViewModel.SelectedWarehouse.Name
                    }));
        }
    }
    private void ShowNomenclature(bool editMode, Type? argCaller = null)
    {
        var nomenclatureView = new NomenclatureView(_nomenclatureViewModel, editMode);
        var window = new Window
        {
            Content = nomenclatureView,
            Title = "Номенклатура",
            Width = 800,
            Height = 600
        };
        _ = _nomenclatureViewModel.Load();
        window.ShowDialog();
        if (_nomenclatureViewModel.SelectedNomenclature != null && argCaller != null)
            _messageBus.Publish(
                new SelectResultMessage(
                    MessagesEnum.SelectNomenclature, argCaller, new Nomenclature
                    {
                        Id = _nomenclatureViewModel.SelectedNomenclature.Id,
                        Code = _nomenclatureViewModel.SelectedNomenclature.Code,
                        Article = _nomenclatureViewModel.SelectedNomenclature.Article,
                        Name = _nomenclatureViewModel.SelectedNomenclature.Name,
                        UnitOfMeasure = _nomenclatureViewModel.SelectedNomenclature.UnitOfMeasure
                    }));

    }
}

//NomenclatureViewModel.cs
using System.ComponentModel;
using RequestManagement.Server.Controllers;
using System.Windows.Threading;
using System.Collections.ObjectModel;
using System.Windows.Input;
using Timer = System.Timers.Timer;
using System.Runtime.CompilerServices;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Interfaces;
using WpfClient.Services.Interfaces;
using WpfClient.Messages;

namespace WpfClient.ViewModels;

public class NomenclatureViewModel : INotifyPropertyChanged
{
    private readonly IMessageBus _messageBus;
    public event PropertyChangedEventHandler? PropertyChanged;
    private readonly INomenclatureService _requestService;
    private Nomenclature? _selectedNomenclature;
    private string _newNomenclatureCode;
    private string _newNomenclatureName;
    private string _newNomenclatureArticle;
    private string _newNomenclatureUnitOfMeasure;
    private readonly Timer _filterTimer;
    private string _filterText;
    private readonly Dispatcher _dispatcher;
    public event EventHandler CloseWindowRequested;
    public ObservableCollection<Nomenclature> NomenclatureList { get; } = [];
    public ICommand LoadNomenclatureCommand { get; }
    public ICommand AddNomenclatureCommand { get; }
    public ICommand UpdateNomenclatureCommand { get; }
    public ICommand DeleteNomenclatureCommand { get; }
    public ICommand SelectRowCommand { get; }

    public NomenclatureViewModel(INomenclatureService requestService, IMessageBus messageBus)
    {
        _requestService = requestService;
        _messageBus = messageBus;
        LoadNomenclatureCommand = new RelayCommand(Execute1);
        AddNomenclatureCommand = new RelayCommand(Execute2);
        UpdateNomenclatureCommand = new RelayCommand(Execute3);
        DeleteNomenclatureCommand = new RelayCommand(Execute4);
        SelectRowCommand = new RelayCommand(Execute5);
        _dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new Timer(1000) { AutoReset = false }; // Задержка 1 секунда
        _filterTimer.Elapsed += async (s, e) => await LoadNomenclatureAsync();
        return;
        async void Execute4() => await DeleteNomenclatureAsync();
        async void Execute3() => await UpdateNomenclatureAsync();
        async void Execute2() => await AddNomenclatureAsync();
        async void Execute1() => await LoadNomenclatureAsync();
        void Execute5() => SelectAndClose();
    }

    public string FilterText
    {
        get => _filterText;
        set
        {
            if (_filterText == value) return;
            _filterText = value;
            OnPropertyChanged();
            _filterTimer.Stop(); // Сбрасываем таймер при каждом вводе
            _filterTimer.Start(); // Запускаем таймер заново
        }
    }
    public async Task Load()
    {
        await LoadNomenclatureAsync();
    }
    private async Task DeleteNomenclatureAsync()
    {
        if (_selectedNomenclature != null)
        {
            await _requestService.DeleteNomenclatureAsync(_selectedNomenclature.Id);
            await LoadNomenclatureAsync(); // Обновляем список после удаления
            NewNomenclatureName = string.Empty;
            NewNomenclatureCode = string.Empty;
            NewNomenclatureUnitOfMeasure = string.Empty;
            NewNomenclatureArticle = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.NomenclatureUpdated));
        }
    }
    private async Task LoadNomenclatureAsync()
    {
        var filter = string.IsNullOrWhiteSpace(_filterText) ? "" : _filterText.Trim();
        var driverList = await _requestService.GetAllNomenclaturesAsync(filter.ToLower());
        await _dispatcher.InvokeAsync(() =>
        {
            NomenclatureList.Clear();
            foreach (var item in driverList)
            {
                NomenclatureList.Add(new Nomenclature { Id = item.Id, Name = item.Name, Code = item.Code, Article = item.Article, UnitOfMeasure = item.UnitOfMeasure });
            }
            return Task.CompletedTask;
        });
    }
    private async Task UpdateNomenclatureAsync()
    {
        if (_selectedNomenclature != null && !string.IsNullOrEmpty(NewNomenclatureName.Trim()) && !string.IsNullOrEmpty(NewNomenclatureCode.Trim()) && !string.IsNullOrEmpty(NewNomenclatureUnitOfMeasure.Trim()))
        {
            await _requestService.UpdateNomenclatureAsync(new RequestManagement.Common.Models.Nomenclature { Id = _selectedNomenclature.Id, Name = NewNomenclatureName, Code = NewNomenclatureCode, Article = NewNomenclatureArticle, UnitOfMeasure = NewNomenclatureUnitOfMeasure });
            await LoadNomenclatureAsync();
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.NomenclatureUpdated));
        }
    }
    private async Task AddNomenclatureAsync()
    {
        if (!string.IsNullOrWhiteSpace(NewNomenclatureName.Trim()) && !string.IsNullOrWhiteSpace(NewNomenclatureCode.Trim()) && !string.IsNullOrWhiteSpace(NewNomenclatureUnitOfMeasure.Trim()))
        {
            await _requestService.CreateNomenclatureAsync(new RequestManagement.Common.Models.Nomenclature { Name = NewNomenclatureName, Code = NewNomenclatureCode, Article = NewNomenclatureArticle, UnitOfMeasure = NewNomenclatureUnitOfMeasure });
            await LoadNomenclatureAsync();
            NewNomenclatureName = string.Empty;
            NewNomenclatureCode = string.Empty;
            NewNomenclatureUnitOfMeasure = string.Empty;
            NewNomenclatureArticle = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.NomenclatureUpdated));
        }
    }

    public string NewNomenclatureCode
    {
        get => _newNomenclatureCode;
        set
        {
            if (_newNomenclatureCode == value) return;
            _newNomenclatureCode = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }
    public string NewNomenclatureName
    {
        get => _newNomenclatureName;
        set
        {
            if (_newNomenclatureName == value) return;
            _newNomenclatureName = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }
    public string NewNomenclatureArticle
    {
        get => _newNomenclatureArticle;
        set
        {
            if (_newNomenclatureArticle == value) return;
            _newNomenclatureArticle = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }
    public string NewNomenclatureUnitOfMeasure
    {
        get => _newNomenclatureUnitOfMeasure;
        set
        {
            if (_newNomenclatureUnitOfMeasure == value) return;
            _newNomenclatureUnitOfMeasure = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }
    public Nomenclature? SelectedNomenclature
    {
        get => _selectedNomenclature ?? null;
        set
        {
            _selectedNomenclature = value;
            AddToEdit();
        }
    }

    private void AddToEdit()
    {
        if (_selectedNomenclature != null)
        {
            NewNomenclatureName = _selectedNomenclature.Name;
            NewNomenclatureCode = _selectedNomenclature.Code;
            NewNomenclatureArticle = _selectedNomenclature.Article;
            NewNomenclatureUnitOfMeasure = _selectedNomenclature.UnitOfMeasure;
        }
    }

    private void SelectAndClose()
    {
        if (_selectedNomenclature != null)
        {
            CloseWindowRequested?.Invoke(this, EventArgs.Empty);
        }
    }

    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

//StartDataLoadViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.Input;
using WpfClient.Messages;
using WpfClient.Services.Interfaces;
using System.Collections.ObjectModel;
using WpfClient.Models;
using Microsoft.Win32;
using System.Windows;
using RequestManagement.Common.Models;
using RequestManagement.Common.Interfaces;

namespace WpfClient.ViewModels
{
    public partial class StartDataLoadViewModel : ObservableObject
    {
        private readonly IMessageBus _messageBus;
        private readonly IExcelReaderService _excelReaderService;
        private readonly IWarehouseService _requestService;
        private readonly IStockService _stockService;
        [ObservableProperty] private bool _isBusy;
        [ObservableProperty] private string _documentPath = "";
        [ObservableProperty] private List<MaterialStock> _materialStocks = [];
        [ObservableProperty] private Warehouse _selectedWarehouse = new();
        [ObservableProperty] private DateTime _toDate = DateTime.Now;
        public StartDataLoadViewModel()
        {
           
        }

        public StartDataLoadViewModel(IMessageBus messageBus, IExcelReaderService excelReaderService, IWarehouseService requestService, IStockService stockService)
        {
            _messageBus = messageBus;
            _excelReaderService = excelReaderService;
            _requestService = requestService;
            _stockService = stockService;
            _messageBus.Subscribe<SelectResultMessage>(OnSelect);
        }

        public void Init()
        {
            DocumentPath = "";
            MaterialStocks = [];
            SelectedWarehouse = new Warehouse();
            ToDate = DateTime.Now;
        }

        private Task OnSelect(SelectResultMessage arg)
        {
            if (arg.Caller != typeof(StartDataLoadViewModel) || arg.Item == null) return Task.CompletedTask;
            switch (arg.Message)
            {
                case MessagesEnum.SelectWarehouse:
                    SelectedWarehouse = (Warehouse)arg.Item;
                    break;
            }

            return Task.CompletedTask;
        }

        [RelayCommand]
        private void ClearDocumentPath()
        {
            DocumentPath = "";
        }

        [RelayCommand]
        private async Task UploadMaterials()
        {
            try
            {
                IsBusy = true;
                var result =
                    await _stockService.UploadMaterialsStockAsync(MaterialStocks, SelectedWarehouse.Id, ToDate);
                if (result)
                {
                    MessageBox.Show("Data uploaded successfully", "Success", MessageBoxButton.OK,
                        MessageBoxImage.Information);
                }
                else
                {
                    MessageBox.Show("Error uploading data", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading data: {ex.Message}");
            }
            finally
            {
                IsBusy = false;
            }
        }

        [RelayCommand]
        private async Task SelectDocumentPath()
        {
            try
            {
                var openFile = new OpenFileDialog
                {
                    Filter = "Excel files (*.xlsx)|*.xlsx"
                };
                var dialogResult = openFile.ShowDialog();
                if (dialogResult == true && openFile.FileName.Length > 0)
                {
                    DocumentPath = openFile.FileName;
                    var result = _excelReaderService.ReadMaterialStock(DocumentPath);
                    if (result.materialStocks is { Count: > 0 })
                    {
                        MaterialStocks = result.materialStocks;
                        if (result.date != null) ToDate = DateTime.Parse(result.date);
                        if (result.warehouse != null)
                        {
                            SelectedWarehouse = await _requestService.GetOrCreateWarehousesAsync(result.warehouse);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading Excel file: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        [RelayCommand]
        private async Task SelectWarehouse()
        {
            await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectWarehouse, typeof(StartDataLoadViewModel)));
        }
        [RelayCommand]
        private void ClearSelectedWarehouse()
        {
            SelectedWarehouse = new Warehouse();
        }
    }
}


//StockViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Interfaces;
using System.Collections.ObjectModel;
using System.Text.RegularExpressions;
using System.Windows;
using RequestManagement.Common.Models;
using WpfClient.Messages;
using WpfClient.Services.Interfaces;
using static System.Decimal;
using Nomenclature = RequestManagement.Common.Models.Nomenclature;
using Warehouse = RequestManagement.Common.Models.Warehouse;

namespace WpfClient.ViewModels;

public partial class StockViewModel : ObservableObject
{
    public bool EditMode { get; set; }
    private readonly IStockService _stockService;
    private readonly IMessageBus _messageBus;
    private readonly IExpenseService _expenseService;
    [ObservableProperty]
    private ObservableCollection<RequestManagement.Common.Models.Stock> _stocks = [];

    [ObservableProperty]
    private RequestManagement.Common.Models.Stock? _selectedStock;

    [ObservableProperty]
    private string _selectedNomenclatureName = string.Empty;

    [ObservableProperty]
    private string _initialQuantity = string.Empty;

    [ObservableProperty]
    private string _warehouseName = "Не выбран";

    [ObservableProperty]
    private int _warehouseId;

    [ObservableProperty]
    private int _initialQuantityFilterType;

    [ObservableProperty]
    private string _initialQuantityFilter = string.Empty;

    [ObservableProperty]
    private int _receivedQuantityFilterType;

    [ObservableProperty]
    private string _receivedQuantityFilter = string.Empty;

    [ObservableProperty]
    private int _consumedQuantityFilterType;

    [ObservableProperty]
    private string _consumedQuantityFilter = string.Empty;

    [ObservableProperty]
    private int _finalQuantityFilterType;

    [ObservableProperty]
    private string _finalQuantityFilter = string.Empty;

    [ObservableProperty]
    private string _nomenclatureFilter = string.Empty;

    private Driver? _lastSelectedDriver = null;
    private Equipment? _lastSelectedEquipment = null;
    public StockViewModel()
    {
        // Для дизайнера
    }
    public StockViewModel(IStockService stockService, IMessageBus messageBus, IExpenseService expenseService)
    {
        _stockService = stockService ?? throw new ArgumentNullException(nameof(stockService));
        _messageBus = messageBus;
        _expenseService = expenseService;
        _messageBus.Subscribe<SelectResultMessage>(OnSelect);
        //RefreshCommand.Execute(null);
    }

    private Task OnSelect(SelectResultMessage arg)
    {
        if (arg.Caller != typeof(IStockService) || arg.Item == null)
            return Task.CompletedTask;
        switch (arg.Message)
        {
            case MessagesEnum.SelectNomenclature:
                if(SelectedStock == null) return Task.CompletedTask;
                SelectedStock.Nomenclature = (Nomenclature)arg.Item;
                SelectedStock.NomenclatureId = ((Nomenclature)arg.Item).Id;
                SelectedNomenclatureName =
                    $"{SelectedStock.Nomenclature.Name} ({SelectedStock.Nomenclature.Article})({SelectedStock.Nomenclature.Code})";
                break;
            case MessagesEnum.SelectWarehouse:
                WarehouseId = ((Warehouse)arg.Item).Id;
                WarehouseName = ((Warehouse)arg.Item).Name;
                break;
        }
        return Task.CompletedTask;
    }

    partial void OnSelectedStockChanged(RequestManagement.Common.Models.Stock? value)
    {
        if (value != null)
        {
            SelectedNomenclatureName = $"{value.Nomenclature.Name} ({value.Nomenclature.Article})({value.Nomenclature.Code})";
            InitialQuantity = value.InitialQuantity.ToString("F2");
        }
        else
        {
            SelectedNomenclatureName = string.Empty;
            InitialQuantity = string.Empty;
        }
    }

    partial void OnInitialQuantityChanged(string value)
    {
        if (!Regex.IsMatch(value, @"^\d*([.,]\d{0,2})?$|^$"))
        {
            InitialQuantity = Regex.Replace(value, @"[^\d.,]", "");
            MessageBox.Show("Допустимы только цифры и запятая.", "Ошибка ввода", MessageBoxButton.OK, MessageBoxImage.Warning);
        }
    }

    partial void OnNomenclatureFilterChanged(string value)
    {
        RefreshCommand.Execute(null);
    }

    [RelayCommand]
    private async Task SelectNomenclature()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectNomenclature,typeof(IStockService)));
    }

    [RelayCommand]
    private async Task SelectWarehouse()
    {
        await _messageBus.Publish(new SelectTaskMessage(MessagesEnum.SelectWarehouse, typeof(IStockService)));
    }

    [RelayCommand]
    private void DoubleClick()
    {
        _messageBus.Publish(new ShowTaskMessage(MessagesEnum.ShowExpenseDialog, typeof(IStockService), false,-1,null,0, SelectedStock, _lastSelectedEquipment, _lastSelectedDriver, null));
    }

    [RelayCommand]
    private async Task Save()
    {
        if (SelectedStock == null)
        {
            MessageBox.Show("Выберите запись для сохранения.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return;
        }

        if (!TryParse(InitialQuantity, out var initialQuantity))
        {
            MessageBox.Show("Некорректное значение начального количества.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return;
        }

        SelectedStock.InitialQuantity = initialQuantity;
        //SelectedStock.NomenclatureId = 
        var success = await _stockService.UpdateStockAsync(SelectedStock);
        if (success)
        {
            await RefreshStocks();
        }
        else
        {
            MessageBox.Show("Ошибка при сохранении записи.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }

    [RelayCommand]
    private async Task Delete()
    {
        if (SelectedStock == null)
        {
            MessageBox.Show("Выберите запись для удаления.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Warning);
            return;
        }

        var result = MessageBox.Show("Вы уверены, что хотите удалить запись?", "Подтверждение", MessageBoxButton.YesNo, MessageBoxImage.Question);
        if (result == MessageBoxResult.Yes)
        {
            var success = await _stockService.DeleteStockAsync(SelectedStock.Id);
            if (success)
            {
                await RefreshStocks();
            }
            else
            {
                MessageBox.Show("Ошибка при удалении записи.", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
    }

    [RelayCommand]
    private async Task Refresh()
    {
        await RefreshStocks();
    }
    public async Task LoadStocksAsync() => await RefreshStocks();
    public async Task LoadLastSelectionHistoryAsync()
    {
        if (SelectedStock != null)
        {
            var result = await _expenseService.GetUserLastSelectionAsync(SelectedStock.NomenclatureId);
            if (result != null)
            {
                _lastSelectedDriver = result.Driver;
                _lastSelectedEquipment = result.Equipment;
            }
        }
    }
    private async Task RefreshStocks()
    {
        try
        {
            TryParse(InitialQuantityFilter, out var initialQty);
            TryParse(ReceivedQuantityFilter, out var receivedQty);
            TryParse(ConsumedQuantityFilter, out var consumedQty);
            TryParse(FinalQuantityFilter, out var finalQty);

            var stocks = await _stockService.GetAllStocksAsync(
                WarehouseId,
                NomenclatureFilter,
                InitialQuantityFilterType,
                (double)initialQty,
                ReceivedQuantityFilterType,
                (double)receivedQty,
                ConsumedQuantityFilterType,
                (double)consumedQty,
                FinalQuantityFilterType,
                (double)finalQty);

            if (!string.IsNullOrWhiteSpace(NomenclatureFilter))
            {
                var words = NomenclatureFilter.Split(' ', StringSplitOptions.RemoveEmptyEntries)
                    .Select(w => w.ToLower())
                    .ToList();

                stocks = stocks.Where(s =>
                        words.All(w =>
                            s.Nomenclature.Name.ToLower().Contains(w) ||
                            s.Nomenclature.Code.ToLower().Contains(w) ||
                            s.Nomenclature.Article.ToLower().Contains(w) ||
                            s.Nomenclature.UnitOfMeasure.ToLower().Contains(w)))
                    .ToList();
            }

            Stocks = new ObservableCollection<RequestManagement.Common.Models.Stock>(stocks);
        }
        catch (Exception ex)
        {
            MessageBox.Show($"Ошибка при загрузке данных: {ex.Message}", "Ошибка", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }
}

//WarehouseViewModel.cs
using System.ComponentModel;
using RequestManagement.Server.Controllers;
using System.Windows.Threading;
using System.Collections.ObjectModel;
using System.Windows.Input;
using Timer = System.Timers.Timer;
using System.Runtime.CompilerServices;
using CommunityToolkit.Mvvm.Input;
using RequestManagement.Common.Interfaces;
using WpfClient.Services.Interfaces;
using WpfClient.Messages;

namespace WpfClient.ViewModels;

public class WarehouseViewModel : INotifyPropertyChanged
{
    private readonly IMessageBus _messageBus;
    public event PropertyChangedEventHandler? PropertyChanged;
    private readonly IWarehouseService _requestService;
    private Warehouse? _selectedWarehouse;
    private string _newWarehouseName;
    private readonly Timer _filterTimer;
    private string _filterText;
    private readonly Dispatcher _dispatcher;
    public event EventHandler CloseWindowRequested;
    public ObservableCollection<Warehouse> WarehouseList { get; } = [];
    public ICommand LoadWarehouseCommand { get; }
    public ICommand AddWarehouseCommand { get; }
    public ICommand UpdateWarehouseCommand { get; }
    public ICommand DeleteWarehouseCommand { get; }
    public ICommand SelectRowCommand { get; }

    public WarehouseViewModel(IWarehouseService requestService, IMessageBus messageBus)
    {
        _requestService = requestService;
        _messageBus = messageBus;
        LoadWarehouseCommand = new RelayCommand(Execute1);
        AddWarehouseCommand = new RelayCommand(Execute2);
        UpdateWarehouseCommand = new RelayCommand(Execute3);
        DeleteWarehouseCommand = new RelayCommand(Execute4);
        SelectRowCommand = new RelayCommand(Execute5);
        _dispatcher = Dispatcher.CurrentDispatcher;
        _filterTimer = new Timer(1000) { AutoReset = false }; // Задержка 1 секунда
        _filterTimer.Elapsed += async (s, e) => await LoadWarehouseAsync();
        return;
        async void Execute4() => await DeleteWarehouseAsync();
        async void Execute3() => await UpdateWarehouseAsync();
        async void Execute2() => await AddWarehouseAsync();
        async void Execute1() => await LoadWarehouseAsync();
        void Execute5() => SelectAndClose();
    }

    public string FilterText
    {
        get => _filterText;
        set
        {
            if (_filterText == value) return;
            _filterText = value;
            OnPropertyChanged();
            _filterTimer.Stop(); // Сбрасываем таймер при каждом вводе
            _filterTimer.Start(); // Запускаем таймер заново
        }
    }
    public async Task Load()
    {
        await LoadWarehouseAsync();
    }
    private async Task DeleteWarehouseAsync()
    {
        if (_selectedWarehouse != null)
        {
            await _requestService.DeleteWarehouseAsync(_selectedWarehouse.Id);
            await LoadWarehouseAsync(); // Обновляем список после удаления
            NewWarehouseName = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.WarehouseUpdated));
        }
    }
    private async Task LoadWarehouseAsync()
    {
        var filter = string.IsNullOrWhiteSpace(_filterText) ? "" : _filterText.Trim();
        var driverList = await _requestService.GetAllWarehousesAsync(filter.ToLower());
        await _dispatcher.InvokeAsync(() =>
        {
            WarehouseList.Clear();
            foreach (var item in driverList)
            {
                WarehouseList.Add(new Warehouse { Id = item.Id, Name = item.Name});
            }
            return Task.CompletedTask;
        });
    }
    private async Task UpdateWarehouseAsync()
    {
        if (_selectedWarehouse != null && !string.IsNullOrEmpty(NewWarehouseName.Trim()))
        {
            await _requestService.UpdateWarehouseAsync(new RequestManagement.Common.Models.Warehouse { Id = _selectedWarehouse.Id, Name = NewWarehouseName});
            await LoadWarehouseAsync();
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.WarehouseUpdated));
        }
    }
    private async Task AddWarehouseAsync()
    {
        if (!string.IsNullOrWhiteSpace(NewWarehouseName.Trim()))
        {
            await _requestService.CreateWarehouseAsync(new RequestManagement.Common.Models.Warehouse { Name = NewWarehouseName});
            await LoadWarehouseAsync();
            NewWarehouseName = string.Empty;
            await _messageBus.Publish(new UpdatedMessage(MessagesEnum.WarehouseUpdated));
        }
    }

    public string NewWarehouseName
    {
        get => _newWarehouseName;
        set
        {
            if (_newWarehouseName == value) return;
            _newWarehouseName = value;
            OnPropertyChanged(); // Уведомляем UI об изменении
        }
    }
    public Warehouse? SelectedWarehouse
    {
        get => _selectedWarehouse ?? null;
        set
        {
            _selectedWarehouse = value;
            AddToEdit();
        }
    }

    private void AddToEdit()
    {
        if (_selectedWarehouse != null)
        {
            NewWarehouseName = _selectedWarehouse.Name;
        }
    }

    private void SelectAndClose()
    {
        if (_selectedWarehouse != null)
        {
            CloseWindowRequested?.Invoke(this, EventArgs.Empty);
        }
    }

    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

//CreateRequestView.xaml
<UserControl x:Class="WpfClient.Views.CreateRequestView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>
        <TextBlock Text="Создание заявки" HorizontalAlignment="Center" VerticalAlignment="Center"/>
    </Grid>
</UserControl>

//CreateRequestView.xaml.cs
using System.Windows.Controls;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для CreateRequestView.xaml
/// </summary>
public partial class CreateRequestView : UserControl
{
    public CreateRequestView()
    {
        InitializeComponent();
    }
}

//DefectGroupView.xaml
<UserControl x:Class="WpfClient.Views.DefectGroupView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <StackPanel Grid.Column="1" Orientation="Horizontal" Margin="5" Height="30">
                <TextBox Text="{Binding NewDefectGroupName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
                <Button Content="Добавить" Command="{Binding AddDefectGroupCommand}" Margin="5"/>
                <Button Content="Сохранить" Command="{Binding UpdateDefectGroupCommand}" Margin="5"/>
                <Button Content="Удалить" Command="{Binding DeleteDefectGroupCommand}" Margin="5"/>
            </StackPanel>
        </Grid>


        <DataGrid Grid.Row="1" ItemsSource="{Binding DefectGroupList}"  SelectedItem="{Binding SelectedDefectGroup}" AutoGenerateColumns="False" Margin="5" CanUserResizeRows="False" CanUserAddRows="False">
            <DataGrid.Columns>
                <DataGridTextColumn Header="ID" Binding="{Binding Id}" IsReadOnly="True" Width="50"/>
                <DataGridTextColumn Header="Название" Binding="{Binding Name}" IsReadOnly="True"/>
            </DataGrid.Columns>
            <DataGrid.InputBindings>
                <MouseBinding Gesture="LeftDoubleClick" Command="{Binding SelectRowCommand}" />
            </DataGrid.InputBindings>
        </DataGrid>

        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="5" HorizontalAlignment="Center">
            <TextBox  TextWrapping="Wrap" Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center" Width="674" Margin="5"/>
            <Border BorderBrush="Black" BorderThickness="1" Margin="5"/>
            <Button Content="Обновить" Command="{Binding LoadDefectGroupCommand}" Margin="5"/>
        </StackPanel>

    </Grid>
</UserControl>

//DefectGroupView.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для DefectGroupsView.xaml
/// </summary>
public partial class DefectGroupView
{
    private readonly bool _editMode;
    public DefectGroupView(DefectGroupViewModel viewModel, bool editMode)
    {
        InitializeComponent();
        DataContext = viewModel;
        viewModel.CloseWindowRequested += ViewModel_CloseWindowRequested;
        _editMode = editMode;
    }
    private void ViewModel_CloseWindowRequested(object? sender, EventArgs e)
    {
        if (!_editMode) Window.GetWindow(this)?.Close(); // Закрываем окно, содержащее UserControl
    }
}

//DefectView.xaml
<UserControl x:Class="WpfClient.Views.DefectView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <Grid Grid.Column="0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <TextBox Grid.Row="0" Text="{Binding NewDefectName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
                <ComboBox Grid.Row="1" ItemsSource="{Binding DefectGroupList}"  SelectedIndex="{Binding SelectedDefectGroupIndex, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
            </Grid>
            <StackPanel Grid.Column="1" Orientation="Horizontal" Margin="5" Height="30">
                <Button Content="Добавить" Command="{Binding AddDefectCommand}" Margin="5"/>
                <Button Content="Сохранить" Command="{Binding UpdateDefectCommand}" Margin="5"/>
                <Button Content="Удалить" Command="{Binding DeleteDefectCommand}" Margin="5"/>
            </StackPanel>
        </Grid>


        <DataGrid Grid.Row="1" ItemsSource="{Binding DefectList}"  SelectedItem="{Binding SelectedDefect}" AutoGenerateColumns="False" Margin="5" CanUserResizeRows="False" CanUserAddRows="False">
            <DataGrid.Columns>
                <DataGridTextColumn Header="ID" Binding="{Binding Id}" IsReadOnly="True" Width="50"/>
                <DataGridTextColumn Header="Название" Binding="{Binding Name}" IsReadOnly="True"/>
                <DataGridTextColumn Header="Название" Binding="{Binding DefectGroupName}" IsReadOnly="True"/>
            </DataGrid.Columns>
            <DataGrid.InputBindings>
                <MouseBinding Gesture="LeftDoubleClick" Command="{Binding SelectRowCommand}" />
            </DataGrid.InputBindings>
        </DataGrid>

        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="5" HorizontalAlignment="Center">
            <TextBox  TextWrapping="Wrap" Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center" Width="674" Margin="5"/>
            <Border BorderBrush="Black" BorderThickness="1" Margin="5"/>
            <Button Content="Обновить" Command="{Binding LoadDefectCommand}" Margin="5"/>
        </StackPanel>

    </Grid>
</UserControl>
    

//DefectView.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для DefectsView.xaml
/// </summary>
public partial class DefectView
{
    public DefectView(DefectViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
        viewModel.CloseWindowRequested += ViewModel_CloseWindowRequested;
    }
    private void ViewModel_CloseWindowRequested(object? sender, EventArgs e)
    {
        Window.GetWindow(this)?.Close(); // Закрываем окно, содержащее UserControl
    }
}

//DriverView.xaml
<UserControl x:Class="WpfClient.Views.DriverView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <Grid Grid.Column="0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <TextBox Grid.Row="0"  Text="{Binding NewDriverFullName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
                <TextBox Grid.Row="1"  Text="{Binding NewDriverShortName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
                <TextBox Grid.Row="2"  Text="{Binding NewDriverPosition, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
            </Grid>
            <StackPanel Grid.Column="1" Orientation="Horizontal" Margin="5" Height="30">
                <Button Content="Добавить" Command="{Binding AddDriverCommand}" Margin="5"/>
                <Button Content="Сохранить" Command="{Binding UpdateDriverCommand}" Margin="5"/>
                <Button Content="Удалить" Command="{Binding DeleteDriverCommand}" Margin="5"/>
            </StackPanel>
        </Grid>


        <DataGrid Grid.Row="1" ItemsSource="{Binding DriverList}"  SelectedItem="{Binding SelectedDriver}" AutoGenerateColumns="False" Margin="5" CanUserResizeRows="False" CanUserAddRows="False">
            <DataGrid.Columns>
                <DataGridTextColumn Header="ID" Binding="{Binding Id}" IsReadOnly="True" Width="50"/>
                <DataGridTextColumn Header="ФИО" Binding="{Binding FullName}" IsReadOnly="True"/>
                <DataGridTextColumn Header="ФИО" Binding="{Binding ShortName}" IsReadOnly="True"/>
                <DataGridTextColumn Header="Должность" Binding="{Binding Position}" IsReadOnly="True"/>
            </DataGrid.Columns>
            <DataGrid.InputBindings>
                <MouseBinding Gesture="LeftDoubleClick" Command="{Binding SelectRowCommand}" />
            </DataGrid.InputBindings>
        </DataGrid>

        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="5" HorizontalAlignment="Center">
            <TextBox  TextWrapping="Wrap" Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center" Width="674" Margin="5"/>
            <Border BorderBrush="Black" BorderThickness="1" Margin="5"/>
            <Button Content="Обновить" Command="{Binding LoadDriverCommand}" Margin="5"/>
        </StackPanel>

    </Grid>
</UserControl>

//DriverView.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для DriverView.xaml
/// </summary>
public partial class DriverView
{
    public DriverView(DriverViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
        viewModel.CloseWindowRequested += ViewModel_CloseWindowRequested;
    }
    private void ViewModel_CloseWindowRequested(object? sender, EventArgs e)
    {
        Window.GetWindow(this)?.Close(); // Закрываем окно, содержащее UserControl
    }
}

//EquipmentView.xaml
<UserControl x:Class="WpfClient.Views.EquipmentView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="5">
            <TextBox Text="{Binding NewEquipmentName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
            <TextBox Text="{Binding NewEquipmentLicensePlate, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="150" Margin="5" />
            <Button Content="Добавить" Command="{Binding AddEquipmentCommand}" Margin="5"/>
            <Button Content="Сохранить" Command="{Binding UpdateEquipmentCommand}" Margin="5"/>
            <Button Content="Удалить" Command="{Binding DeleteEquipmentCommand}" Margin="5"/>
        </StackPanel>

        <DataGrid Grid.Row="1" ItemsSource="{Binding EquipmentList}"  SelectedItem="{Binding SelectedEquipment}" AutoGenerateColumns="False" Margin="5" CanUserResizeRows="False" CanUserAddRows="False">
            <DataGrid.Columns>
                <DataGridTextColumn Header="ID" Binding="{Binding Id}" IsReadOnly="True" Width="50"/>
                <DataGridTextColumn Header="Название" Binding="{Binding Name}" IsReadOnly="True"/>
                <DataGridTextColumn Header="Номер" Binding="{Binding LicensePlate}" IsReadOnly="True"/>
            </DataGrid.Columns>
            <DataGrid.InputBindings>
                <MouseBinding Gesture="LeftDoubleClick" Command="{Binding SelectRowCommand}" />
            </DataGrid.InputBindings>
        </DataGrid>

        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="5" HorizontalAlignment="Center">
            <TextBox  TextWrapping="Wrap" Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center" Width="674" Margin="5"/>
            <Border BorderBrush="Black" BorderThickness="1" Margin="5"/>
            <Button Content="Обновить" Command="{Binding LoadEquipmentCommand}" Margin="5"/>
        </StackPanel>

    </Grid>
</UserControl>

//EquipmentView.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для EquipmentView.xaml
/// </summary>
public partial class EquipmentView
{

    public EquipmentView(EquipmentViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
        viewModel.CloseWindowRequested += ViewModel_CloseWindowRequested;
    }
    private void ViewModel_CloseWindowRequested(object? sender, EventArgs e)
    {
        Window.GetWindow(this)?.Close(); // Закрываем окно, содержащее UserControl
    }
}

//ExpenseListView.xaml
<UserControl x:Class="WpfClient.Views.ExpenseListView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:WpfClient.ViewModels"
             xmlns:b="http://schemas.microsoft.com/xaml/behaviors"
             xmlns:behaviors="clr-namespace:WpfClient.ViewModels.Behaviors"
             xmlns:helpers="clr-namespace:WpfClient.ViewModels.Helpers"
             mc:Ignorable="d"
             d:DesignHeight="800" d:DesignWidth="1200" MinHeight="800" MinWidth="1200">
    <UserControl.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Styles/TextBoxClearButton.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </UserControl.Resources>
    <UserControl.DataContext>
        <vm:ExpenseListViewModel />
    </UserControl.DataContext>
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <Grid Grid.Row="0">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <Grid Grid.Column="0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="Auto" />
                </Grid.RowDefinitions>
                <StackPanel Grid.Row="0"  Orientation="Horizontal" Margin="5,5,0,5">
                    <Label Content="Период: с " Margin="0,5"/>
                    <DatePicker Margin="0,7,0,3" SelectedDate="{Binding FromDate}">
                        <b:Interaction.Behaviors>
                            <behaviors:DatePickerSelectedDateChangedBehavior Command="{Binding LoadExpensesCommand}" />
                        </b:Interaction.Behaviors>
                    </DatePicker>
                    <Label Content="по" Margin="0,5"/>
                    <DatePicker Margin="0,7,0,3" SelectedDate="{Binding ToDate}">
                        <b:Interaction.Behaviors>
                            <behaviors:DatePickerSelectedDateChangedBehavior Command="{Binding LoadExpensesCommand}" />
                        </b:Interaction.Behaviors>
                    </DatePicker>
                </StackPanel>
                <StackPanel Grid.Row="1"  Orientation="Horizontal" Margin="10,5,0,5">
                    <TextBox helpers:PlaceholderHelper.PlaceholderText="Склад" Tag="{Binding ClearSelectedWarehouseCommand}" Text="{Binding SelectedWarehouse.Name, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}" IsReadOnly="True" Width="336" Style="{StaticResource ClearableTextBoxStyle}">
                        <b:Interaction.Behaviors>
                            <behaviors:ClearButtonBehavior />
                            <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                            <behaviors:MouseClickCommandBehavior Command="{Binding SelectWarehouseCommand}" />
                        </b:Interaction.Behaviors>
                    </TextBox>
                </StackPanel>
                <StackPanel Grid.Row="2"  Orientation="Horizontal" Margin="10,5,0,5">
                    <TextBox helpers:PlaceholderHelper.PlaceholderText="Дефект"   Tag="{Binding ClearSelectedDefectCommand}"  Text="{Binding SelectedDefect.Name, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}" IsReadOnly="True" Width="336" Style="{StaticResource ClearableTextBoxStyle}">
                        <b:Interaction.Behaviors>
                            <behaviors:ClearButtonBehavior />
                            <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                            <behaviors:MouseClickCommandBehavior Command="{Binding SelectDefectCommand}" />
                        </b:Interaction.Behaviors>
                    </TextBox>
                </StackPanel>
            </Grid>
            <Grid Grid.Column="1">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="Auto" />
                    <RowDefinition Height="Auto" />
                </Grid.RowDefinitions>
                <StackPanel Grid.Row="0"  Orientation="Horizontal" Margin="10,9,0,5">
                    <TextBox helpers:PlaceholderHelper.PlaceholderText="Номенклатура" Tag="{Binding ClearSearchTextCommand}" Text="{Binding SearchText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="336" Style="{StaticResource ClearableTextBoxStyle}">
                        <b:Interaction.Behaviors>
                            <behaviors:ClearButtonBehavior />
                            <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                            <behaviors:MouseClickCommandBehavior/>
                        </b:Interaction.Behaviors>
                    </TextBox>
                </StackPanel>
                <StackPanel Grid.Row="1"  Orientation="Horizontal" Margin="10,5,0,5">
                    <TextBox helpers:PlaceholderHelper.PlaceholderText="Техника" Tag="{Binding ClearSelectedEquipmentCommand}" Text="{Binding SelectedEquipment.Name, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}" IsReadOnly="True" Width="336" Style="{StaticResource ClearableTextBoxStyle}">
                        <b:Interaction.Behaviors>
                            <behaviors:ClearButtonBehavior />
                            <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                            <behaviors:MouseClickCommandBehavior Command="{Binding SelectEquipmentCommand}" />
                        </b:Interaction.Behaviors>
                    </TextBox>
                </StackPanel>
                <StackPanel Grid.Row="2"  Orientation="Horizontal" Margin="10,5,0,5">
                    <TextBox helpers:PlaceholderHelper.PlaceholderText="Водитель" Tag="{Binding ClearSelectedDriverCommand}" Text="{Binding SelectedDriver.ShortName, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}" IsReadOnly="True" Width="336" Style="{StaticResource ClearableTextBoxStyle}">
                        <b:Interaction.Behaviors>
                            <behaviors:ClearButtonBehavior />
                            <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                            <behaviors:MouseClickCommandBehavior Command="{Binding SelectDriverCommand}" />
                        </b:Interaction.Behaviors>
                    </TextBox>
                </StackPanel>
            </Grid>
        </Grid>
        <DataGrid Grid.Row="1" ItemsSource="{Binding ExpensesViewSource.View}" SelectedItem="{Binding SelectedExpense}"
                  AutoGenerateColumns="False" CanUserAddRows="False" Margin="10,10,0,0" SelectionMode="Single" SelectionUnit="FullRow" Name="ExpenseListDataGrid">
            <DataGrid.Resources>
                <SolidColorBrush x:Key="{x:Static SystemColors.InactiveSelectionHighlightBrushKey}" Color="#0078d7"/>
                <SolidColorBrush x:Key="{x:Static SystemColors.WindowBrushKey}" Color="White"/>
                <SolidColorBrush x:Key="{x:Static SystemColors.ControlBrushKey}" Color="#FFE5E5E5"/>
            </DataGrid.Resources>
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Редактировать" Command="{Binding DoubleClickCommand}"/>
                    <MenuItem Header="Отметить все" Command="{Binding SelectAllCommand}"/>
                    <MenuItem Header="Снять отметки со всех" Command="{Binding DeselectAllCommand}"/>
                    <MenuItem Header="Инвертировать отметки" Command="{Binding InvertSelectedCommand}"/>
                    <MenuItem Header="Удалить выбранный" Command="{Binding ExpenseDeleteCommand}"/>
                    <MenuItem Header="{Binding MenuDeleteItemText}" Command="{Binding ExpenseDeleteRangeCommand}"/>
                </ContextMenu>
            </DataGrid.ContextMenu>
            <DataGrid.InputBindings>
                <MouseBinding
                    MouseAction="LeftDoubleClick"
                    Command="{Binding DoubleClickCommand}"
                    CommandParameter="{Binding Expenses/}"/>
            </DataGrid.InputBindings>
            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" SortMemberPath="IsSelected" CanUserSort="True">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                                      Command="{Binding DataContext.ExpenseListCheckedUpdateCommand, RelativeSource={RelativeSource AncestorType=DataGrid}}"/>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridTextColumn Header="Дата" Binding="{Binding Date.Date, StringFormat=\{0:dd.MM.yyyy\}}" IsReadOnly="True" Width="80" />
                <DataGridTextColumn Header="Наименование" Binding="{Binding Stock.Nomenclature.Name}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Артикул" Binding="{Binding Stock.Nomenclature.Article}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Ед.изм." Binding="{Binding Stock.Nomenclature.UnitOfMeasure}" IsReadOnly="True" Width="50" />
                <DataGridTextColumn Header="Кол-во" Binding="{Binding Quantity}" IsReadOnly="True" Width="70" />
                <DataGridTextColumn Header="Техника" Binding="{Binding Equipment.Name}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="г.н." Binding="{Binding Equipment.StateNumber}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Водитель" Binding="{Binding Driver.ShortName}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Дефект" Binding="{Binding Defect.Name}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Склад" Binding="{Binding Stock.Warehouse.Name}" IsReadOnly="True" Width="*" />
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</UserControl>

//ExpenseListView.xaml.cs
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для ExpenseListView.xaml
/// </summary>
public partial class ExpenseListView
{
    public ExpenseListView(ExpenseListViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
    }
}

//ExpenseView.xaml
<UserControl x:Class="WpfClient.Views.ExpenseView"
             x:Name="ExpenseViewWindow"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:WpfClient.ViewModels"
             mc:Ignorable="d"
             d:DesignHeight="330" d:DesignWidth="620" MinHeight="330" MinWidth="620">
    <UserControl.DataContext>
        <vm:ExpenseViewModel />
    </UserControl.DataContext>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid Grid.Row="0" HorizontalAlignment="Left">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>
            <Label Grid.Row="0" Margin="5" Content="{Binding ExpenseStock.Nomenclature.Code}" />
            <Label Grid.Row="0" Margin="120,5,5,5" Content="{Binding ExpenseStock.Nomenclature.UnitOfMeasure}" />
            <Label Grid.Row="1" Margin="5" Content="{Binding ExpenseStock.Nomenclature.Article}"/>
            <Label Grid.Row="2" Margin="5" Content="{Binding ExpenseStock.Nomenclature.Name}" />
        </Grid>
        <Grid Grid.Row="1" HorizontalAlignment="Left" Width="600">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="540"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <TextBox Grid.Column="0" Margin="5" TextAlignment="Center" Text="{Binding SelectedEquipmentText}" />
            <Button Grid.Column="1" Margin="5" Content="Выбрать" Command="{Binding SelectEquipmentCommand}"/>
        </Grid>
        <Grid Grid.Row="2" HorizontalAlignment="Left" Width="600">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="540"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <TextBox Grid.Column="0" Margin="5" TextAlignment="Center" Text="{Binding SelectedDriver.FullName}"/>
            <Button Grid.Column="1" Margin="5" Content="Выбрать"  Command="{Binding SelectDriverCommand}"/>
        </Grid>
        <Grid Grid.Row="3" HorizontalAlignment="Left" Width="600">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="540"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <TextBox Grid.Column="0" Margin="5" TextAlignment="Center" Text="{Binding SelectedDefect.Name}"/>
            <Button Grid.Column="1" Margin="5" Content="Выбрать"  Command="{Binding SelectDefectCommand}"/>
        </Grid>
        <Grid Grid.Row="4" HorizontalAlignment="Left" Width="600" Margin="0,10,0,0">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <TextBlock Grid.Column="0" Margin="65,5,5,5">
                <Run>Количество(доступно </Run> 
                <Hyperlink Command="{Binding SetMaxQuantityCommand}">
                    <TextBlock Text="{Binding ExpenseStock.FinalQuantity}"/>
                </Hyperlink>
                <Run>):</Run>
            </TextBlock>
            <TextBox Grid.Column="1" Width="60" Margin="5" Text="{Binding QuantityForExpense}"/>
            <DatePicker Grid.Column="2" SelectedDate="{Binding SelectedDate}" Margin="60,3,0,2" Width="150"/>
        </Grid>
        <Grid Grid.Row="5" HorizontalAlignment="Center"  Margin="0,30,0,0">
            <Button Content="Сохранить" Width="100" Command="{Binding SaveExpenseToDatabaseCommand, Mode=OneWay}" CommandParameter="{Binding ElementName=ExpenseViewWindow}"/>
        </Grid>
    </Grid>
</UserControl>

//ExpenseView.xaml.cs
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для ExpenseView.xaml
/// </summary>
public partial class ExpenseView
{
    public ExpenseView(ExpenseViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
    }
}

//IncomingListView.xaml
<UserControl x:Class="WpfClient.Views.IncomingListView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:WpfClient.ViewModels"
             xmlns:b="http://schemas.microsoft.com/xaml/behaviors"
             xmlns:behaviors="clr-namespace:WpfClient.ViewModels.Behaviors"
             xmlns:helpers="clr-namespace:WpfClient.ViewModels.Helpers"
             mc:Ignorable="d"
             d:DesignHeight="800" d:DesignWidth="1200" MinHeight="800" MinWidth="1200">
    <UserControl.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Styles/TextBoxClearButton.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </UserControl.Resources>
    <UserControl.DataContext>
        <vm:IncomingListViewModel />
    </UserControl.DataContext>
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>
        <Grid Grid.Row="0">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <StackPanel Grid.Row="0"  Orientation="Horizontal" Margin="5,5,0,5">
                <Label Content="Период: с " Margin="0,5"/>
                <DatePicker Margin="0,7,0,3" SelectedDate="{Binding FromDate}">
                    <b:Interaction.Behaviors>
                        <behaviors:DatePickerSelectedDateChangedBehavior Command="{Binding LoadIncomingsCommand}" />
                    </b:Interaction.Behaviors>
                </DatePicker>
                <Label Content="по" Margin="0,5"/>
                <DatePicker Margin="0,7,0,3" SelectedDate="{Binding ToDate}">
                    <b:Interaction.Behaviors>
                        <behaviors:DatePickerSelectedDateChangedBehavior Command="{Binding LoadIncomingsCommand}" />
                    </b:Interaction.Behaviors>
                </DatePicker>
            </StackPanel>
            <StackPanel Grid.Row="1"  Orientation="Horizontal" Margin="10,5,0,5">
                <TextBox helpers:PlaceholderHelper.PlaceholderText="Склад" 
                         Tag="{Binding ClearSelectedWarehouseCommand}" 
                         Text="{Binding SelectedWarehouse.Name, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}" 
                         IsReadOnly="True" Width="338" Style="{StaticResource ClearableTextBoxStyle}">
                    <b:Interaction.Behaviors>
                        <behaviors:ClearButtonBehavior />
                        <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                        <behaviors:MouseClickCommandBehavior Command="{Binding SelectWarehouseCommand}" />
                    </b:Interaction.Behaviors>
                </TextBox>
            </StackPanel>
            <StackPanel Grid.Row="2"  Orientation="Horizontal" Margin="10,9,0,5">
                <TextBox helpers:PlaceholderHelper.PlaceholderText="Номенклатура" 
                         Tag="{Binding ClearSearchTextCommand}" 
                         Text="{Binding SearchText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" 
                         Width="338" Style="{StaticResource ClearableTextBoxStyle}">
                    <b:Interaction.Behaviors>
                        <behaviors:ClearButtonBehavior />
                        <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                        <behaviors:MouseClickCommandBehavior/>
                    </b:Interaction.Behaviors>
                </TextBox>
            </StackPanel>
        </Grid>
        <DataGrid Grid.Row="1" ItemsSource="{Binding IncomingsViewSource.View}" SelectedItem="{Binding SelectedIncoming}"
                  AutoGenerateColumns="False" CanUserAddRows="False" Margin="10,10,0,0" SelectionMode="Single" SelectionUnit="FullRow" Name="IncomingListDataGrid">
            <DataGrid.Resources>
                <SolidColorBrush x:Key="{x:Static SystemColors.InactiveSelectionHighlightBrushKey}" Color="#0078d7"/>
            </DataGrid.Resources>
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="Редактировать" Command="{Binding DoubleClickCommand}"/>
                    <MenuItem Header="Отметить все" Command="{Binding SelectAllCommand}"/>
                    <MenuItem Header="Снять отметки со всех" Command="{Binding DeselectAllCommand}"/>
                    <MenuItem Header="Инвертировать отметки" Command="{Binding InvertSelectedCommand}"/>
                    <MenuItem Header="Удалить выбранный" Command="{Binding IncomingDeleteCommand}"/>
                    <MenuItem Header="{Binding MenuDeleteItemText}" Command="{Binding IncomingDeleteRangeCommand}"/>
                </ContextMenu>
            </DataGrid.ContextMenu>
            <DataGrid.InputBindings>
                <MouseBinding
                    MouseAction="LeftDoubleClick"
                    Command="{Binding DoubleClickCommand}"
                    CommandParameter="{Binding Incomings/}"/>
            </DataGrid.InputBindings>
            <DataGrid.Columns>
                <DataGridTemplateColumn Header="" SortMemberPath="IsSelected" CanUserSort="True">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <CheckBox IsChecked="{Binding IsSelected, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                                      Command="{Binding DataContext.IncomingListCheckedUpdateCommand, RelativeSource={RelativeSource AncestorType=DataGrid}}"/>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridTextColumn Header="Дата" Binding="{Binding Date.Date, StringFormat=\{0:dd.MM.yyyy\}}" IsReadOnly="True" Width="80" />
                <DataGridTextColumn Header="Наименование" Binding="{Binding Stock.Nomenclature.Name}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Артикул" Binding="{Binding Stock.Nomenclature.Article}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Ед.изм." Binding="{Binding Stock.Nomenclature.UnitOfMeasure}" IsReadOnly="True" Width="50" />
                <DataGridTextColumn Header="Кол-во" Binding="{Binding Quantity}" IsReadOnly="True" Width="70" />
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</UserControl>


//IncomingListView.xaml.cs
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для IncomingListView.xaml
/// </summary>
public partial class IncomingListView
{
    public IncomingListView(IncomingListViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
    }
}

//MainDictionary.xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:WpfClient.Views">
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
</ResourceDictionary>

//MainMenu.xaml
<Window x:Class="WpfClient.Views.MainMenu"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:WpfClient.Views"
        Title="Request Management" Height="655" Width="1000">
    <Window.Resources>
        <ResourceDictionary Source="MainDictionary.xaml" />
    </Window.Resources>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Меню -->
        <Menu Grid.Row="0">
            <MenuItem Header="Заявки">
                <MenuItem Header="Просмотреть все заявки" Command="{Binding ViewRequestsCommand}"/>
                <MenuItem Header="Создать заявку" Command="{Binding CreateRequestCommand}"/>
            </MenuItem>
            <MenuItem Header="Справочники" Visibility="{Binding IsAdminVisible, Converter={StaticResource BooleanToVisibilityConverter}}">
                <MenuItem Header="Машины" Command="{Binding ShowEquipmentCommand}"/>
                <MenuItem Header="Водители" Command="{Binding ShowDriverCommand}"/>
                <MenuItem Header="Группы дефектов" Command="{Binding ShowDefectGroupCommand}"/>
                <MenuItem Header="Дефекты" Command="{Binding ShowDefectCommand}"/>
                <MenuItem Header="Склады" Command="{Binding ShowWarehouseCommand}"/>
                <MenuItem Header="Номенклатура" Command="{Binding ShowNomenclatureCommand}"/>
            </MenuItem>
            <MenuItem Header="Движения">
                <MenuItem Header="Приходы" Command="{Binding ShowIncomingListCommand}"/>
                <MenuItem Header="Расходы" Command="{Binding ShowExpensesCommand}"/>
            </MenuItem>
            <MenuItem Header="Администратирование">
                <MenuItem Header="Загрузка начальных остатков" Command="{Binding ShowStartDataLoadingCommand}"/>
                <MenuItem Header="Расходы" Command="{Binding ShowExpensesCommand}"/>
            </MenuItem>
        </Menu>

        <!-- Контент -->
        <ContentControl Grid.Row="1" Content="{Binding StockControlProperty}"/>
    </Grid>
</Window>

//MainMenu.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для Window1.xaml
/// </summary>
public partial class MainMenu : Window
{
    public MainMenu(MainMenuViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;
    }
}

//MainWindow.xaml
<Window x:Class="WpfClient.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Вход в систему" Height="250" Width="300"
        WindowStartupLocation="CenterScreen">
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Логин" Margin="0,0,0,5"/>
        <TextBox Grid.Row="1" Text="{Binding Login, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,10"/>

        <TextBlock Grid.Row="2" Text="Пароль" Margin="0,0,0,5"/>
        <PasswordBox x:Name="passwordBox" Grid.Row="3" Margin="0,0,0,10"/>

        <Button Grid.Row="4" Content="Войти" Command="{Binding LoginCommand}" Width="100" HorizontalAlignment="Center"/>
        <TextBlock Grid.Row="5" Text="{Binding ErrorMessage}" Foreground="Red" Margin="0,10,0,-71" TextAlignment="Center" TextWrapping="Wrap"/>
    </Grid>
</Window>

//MainWindow.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

public partial class MainWindow : Window
{
    public MainWindow(LoginViewModel viewModel)
    {
        InitializeComponent();
        DataContext = viewModel;

        // Проверка DataContext
        if (DataContext == null)
        {
            MessageBox.Show("DataContext не установлен!");
        }

        // Привязка пароля из PasswordBox
        passwordBox.PasswordChanged += (s, e) => viewModel.Password = passwordBox.Password;
    }
}

//NomenclatureView.xaml
<UserControl x:Class="WpfClient.Views.NomenclatureView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <Grid Grid.Column="0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <TextBox Grid.Row="0"  Text="{Binding NewNomenclatureCode, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
                <TextBox Grid.Row="1"  Text="{Binding NewNomenclatureName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
                <TextBox Grid.Row="2"  Text="{Binding NewNomenclatureArticle, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
                <TextBox Grid.Row="3"  Text="{Binding NewNomenclatureUnitOfMeasure, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
            </Grid>
            <StackPanel Grid.Column="1" Orientation="Horizontal" Margin="5" Height="30">
                <Button Content="Добавить" Command="{Binding AddNomenclatureCommand}" Margin="5"/>
                <Button Content="Сохранить" Command="{Binding UpdateNomenclatureCommand}" Margin="5"/>
                <Button Content="Удалить" Command="{Binding DeleteNomenclatureCommand}" Margin="5"/>
            </StackPanel>
        </Grid>
        <DataGrid Grid.Row="1" ItemsSource="{Binding NomenclatureList}"  SelectedItem="{Binding SelectedNomenclature}" AutoGenerateColumns="False" Margin="5" CanUserResizeRows="False" CanUserAddRows="False">
            <DataGrid.Columns>
                <DataGridTextColumn Header="ID" Binding="{Binding Id}" IsReadOnly="True" Width="50"/>
                <DataGridTextColumn Header="Код" Binding="{Binding Code}" IsReadOnly="True"/>
                <DataGridTextColumn Header="Наименование" Binding="{Binding Name}" IsReadOnly="True"/>
                <DataGridTextColumn Header="Артикул" Binding="{Binding Article}" IsReadOnly="True"/>
                <DataGridTextColumn Header="Ед.изм." Binding="{Binding UnitOfMeasure}" IsReadOnly="True"/>
            </DataGrid.Columns>
            <DataGrid.InputBindings>
                <MouseBinding Gesture="LeftDoubleClick" Command="{Binding SelectRowCommand}" />
            </DataGrid.InputBindings>
        </DataGrid>

        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="5" HorizontalAlignment="Center">
            <TextBox  TextWrapping="Wrap" Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center" Width="674" Margin="5"/>
            <Border BorderBrush="Black" BorderThickness="1" Margin="5"/>
            <Button Content="Обновить" Command="{Binding LoadNomenclatureCommand}" Margin="5"/>
        </StackPanel>

    </Grid>
</UserControl>

//NomenclatureView.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для NomenclatureView.xaml
/// </summary>
public partial class NomenclatureView
{
    private readonly bool _editMode;
    public NomenclatureView(NomenclatureViewModel viewModel,bool editMode)
    {
        InitializeComponent();
        DataContext = viewModel;
        viewModel.CloseWindowRequested += ViewModel_CloseWindowRequested;
        _editMode = editMode;
    }
    private void ViewModel_CloseWindowRequested(object? sender, EventArgs e)
    {
        if(!_editMode) Window.GetWindow(this)?.Close(); // Закрываем окно, содержащее UserControl
    }
}

//RequestsView.xaml
<UserControl x:Class="WpfClient.Views.RequestsView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>
        <TextBlock Text="Список всех заявок" HorizontalAlignment="Center" VerticalAlignment="Center"/>
    </Grid>
</UserControl>

//RequestsView.xaml.cs
using System.Windows.Controls;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для RequestsView.xaml
/// </summary>
public partial class RequestsView : UserControl
{
    public RequestsView()
    {
        InitializeComponent();
    }
}

//StartDataLoadView.xaml
<UserControl x:Class="WpfClient.Views.StartDataLoadView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:WpfClient.ViewModels"
             xmlns:b="http://schemas.microsoft.com/xaml/behaviors"
             xmlns:behaviors="clr-namespace:WpfClient.ViewModels.Behaviors"
             xmlns:helpers="clr-namespace:WpfClient.ViewModels.Helpers"
             mc:Ignorable="d"
             d:DesignHeight="220" d:DesignWidth="500" MinHeight="220" MinWidth="500">
    <UserControl.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Styles/TextBoxClearButton.xaml" />
            </ResourceDictionary.MergedDictionaries>
            <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter" />
        </ResourceDictionary>
    </UserControl.Resources>
    <UserControl.DataContext>
        <vm:StartDataLoadViewModel />
    </UserControl.DataContext>
    <Grid>
        <Grid Margin="10" x:Name="MainContent" >
            <Grid.Style>
                <Style TargetType="Grid">
                    <Setter Property="IsEnabled" Value="True" />
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding IsBusy}" Value="True">
                            <Setter Property="IsEnabled" Value="False" />
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </Grid.Style>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
                <RowDefinition Height="Auto" />
            </Grid.RowDefinitions>
            <StackPanel Grid.Row="0"  Orientation="Horizontal" Margin="10,5,0,5">
                <TextBox helpers:PlaceholderHelper.PlaceholderText="Документ Excel" 
                     Tag="{Binding ClearDocumentPathCommand}" 
                     Text="{Binding DocumentPath, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}" 
                     IsReadOnly="True" Width="455" Style="{StaticResource ClearableTextBoxStyle}">
                    <b:Interaction.Behaviors>
                        <behaviors:ClearButtonBehavior />
                        <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                        <behaviors:MouseClickCommandBehavior Command="{Binding SelectDocumentPathCommand}" />
                    </b:Interaction.Behaviors>
                </TextBox>
            </StackPanel>
            <StackPanel Grid.Row="1"  Orientation="Horizontal" Margin="10,25,0,5">
                <Label Content="Всего наименований: "/>
                <Label Margin="-10,0,0,0" Content="{Binding MaterialStocks.Count}"/>
            </StackPanel>
            <StackPanel Grid.Row="2"  Orientation="Horizontal" Margin="10,0,0,5">
                <TextBox helpers:PlaceholderHelper.PlaceholderText="Склад" 
                     Tag="{Binding ClearSelectedWarehouseCommand}" 
                     Text="{Binding SelectedWarehouse.Name, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}" 
                     IsReadOnly="True" Width="338" Style="{StaticResource ClearableTextBoxStyle}">
                    <b:Interaction.Behaviors>
                        <behaviors:ClearButtonBehavior />
                        <behaviors:PlaceholderBehavior PlaceholderTargetName="Placeholder"/>
                        <behaviors:MouseClickCommandBehavior Command="{Binding SelectWarehouseCommand}" />
                    </b:Interaction.Behaviors>
                </TextBox>
                <DatePicker Margin="10,3,0,3" SelectedDate="{Binding ToDate}"/>
            </StackPanel>
            <StackPanel Grid.Row="3" HorizontalAlignment="Center" Orientation="Horizontal" Margin="10,15,0,5">
                <Button Content="Загрузить" Command="{Binding UploadMaterialsCommand}"/>
            </StackPanel>
        </Grid>
        <Grid Background="#80000000" Panel.ZIndex="1" 
              Visibility="{Binding IsBusy, Mode=OneWay, Converter={StaticResource BooleanToVisibilityConverter}}">
            <Border Background="White" CornerRadius="5" Padding="20" 
                    HorizontalAlignment="Center" VerticalAlignment="Center">
                <StackPanel>
                    <TextBlock Text="Загрузка..." FontSize="16" HorizontalAlignment="Center" />
                    <ProgressBar IsIndeterminate="True" Width="100" Height="20" Margin="0,10,0,0" />
                </StackPanel>
            </Border>
        </Grid>
    </Grid>
</UserControl>

//StartDataLoadView.xaml.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using WpfClient.ViewModels;

namespace WpfClient.Views
{
    /// <summary>
    /// Логика взаимодействия для StartDataLoadView.xaml
    /// </summary>
    public partial class StartDataLoadView
    {
        public StartDataLoadView(StartDataLoadViewModel viewModel)
        {
            InitializeComponent();
            DataContext = viewModel;
        }
    }
}


//StockView.xaml
<UserControl x:Class="WpfClient.Views.StockView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:WpfClient.ViewModels"
             mc:Ignorable="d"
             d:DesignHeight="600" d:DesignWidth="1000" MinHeight="600" MinWidth="1000">
    <UserControl.DataContext>
        <vm:StockViewModel />
    </UserControl.DataContext>
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <!-- Верхняя панель -->
        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,10">
            <TextBox Text="{Binding SelectedNomenclatureName, Mode=OneWay}"
                     IsReadOnly="True" Width="300" Margin="0,0,5,0" />
            <Button Content="Выбрать номенклатуру" Command="{Binding SelectNomenclatureCommand}"
                    Width="150" Margin="0,0,10,0" />
            <TextBox Text="{Binding InitialQuantity, UpdateSourceTrigger=PropertyChanged}"
                     Width="100" Margin="0,0,10,0">
                <TextBox.InputBindings>
                    <KeyBinding Key="Enter" Command="{Binding SaveCommand}" />
                </TextBox.InputBindings>
            </TextBox>
            <Button Content="Добавить" Width="80" Margin="0,0,5,0" IsEnabled="False" />
            <Button Content="Сохранить" Command="{Binding SaveCommand}" Width="80" Margin="0,0,5,0" />
            <Button Content="Удалить" Command="{Binding DeleteCommand}" Width="80" />
        </StackPanel>

        <!-- DataGrid -->
        <DataGrid Grid.Row="1" ItemsSource="{Binding Stocks}" SelectedItem="{Binding SelectedStock}"
                  AutoGenerateColumns="False" CanUserAddRows="False" Margin="0,0,0,10">
            <DataGrid.InputBindings>
                <MouseBinding
                    MouseAction="LeftDoubleClick"
                    Command="{Binding DoubleClickCommand}"
                    CommandParameter="{Binding Stocks/}"/>
            </DataGrid.InputBindings>
            <DataGrid.Columns>
                <DataGridTextColumn Header="Код" Binding="{Binding Nomenclature.Code}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Артикул" Binding="{Binding Nomenclature.Article}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Наименование" Binding="{Binding Nomenclature.Name}" IsReadOnly="True" Width="2*" />
                <DataGridTextColumn Header="Ед. изм." Binding="{Binding Nomenclature.UnitOfMeasure}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Начальный остаток" Binding="{Binding InitialQuantity}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Приход" Binding="{Binding ReceivedQuantity}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Расход" Binding="{Binding ConsumedQuantity}" IsReadOnly="True" Width="*" />
                <DataGridTextColumn Header="Остаток" Binding="{Binding FinalQuantity}" IsReadOnly="True" Width="*" />
            </DataGrid.Columns>
        </DataGrid>

        <!-- Панель фильтров -->
        <Grid Grid.Row="2">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="650"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <StackPanel Grid.Column="0" >
                <StackPanel Orientation="Horizontal" Margin="0,0,0,5">
                    <TextBox Text="{Binding WarehouseName, Mode=OneWay}" IsReadOnly="True" Width="200" />
                    <Button Content="Выбрать склад" Command="{Binding SelectWarehouseCommand}" Width="150" Margin="5,0,0,0" />
                </StackPanel>
                <StackPanel Orientation="Horizontal" Margin="0,0,0,5">
                    <Label Content="Начальный остаток:"/>
                    <ComboBox SelectedIndex="{Binding InitialQuantityFilterType}" Width="100">
                        <ComboBoxItem Content="" />
                        <ComboBoxItem Content="=" />
                        <ComboBoxItem Content=">" />
                        <ComboBoxItem Content="&lt;" />
                    </ComboBox>
                    <TextBox Text="{Binding InitialQuantityFilter}" Width="100" Margin="5,0,0,0" />
                    <Label Margin="50,0,0,0" Content="Приход:"/>
                    <ComboBox SelectedIndex="{Binding ReceivedQuantityFilterType}" Width="100" Margin="5,0,0,0">
                        <ComboBoxItem Content="" />
                        <ComboBoxItem Content="=" />
                        <ComboBoxItem Content=">" />
                        <ComboBoxItem Content="&lt;" />
                    </ComboBox>
                    <TextBox Text="{Binding ReceivedQuantityFilter}" Width="100" Margin="5,0,0,0" />
                </StackPanel>
                <StackPanel Orientation="Horizontal" Margin="0,0,0,5">
                    <Label Margin="6,0,0,0" Content="Конечный остаток:"/>
                    <ComboBox SelectedIndex="{Binding ConsumedQuantityFilterType}" Width="100">
                        <ComboBoxItem Content="" />
                        <ComboBoxItem Content="=" />
                        <ComboBoxItem Content=">" />
                        <ComboBoxItem Content="&lt;" />
                    </ComboBox>
                    <TextBox Text="{Binding ConsumedQuantityFilter}" Width="100" Margin="5,0,0,0" />
                    <Label Margin="54,0,0,0" Content="Расход:"/>
                    <ComboBox SelectedIndex="{Binding FinalQuantityFilterType}" Width="100" Margin="5,0,0,0">
                        <ComboBoxItem Content="" />
                        <ComboBoxItem Content="=" />
                        <ComboBoxItem Content=">" />
                        <ComboBoxItem Content="&lt;" />
                    </ComboBox>
                    <TextBox Text="{Binding FinalQuantityFilter}" Width="100" Margin="5,0,0,0" />
                </StackPanel>
                <StackPanel Orientation="Horizontal">
                    <TextBox Text="{Binding NomenclatureFilter, UpdateSourceTrigger=PropertyChanged}" Width="300" />
                </StackPanel>
            </StackPanel>
            <Button Height="26" Grid.Column="1" Content="Обновить" Command="{Binding RefreshCommand}" Width="100" Margin="40,0,0,0" />
        </Grid>
    </Grid>
</UserControl>

//StockView.xaml.cs
using System.Text.RegularExpressions;
using System.Windows.Input;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для StockView.xaml
/// </summary>
public partial class StockView
{
    private readonly bool _editMode;
    public StockView(StockViewModel viewModel,bool editMode)
    {
        InitializeComponent();
        DataContext = viewModel;
        _editMode = editMode;
    }
    private void NumberValidationTextBox(object sender, TextCompositionEventArgs e)
    {
        var regex = new Regex("[^0-9,]+");
        e.Handled = regex.IsMatch(e.Text);
    }
}

//WarehouseView.xaml
<UserControl x:Class="WpfClient.Views.WarehouseView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="5">
            <TextBox Text="{Binding NewWarehouseName, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="400" Margin="5" />
            <Button Content="Добавить" Command="{Binding AddWarehouseCommand}" Margin="5"/>
            <Button Content="Сохранить" Command="{Binding UpdateWarehouseCommand}" Margin="5"/>
            <Button Content="Удалить" Command="{Binding DeleteWarehouseCommand}" Margin="5"/>
        </StackPanel>

        <DataGrid Grid.Row="1" ItemsSource="{Binding WarehouseList}"  SelectedItem="{Binding SelectedWarehouse}" AutoGenerateColumns="False" Margin="5" CanUserResizeRows="False" CanUserAddRows="False">
            <DataGrid.Columns>
                <DataGridTextColumn Header="ID" Binding="{Binding Id}" IsReadOnly="True" Width="50"/>
                <DataGridTextColumn Header="Название" Binding="{Binding Name}" IsReadOnly="True"/>
            </DataGrid.Columns>
            <DataGrid.InputBindings>
                <MouseBinding Gesture="LeftDoubleClick" Command="{Binding SelectRowCommand}" />
            </DataGrid.InputBindings>
        </DataGrid>

        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="5" HorizontalAlignment="Center">
            <TextBox  TextWrapping="Wrap" Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}" VerticalAlignment="Center" Width="674" Margin="5"/>
            <Border BorderBrush="Black" BorderThickness="1" Margin="5"/>
            <Button Content="Обновить" Command="{Binding LoadWarehouseCommand}" Margin="5"/>
        </StackPanel>

    </Grid>
</UserControl>

//WarehouseView.xaml.cs
using System.Windows;
using WpfClient.ViewModels;

namespace WpfClient.Views;

/// <summary>
/// Логика взаимодействия для WarehouseView.xaml
/// </summary>
public partial class WarehouseView
{
    private readonly bool _editMode;
    public WarehouseView(WarehouseViewModel viewModel,bool editMode)
    {
        InitializeComponent();
        DataContext = viewModel;
        viewModel.CloseWindowRequested += ViewModel_CloseWindowRequested;
        _editMode = editMode;
    }
    private void ViewModel_CloseWindowRequested(object? sender, EventArgs e)
    {
        if(!_editMode) Window.GetWindow(this)?.Close(); // Закрываем окно, содержащее UserControl
    }
}

//IExcelReaderService.cs
using WpfClient.Models;

namespace WpfClient.Services.Interfaces
{
    public interface IExcelReaderService
    {
        (List<MaterialStock> materialStocks, string? date, string? warehouse) ReadMaterialStock(string filePath);
    }
}


//IGrpcClientFactory.cs
using AuthService = RequestManagement.Server.Controllers.AuthService;
using ExpenseService = RequestManagement.Server.Controllers.ExpenseService;
using RequestService = RequestManagement.Server.Controllers.RequestService;
using StockService = RequestManagement.Server.Controllers.StockService;
using IncomingService = RequestManagement.Server.Controllers.IncomingService;
using WarehouseService = RequestManagement.Server.Controllers.WarehouseService;

namespace WpfClient.Services.Interfaces;

public interface IGrpcClientFactory
{
    AuthService.AuthServiceClient CreateAuthClient();
    RequestService.RequestServiceClient CreateRequestClient();
    StockService.StockServiceClient CreateStockClient();
    ExpenseService.ExpenseServiceClient CreateExpenseClient();
    IncomingService.IncomingServiceClient CreateIncomingClient();
    WarehouseService.WarehouseServiceClient CreateWarehouseClient();
}

//IMessageBus.cs
// IMessageBus.cs
namespace WpfClient.Services.Interfaces;

public interface IMessageBus
{
    /// <summary>
    /// Подписывает асинхронный обработчик на сообщение определенного типа.
    /// </summary>
    /// <typeparam name="TMessage">Тип сообщения.</typeparam>
    /// <param name="handler">Асинхронный обработчик сообщения.</param>
    void Subscribe<TMessage>(Func<TMessage, Task> handler);

    /// <summary>
    /// Отписывает асинхронный обработчик от сообщения определенного типа.
    /// </summary>
    /// <typeparam name="TMessage">Тип сообщения.</typeparam>
    /// <param name="handler">Обработчик для удаления.</param>
    void Unsubscribe<TMessage>(Func<TMessage, Task> handler);

    /// <summary>
    /// Асинхронно публикует сообщение всем подписчикам.
    /// </summary>
    /// <typeparam name="TMessage">Тип сообщения.</typeparam>
    /// <param name="message">Сообщение для отправки.</param>
    /// <returns>Задача, завершающаяся после обработки всеми подписчиками.</returns>
    Task Publish<TMessage>(TMessage message);
}

//ClearButtonBehavior.cs
using Microsoft.Xaml.Behaviors;
using System.Windows.Controls;
using System.Windows;

namespace WpfClient.ViewModels.Behaviors;

public class ClearButtonBehavior : Behavior<TextBox>
{
    protected override void OnAttached()
    {
        base.OnAttached();
        AssociatedObject.TextChanged += OnTextChanged;
    }

    private void OnTextChanged(object sender, TextChangedEventArgs e)
    {
        if (AssociatedObject.Template.FindName("ClearButton", AssociatedObject) is Button button)
        {
            button.Visibility = string.IsNullOrEmpty(AssociatedObject.Text)
                ? Visibility.Collapsed
                : Visibility.Visible;
        }
    }

    protected override void OnDetaching()
    {
        AssociatedObject.TextChanged -= OnTextChanged;
        base.OnDetaching();
    }
}

//DatePickerSelectedDateChangedBehavior.cs
using Microsoft.Xaml.Behaviors;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows;

namespace WpfClient.ViewModels.Behaviors;

public class DatePickerSelectedDateChangedBehavior : Behavior<DatePicker>
{
    public static readonly DependencyProperty CommandProperty =
        DependencyProperty.Register(nameof(Command), typeof(ICommand), typeof(DatePickerSelectedDateChangedBehavior), new PropertyMetadata(null));

    public ICommand Command
    {
        get => (ICommand)GetValue(CommandProperty);
        set => SetValue(CommandProperty, value);
    }

    public static readonly DependencyProperty CommandParameterProperty =
        DependencyProperty.Register(nameof(CommandParameter), typeof(object), typeof(DatePickerSelectedDateChangedBehavior), new PropertyMetadata(null));

    public object CommandParameter
    {
        get => GetValue(CommandParameterProperty);
        set => SetValue(CommandParameterProperty, value);
    }

    protected override void OnAttached()
    {
        base.OnAttached();
        AssociatedObject.SelectedDateChanged += OnSelectedDateChanged;
    }

    protected override void OnDetaching()
    {
        base.OnDetaching();
        AssociatedObject.SelectedDateChanged -= OnSelectedDateChanged;
    }

    private void OnSelectedDateChanged(object sender, SelectionChangedEventArgs e)
    {
        if (Command?.CanExecute(CommandParameter) == true)
        {
            Command.Execute(CommandParameter);
        }
    }
}

//MouseClickCommandBehavior.cs
using Microsoft.Xaml.Behaviors;
using System.Windows.Input;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace WpfClient.ViewModels.Behaviors;

public class MouseClickCommandBehavior : Behavior<UIElement>
{
    public static readonly DependencyProperty CommandProperty =
        DependencyProperty.Register(nameof(Command), typeof(ICommand), typeof(MouseClickCommandBehavior), new PropertyMetadata(null));

    public ICommand Command
    {
        get => (ICommand)GetValue(CommandProperty);
        set => SetValue(CommandProperty, value);
    }

    protected override void OnAttached()
    {
        base.OnAttached();
        AssociatedObject.PreviewMouseLeftButtonDown += OnPreviewMouseLeftButtonDown;
    }

    protected override void OnDetaching()
    {
        base.OnDetaching();
        AssociatedObject.PreviewMouseLeftButtonDown -= OnPreviewMouseLeftButtonDown;
    }

    private void OnPreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (e.OriginalSource is DependencyObject source)
        {
            var button = FindParent<Button>(source);
            if (button is { Name: "ClearButton" })
            {
                var cmd = button.Command;
                if (cmd?.CanExecute(null) == true)
                {
                    cmd.Execute(null);
                }
                return;
            }
        }

        if (Command?.CanExecute(null) == true)
        {
            Command.Execute(null);
        }
    }

    private static T FindParent<T>(DependencyObject child) where T : DependencyObject
    {
        var parent = VisualTreeHelper.GetParent(child);

        while (parent != null)
        {
            if (parent is T typed)
                return typed;

            parent = VisualTreeHelper.GetParent(parent);
        }

        return null;
    }
}

//PlaceholderBehavior.cs
using Microsoft.Xaml.Behaviors;
using System.Windows.Controls;
using System.Windows;

namespace WpfClient.ViewModels.Behaviors;

public class PlaceholderBehavior : Behavior<TextBox>
{
    public static readonly DependencyProperty PlaceholderTargetNameProperty =
        DependencyProperty.Register(nameof(PlaceholderTargetName), typeof(string), typeof(PlaceholderBehavior));

    public string PlaceholderTargetName
    {
        get => (string)GetValue(PlaceholderTargetNameProperty);
        set => SetValue(PlaceholderTargetNameProperty, value);
    }

    private FrameworkElement _placeholderElement;

    protected override void OnAttached()
    {
        base.OnAttached();

        AssociatedObject.Loaded += OnLoaded;
        AssociatedObject.TextChanged += OnStateChanged;
        AssociatedObject.GotFocus += OnStateChanged;
        AssociatedObject.LostFocus += OnStateChanged;
    }

    private void OnLoaded(object sender, RoutedEventArgs e)
    {
        if (_placeholderElement == null && !string.IsNullOrEmpty(PlaceholderTargetName))
        {
            _placeholderElement = AssociatedObject.Template.FindName(PlaceholderTargetName, AssociatedObject) as FrameworkElement;
        }

        UpdatePlaceholderVisibility();
    }

    private void OnStateChanged(object sender, RoutedEventArgs e)
    {
        UpdatePlaceholderVisibility();
    }

    private void UpdatePlaceholderVisibility()
    {
        if (_placeholderElement == null) return;

        bool hasText = !string.IsNullOrEmpty(AssociatedObject.Text);
        bool hasFocus = AssociatedObject.IsKeyboardFocused;

        _placeholderElement.Visibility = (!hasText && !hasFocus)
            ? Visibility.Visible
            : Visibility.Collapsed;
    }

    protected override void OnDetaching()
    {
        base.OnDetaching();

        AssociatedObject.Loaded -= OnLoaded;
        AssociatedObject.TextChanged -= OnStateChanged;
        AssociatedObject.GotFocus -= OnStateChanged;
        AssociatedObject.LostFocus -= OnStateChanged;
    }
}

//UnfocusOnClearBehavior .cs
using Microsoft.Xaml.Behaviors;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows;
using System.Windows.Media;

namespace WpfClient.ViewModels.Behaviors;

public class UnfocusOnClearBehavior : Behavior<TextBox>
{
    private TextBox _hiddenTextBox;

    protected override void OnAttached()
    {
        base.OnAttached();

        AssociatedObject.Loaded += (s, e) =>
        {
            _hiddenTextBox = new TextBox
            {
                Width = 0,
                Height = 0,
                Opacity = 0,
                IsTabStop = false,
                Focusable = true,
                Visibility = Visibility.Collapsed
            };

            var parentPanel = FindParentPanel(AssociatedObject);
            if (parentPanel != null && !_hiddenTextBox.IsLoaded)
            {
                parentPanel.Children.Add(_hiddenTextBox);
            }

            AssociatedObject.PreviewMouseLeftButtonDown += OnPreviewMouseLeftButtonDown;
        };
    }

    private void OnPreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (e.OriginalSource is DependencyObject source &&
            FindParent<Button>(source) is Button button &&
            button.Name == "ClearButton")
        {
            AssociatedObject.Clear();
            AssociatedObject.MoveFocus(new TraversalRequest(FocusNavigationDirection.Next)); // от греха

            if (_hiddenTextBox != null)
            {
                _hiddenTextBox.Visibility = Visibility.Visible;
                _hiddenTextBox.Focus();
                _hiddenTextBox.Visibility = Visibility.Collapsed;
            }

            e.Handled = true;
        }
    }

    private T? FindParent<T>(DependencyObject? child) where T : DependencyObject
    {
        while (child != null && child is not T)
        {
            child = VisualTreeHelper.GetParent(child);
        }
        return child as T;
    }

    private Panel? FindParentPanel(DependencyObject? child)
    {
        while (child != null && child is not Panel)
        {
            child = VisualTreeHelper.GetParent(child);
        }
        return child as Panel;
    }
}

public static class ClearTextBehaviorHelper
{
    public static readonly DependencyProperty EnableUnfocusOnClearProperty =
        DependencyProperty.RegisterAttached(
            "EnableUnfocusOnClear",
            typeof(bool),
            typeof(ClearTextBehaviorHelper),
            new PropertyMetadata(false, OnEnableChanged));

    public static void SetEnableUnfocusOnClear(DependencyObject element, bool value) =>
        element.SetValue(EnableUnfocusOnClearProperty, value);

    public static bool GetEnableUnfocusOnClear(DependencyObject element) =>
        (bool)element.GetValue(EnableUnfocusOnClearProperty);

    private static void OnEnableChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is not TextBox textBox) return;

        if ((bool)e.NewValue)
        {
            var behaviors = Interaction.GetBehaviors(textBox);
            if (!behaviors.OfType<UnfocusOnClearBehavior>().Any())
                behaviors.Add(new UnfocusOnClearBehavior());
        }
        else
        {
            var behavior = Interaction.GetBehaviors(textBox).FirstOrDefault(b => b is UnfocusOnClearBehavior);
            if (behavior != null)
                Interaction.GetBehaviors(textBox).Remove(behavior);
        }
    }
}

//InverseBooleanConverter.cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Data;

namespace WpfClient.ViewModels.Helpers
{
    public class InverseBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool boolean)
            {
                return !boolean;
            }
            return value;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool boolean)
            {
                return !boolean;
            }
            return value;
        }
    }
}


//PlaceholderHelper.cs
using System.Windows;

namespace WpfClient.ViewModels.Helpers;

public static class PlaceholderHelper
{
    public static readonly DependencyProperty PlaceholderTextProperty =
        DependencyProperty.RegisterAttached(
            "PlaceholderText",
            typeof(string),
            typeof(PlaceholderHelper),
            new FrameworkPropertyMetadata(string.Empty, FrameworkPropertyMetadataOptions.Inherits));

    public static void SetPlaceholderText(DependencyObject element, string value)
    {
        element.SetValue(PlaceholderTextProperty, value);
    }

    public static string GetPlaceholderText(DependencyObject element)
    {
        return (string)element.GetValue(PlaceholderTextProperty);
    }
}

//TextBoxFocusHelper.cs
using System.Windows.Controls;
using System.Windows;

namespace WpfClient.ViewModels.Helpers;

public static class TextBoxFocusHelper
{
    public static readonly DependencyProperty UnfocusOnClearProperty =
        DependencyProperty.RegisterAttached(
            "UnfocusOnClear",
            typeof(bool),
            typeof(TextBoxFocusHelper),
            new PropertyMetadata(false, OnUnfocusOnClearChanged));

    public static bool GetUnfocusOnClear(DependencyObject obj) => (bool)obj.GetValue(UnfocusOnClearProperty);
    public static void SetUnfocusOnClear(DependencyObject obj, bool value) => obj.SetValue(UnfocusOnClearProperty, value);

    private static void OnUnfocusOnClearChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is TextBox textBox && e.NewValue is true)
        {
            textBox.TextChanged += (sender, args) =>
            {
                if (string.IsNullOrEmpty(textBox.Text))
                {
                    Unfocus(textBox);
                }
            };
        }
    }

    private static void Unfocus(TextBox textBox)
    {
        var dummy = new TextBox
        {
            Width = 0,
            Height = 0,
            Opacity = 0,
            Focusable = true,
            IsTabStop = false,
            Visibility = Visibility.Collapsed
        };

        var parent = FindRootVisual(textBox);
        if (parent is Panel panel)
        {
            panel.Children.Add(dummy);
            dummy.Focus();
            dummy.Dispatcher.BeginInvoke(() =>
            {
                panel.Children.Remove(dummy);
            });
        }
    }

    private static DependencyObject FindRootVisual(DependencyObject current)
    {
        var parent = current;
        while (parent is FrameworkElement { Parent: FrameworkElement p })
            parent = p;
        return parent;
    }
}

//TextBoxClearButton.xaml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:helpers="clr-namespace:WpfClient.ViewModels.Helpers"
                    xmlns:b="http://schemas.microsoft.com/xaml/behaviors"
                    xmlns:behaviors="clr-namespace:WpfClient.ViewModels.Behaviors">

    <Style x:Key="ClearableTextBoxStyle" TargetType="TextBox">
        <Setter Property="MinHeight" Value="30"/>
        <Setter Property="Padding" Value="5"/>
        <Setter Property="behaviors:ClearTextBehaviorHelper.EnableUnfocusOnClear" Value="True" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="TextBox">
                    <Grid>
                        <Border Background="{TemplateBinding Background}"
                            BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            CornerRadius="2">
                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition />
                                    <ColumnDefinition Width="Auto" />
                                </Grid.ColumnDefinitions>
                                <TextBlock x:Name="Placeholder"
                                       Text="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=(helpers:PlaceholderHelper.PlaceholderText)}"
                                       Foreground="Gray"
                                       FontStyle="Italic"
                                       Margin="7,0,30,0"
                                       VerticalAlignment="Center"
                                       IsHitTestVisible="False"
                                       Visibility="Collapsed"
                                       Grid.Column="0" />
                                <ScrollViewer x:Name="PART_ContentHost"
                                          Margin="2"
                                          VerticalAlignment="Center"
                                          Grid.Column="0" />
                                <Button x:Name="ClearButton"
                                    Width="20"
                                    Height="20"
                                    Grid.Column="1"
                                    Margin="0,0,5,0"
                                    VerticalAlignment="Center"
                                    HorizontalAlignment="Center"
                                    Visibility="Collapsed"
                                    Focusable="False"
                                    Background="Transparent"
                                    BorderThickness="0"
                                    Command="{Binding Path=Tag, RelativeSource={RelativeSource TemplatedParent}}">
                                    <Button.Content>
                                        <Path Data="M0,0 L10,10 M0,10 L10,0"
                                          Stroke="Gray"
                                          StrokeThickness="2" />
                                    </Button.Content>
                                    <Button.Style>
                                        <Style TargetType="Button">
                                            <Setter Property="Background" Value="Transparent" />
                                            <Setter Property="BorderThickness" Value="0" />
                                            <Style.Triggers>
                                                <Trigger Property="IsMouseOver" Value="True">
                                                    <Setter Property="Background" Value="#EEE" />
                                                </Trigger>
                                            </Style.Triggers>
                                        </Style>
                                    </Button.Style>
                                </Button>
                            </Grid>
                        </Border>
                    </Grid>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>


