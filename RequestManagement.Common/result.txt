//IAuthService.cs
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Common.Interfaces;

/// <summary>
/// Интерфейс сервиса авторизации
/// </summary>
public interface IAuthService
{
    /// <summary>
    /// Аутентифицирует пользователя по логину и паролю
    /// </summary>
    /// <param name="login">Логин пользователя</param>
    /// <param name="password">Пароль пользователя</param>
    /// <returns>Модель пользователя при успешной аутентификации или null, если аутентификация не удалась</returns>
    Task<User> AuthenticateAsync(string login, string password);

    /// <summary>
    /// Проверяет, имеет ли пользователь права на выполнение действия
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <param name="requiredRole">Требуемая роль для действия</param>
    /// <returns>Признак наличия прав</returns>
    Task<bool> AuthorizeAsync(int userId, UserRole requiredRole);
}

//ICommissionsService.cs
using RequestManagement.Common.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Interfaces
{
    public interface ICommissionsService
    {
        Task<List<Commissions>> GetAllCommissionsAsync(string filter = "");
        Task<int> CreateCommissionsAsync(Commissions warehouse);
        Task<bool> UpdateCommissionsAsync(Commissions warehouse);
        Task<bool> DeleteCommissionsAsync(int id);
    }
}


//IDefectService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IDefectService
{
    Task<List<DefectGroup>> GetAllDefectGroupsAsync(string filter = "");
    Task<int> CreateDefectGroupAsync(DefectGroup defectGroup);
    Task<bool> UpdateDefectGroupAsync(DefectGroup defectGroup);
    Task<bool> DeleteDefectGroupAsync(int id);

    Task<List<Defect>> GetAllDefectsAsync(string filter = "");
    Task<int> CreateDefectAsync(Defect defect);
    Task<bool> UpdateDefectAsync(Defect defect);
    Task<bool> DeleteDefectAsync(int id);
}

//IDriverService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IDriverService
{
    Task<List<Driver>> GetAllDriversAsync(string filter = "");
    Task<int> CreateDriverAsync(Driver driver);
    Task<bool> UpdateDriverAsync(Driver driver);
    Task<bool> DeleteDriverAsync(int id);
}

//IEquipmentService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IEquipmentService
{
    Task<int> CreateEquipmentAsync(Equipment equipment);
    Task<bool> UpdateEquipmentAsync(Equipment equipment);
    Task<bool> DeleteEquipmentAsync(int id);
    Task<List<Equipment>> GetAllEquipmentAsync(string filter = "");
}

//IExpenseService.cs
using RequestManagement.Common.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WpfClient.Models;

namespace RequestManagement.Common.Interfaces
{
    public interface IExpenseService
    {
        Task<Expense> CreateExpenseAsync(Expense expense);
        Task<bool> UpdateExpenseAsync(Expense expense);
        Task<bool> DeleteExpenseAsync(int id);
        Task<UserLastSelection?> GetUserLastSelectionAsync(int userId);
        Task<NomenclatureDefectMapping?> GetLastNomenclatureDefectMappingAsync(int userId, int nomenclatureId);
        Task SaveUserLastSelectionAsync(int userId, int? driverId, int? equipmentId);
        Task SaveNomenclatureDefectMappingAsync(int userId, int stockId, int defectId);
        Task<bool> DeleteExpensesAsync(List<int> requestId);
        Task<List<Expense>> GetAllExpensesAsync(string requestFilter, int requestWarehouseId, int requestEquipmentId, int requestDriverId, int requestDefectId, string requestFromDate, string requestToDate);
        Task<bool> UploadMaterialsExpenseAsync(List<MaterialExpense>? materials, int warehouseId);
    }
}


//IIncomingService.cs
using RequestManagement.Common.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Interfaces
{
    public interface IIncomingService
    {
        Task<Incoming> CreateIncomingAsync(Incoming incoming);
        Task<bool> UpdateIncomingAsync(Incoming expense);
        Task<bool> DeleteIncomingAsync(int id);
        Task<bool> DeleteIncomingsAsync(List<int> requestId);
        Task<List<Incoming>> GetAllIncomingsAsync(string requestFilter, int requestWarehouseId, string requestFromDate, string requestToDate);
        Task<bool> UploadIncomingsAsync(MaterialIncoming incoming);
    }
}


//INomenclatureAnalogService.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces
{
    public interface INomenclatureAnalogService
    {
        Task<List<Nomenclature>> GetAllNomenclatureAnalogsAsync(int filter);
        Task<int> AddNomenclatureAnalogAsync(NomenclatureAnalog nomenclatureAnalog);
        Task<bool> DeleteNomenclatureAnalogAsync(int originalId, int analogId);
    }
}


//INomenclatureService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface INomenclatureService
{
    Task<List<Nomenclature>> GetAllNomenclaturesAsync(string filter = "");
    Task<int> CreateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> UpdateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> DeleteNomenclatureAsync(int id);
}

//IRequestService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IRequestService
{
    Task<int> CreateEquipmentAsync(Equipment equipment);
    Task<bool> UpdateEquipmentAsync(Equipment equipment);
    Task<bool> DeleteEquipmentAsync(int id);
    Task<List<Equipment>> GetAllEquipmentAsync(string filter = "");

    Task<List<Driver>> GetAllDriversAsync(string filter = "");
    Task<int> CreateDriverAsync(Driver driver);
    Task<bool> UpdateDriverAsync(Driver driver);
    Task<bool> DeleteDriverAsync(int id);

    Task<List<DefectGroup>> GetAllDefectGroupsAsync(string filter = "");
    Task<int> CreateDefectGroupAsync(DefectGroup driver);
    Task<bool> UpdateDefectGroupAsync(DefectGroup driver);
    Task<bool> DeleteDefectGroupAsync(int id);

    Task<List<Defect>> GetAllDefectsAsync(string filter = "");
    Task<int> CreateDefectAsync(Defect driver);
    Task<bool> UpdateDefectAsync(Defect driver);
    Task<bool> DeleteDefectAsync(int id);

    Task<List<Nomenclature>> GetAllNomenclaturesAsync(string filter = "");
    Task<int> CreateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> UpdateNomenclatureAsync(Nomenclature nomenclature);
    Task<bool> DeleteNomenclatureAsync(int id);
}

//IStockService.cs
using RequestManagement.Common.Models;
using WpfClient.Models;

namespace RequestManagement.Common.Interfaces;

public interface IStockService
{
    Task<int> CreateStockAsync(Stock stock);
    Task<bool> UpdateStockAsync(Stock stock);
    Task<bool> DeleteStockAsync(int id);
    Task<List<Stock>> GetAllStocksAsync(int warehouseId,
        string filter = "",
        int initialQuantityFilterType = 0,
        double initialQuantityFilter = 0,
        int receivedQuantityFilterType = 0,
        double receivedQuantityFilter = 0,
        int consumedQuantityFilterType = 0,
        double consumedQuantityFilter = 0,
        int finalQuantityFilterType = 0,
        double finalQuantityFilter = 0
        );
    Task<bool> UploadMaterialsStockAsync(List<MaterialStock>? materials, int warehouseId, DateTime date);
}

//IUserService.cs
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Common.Interfaces;

/// <summary>
/// Интерфейс сервиса для работы с пользователями
/// </summary>
public interface IUserService
{
    /// <summary>
    /// Создает нового пользователя
    /// </summary>
    /// <param name="user">Модель пользователя для создания</param>
    /// <returns>Идентификатор созданного пользователя</returns>
    Task<int> CreateUserAsync(User user);

    /// <summary>
    /// Обновляет данные пользователя
    /// </summary>
    /// <param name="user">Обновленная модель пользователя</param>
    /// <returns>Признак успешного обновления</returns>
    Task<bool> UpdateUserAsync(User user);

    /// <summary>
    /// Удаляет пользователя по идентификатору
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <returns>Признак успешного удаления</returns>
    Task<bool> DeleteUserAsync(int userId);

    /// <summary>
    /// Получает пользователя по идентификатору
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <returns>Модель пользователя или null, если пользователь не найден</returns>
    Task<User> GetUserByIdAsync(int userId);

    /// <summary>
    /// Получает пользователя по логину
    /// </summary>
    /// <param name="login">Логин пользователя</param>
    /// <returns>Модель пользователя или null, если пользователь не найден</returns>
    Task<User> GetUserByLoginAsync(string login);

    /// <summary>
    /// Проверяет, имеет ли пользователь указанную роль
    /// </summary>
    /// <param name="userId">Идентификатор пользователя</param>
    /// <param name="role">Роль для проверки</param>
    /// <returns>Признак соответствия роли</returns>
    Task<bool> HasRoleAsync(int userId, UserRole role);
}

//IWarehouseService.cs
using RequestManagement.Common.Models;

namespace RequestManagement.Common.Interfaces;

public interface IWarehouseService
{
    Task<List<Warehouse>> GetAllWarehousesAsync(string filter = "");
    Task<Warehouse> GetOrCreateWarehousesAsync(string filter);
    Task<int> CreateWarehouseAsync(Warehouse warehouse);
    Task<bool> UpdateWarehouseAsync(Warehouse warehouse);
    Task<bool> DeleteWarehouseAsync(int id);
}

//Application.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models
{
    public class Application : IEntity
    {
        public int Id { get; set; }
        public string Number { get; set; } = string.Empty;
        public DateTime Date { get; set; }
        public Driver? Responsible { get; set; }
        public int ResponsibleId { get; set; }
        public Equipment? Equipment { get; set; }
        public int EquipmentId { get; set; }
    }
}


//Commissions.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class Commissions : IEntity
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public int ApproveForActId { get; set; }
        public Driver? ApproveForAct { get; set; } = null;
        public int ApproveForDefectAndLimitId { get; set; }
        public Driver? ApproveForDefectAndLimit { get; set; } = null;
        public int ChairmanId { get; set; }
        public Driver? Chairman { get; set; }
        public int Member1Id { get; set; }
        public Driver? Member1 { get; set; }
        public int Member2Id { get; set; }
        public Driver? Member2 { get; set; }
        public int Member3Id { get; set; }
        public Driver? Member3 { get; set; }
        public int Member4Id { get; set; }
        public Driver? Member4 { get; set; }
    }
}


//Defect.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Defect : IEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public int DefectGroupId { get; set; }      // Группа дефекта (внешний ключ)
    public DefectGroup DefectGroup { get; set; }
}

//DefectGroup.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class DefectGroup : IEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public List<Defect> Defects { get; set; } = [];
}

//Driver.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Driver : IEntity
{
    public int Id { get; set; }
    public string FullName { get; set; } = string.Empty;
    public string ShortName { get; set; } = string.Empty;
    public string Position { get; set; } = string.Empty;
    public string Code { get; set; } = string.Empty;
}

//Equipment.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

/// <summary>
/// Модель единицы техники (назначения) для заявки
/// </summary>
public class Equipment : IEntity
{
    /// <summary>
    /// Уникальный идентификатор единицы техники
    /// </summary>
    public int Id { get; set; }

    /// <summary>
    /// Название единицы техники
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Государственный номер (может отсутствовать)
    /// </summary>
    public string? StateNumber { get; set; } = string.Empty;
    public string Code { get; set; } = string.Empty;
}

//Expense.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class Expense : IEntity
    {
        [NotMapped] public bool IsSelected { get; set; }
        public int Id { get; set; }
        public string? Code { get; set; } = string.Empty;
        public int StockId { get; set; }
        public Stock Stock { get; set; } = null!;
        public decimal Quantity { get; set; }
        public int EquipmentId { get; set; }
        public Equipment Equipment { get; set; } = null!;
        public int DriverId { get; set; }
        public Driver Driver { get; set; } = null!;
        public int DefectId { get; set; }
        public Defect Defect { get; set; } = null!;
        public DateTime Date { get; set; }
    }
}


//Helpers.cs
namespace RequestManagement.Common.Models;

public static class Helpers
{
    public record QuantityFilter(decimal Value, ComparisonOperator Operator)
    {
        private static QuantityFilter GreaterThan(decimal value) => new(value, ComparisonOperator.GreaterThan);
        private static QuantityFilter EqualTo(decimal value) => new(value, ComparisonOperator.EqualTo);
        private static QuantityFilter LessThan(decimal value) => new(value, ComparisonOperator.LessThan);
        public static QuantityFilter? GetQuantityFilter(decimal value, int type) => type switch { 1 => EqualTo(value), 2 => GreaterThan(value), 3 => LessThan(value), _ => null };
    }

    public enum ComparisonOperator
    {
        GreaterThan,
        EqualTo,
        LessThan
    }
}

//Incoming.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models;
public class Incoming : IEntity
{
    [NotMapped]
    public bool IsSelected { get; set; }
    public int Id { get; set; }
    public int StockId { get; set; }
    public Stock Stock { get; set; } = null!;
    public decimal Quantity { get; set; }
    public DateTime Date { get; set; }
    public string Code { get; set; } = string.Empty;
    public Application? Application { get; set; }
    public int ApplicationId { get; set; }
}


//MaterialExpense.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class MaterialExpense
    {
        public string Number { get; set; }
        public DateTime Date { get; set; }
        public string DriverFullName { get; set; }
        public string DriverCode { get; set; }
        public string EquipmentName { get; set; }
        public string EquipmentCode { get; set; }
        public string NomenclatureName { get; set; }
        public string NomenclatureCode { get; set; }
        public string NomenclatureArticle { get; set; } 
        public string NomenlatureUnitOfMeasure { get; set; }
        public decimal Quantity { get; set; }
    }
}


//MaterialIncoming.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WpfClient.Models;

namespace RequestManagement.Common.Models
{
    public class MaterialIncoming
    {
        public string? WarehouseName { get; set; }
        public List<MaterialIncomingItem> Items { get; set; }
    }

    public class MaterialIncomingItem
    {
        public string RegistratorType { get; set; }
        public string RegistratorNumber { get; set; }
        public string RegistratorDate { get; set; }
        public string ReceiptOrderNumber { get; set; }
        public string ReceiptOrderDate { get; set; }
        public string ApplicationNumber { get; set; }
        public string ApplicationDate { get; set; } 
        public string ApplicationResponsibleName { get; set; }
        public string ApplicationEquipmentName { get; set; }
        public string ApplicationEquipmentCode { get; set; }
        public List<MaterialStock> Items { get; set; }
    }
}


//MaterialStock.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WpfClient.Models
{
    public class MaterialStock
    {
        public string ItemName { get; set; }
        public string Code { get; set; }
        public string Article { get; set; }
        public string Unit { get; set; }
        public double FinalBalance { get; set; }
    }
}


//Nomenclature.cs
using RequestManagement.Common.Models.Interfaces;
using System.ComponentModel.DataAnnotations.Schema;
using System.ComponentModel.DataAnnotations;

namespace RequestManagement.Common.Models;

public class Nomenclature : IEntity
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public int Id { get; set; }
    public string Code { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string? Article { get; set; } = string.Empty;
    public string UnitOfMeasure { get; set; } = string.Empty;
    public List<Stock> Stocks { get; set; } = []; // Связь один-ко-многим
}

//NomenclatureAnalog.cs
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models
{
    public class NomenclatureAnalog : IEntity
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }
        public Nomenclature Original { get; set; }
        public int OriginalId { get; set; }
        public Nomenclature Analog { get; set; }
        public int AnalogId { get; set; }
    }
}


//NomenclatureDefectMapping.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class NomenclatureDefectMapping : IEntity
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public User User { get; set; } = null!;
        public int NomenclatureId { get; set; }
        public Nomenclature Nomenclature { get; set; } = null!;
        public int DefectId { get; set; }
        public Defect Defect { get; set; } = null!;
        public DateTime LastUsed { get; set; }
    }
}


//Stock.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Stock : IEntity
{
    public int Id { get; set; }
    public int WarehouseId { get; set; }
    public Warehouse Warehouse { get; set; } = null!; // Внешний ключ на таблицу Warehouse
    public int NomenclatureId { get; set; }
    public Nomenclature Nomenclature { get; set; } = null!; // Внешний ключ на таблицу Nomenclature
    public decimal InitialQuantity { get; set; } // Начальное количество
    public decimal ReceivedQuantity { get; set; } // Количество поступления
    public decimal ConsumedQuantity { get; set; }
    public decimal FinalQuantity => InitialQuantity + ReceivedQuantity - ConsumedQuantity;
}

//User.cs
using RequestManagement.Common.Models.Enums;
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

/// <summary>
/// Модель пользователя системы
/// </summary>
public class User : IEntity
{
    /// <summary>
    /// Уникальный идентификатор пользователя
    /// </summary>
    public int Id { get; set; }

    /// <summary>
    /// Логин пользователя
    /// </summary>
    public string Login { get; set; }

    /// <summary>
    /// Пароль пользователя (хранится в зашифрованном виде)
    /// </summary>
    public string Password { get; set; }

    /// <summary>
    /// Роль пользователя в системе
    /// </summary>
    public UserRole Role { get; set; }
}

//UserLastSelection.cs
using RequestManagement.Common.Models.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RequestManagement.Common.Models
{
    public class UserLastSelection : IEntity
    {
        public int Id { get; set; }
        public int UserId { get; set; }
        public User? User { get; set; }
        public int? DriverId { get; set; }
        public Driver? Driver { get; set; }
        public int? EquipmentId { get; set; }
        public Equipment? Equipment { get; set; }
        public int? CommissionsId { get; set; }
        public Commissions? Commissions { get; set; }
        public DateTime LastUpdated { get; set; }
    }
}


//Warehouse.cs
using RequestManagement.Common.Models.Interfaces;

namespace RequestManagement.Common.Models;

public class Warehouse : IEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Code { get; set; } = string.Empty;
    public DateTime LastUpdated { get; set; }
    // Другие поля склада, если нужно
    public List<Stock> Stocks { get; set; } = []; // Связь один-ко-многим
}

//ExcelHelpers.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Text;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Windows.Networking;
using static System.Net.Mime.MediaTypeNames;
using static System.Runtime.InteropServices.JavaScript.JSType;
using Font = System.Drawing.Font;

namespace RequestManagement.Common.Utilities
{
    public static class ExcelHelpers
    {
        public static string GetSafeSheetName(string name)
        {
            // Удаляем недопустимые символы и обрезаем до 31 символа
            var invalidChars = Path.GetInvalidFileNameChars().Concat(['[', ']', '*', '?', '/', '\\']);
            name = invalidChars.Aggregate(name, (current, c) => current.Replace(c, '_'));
            return name.Length > 31 ? name[..31] : name;
        }

        public static double GetRowHeight(double columnWidth, string fontName, float fontSize, string text,float rowHeight = 13.25f)
        {
            const float pixelsPerExcelColumn = 6.11f;
            var columnWidthInPixels = (float)(columnWidth * pixelsPerExcelColumn)/1.01f;
            var lineCount =  GetLineCount(columnWidthInPixels, fontName, fontSize, text, rowHeight);
            return lineCount * rowHeight;
        }
        private static int GetLineCount(double columnWidth, string fontName, float fontSize, string text, float rowHeight)
        {
            using var bmp = new Bitmap(1, 1);
            using var g = Graphics.FromImage(bmp);
            g.TextRenderingHint = TextRenderingHint.AntiAlias;
            var font = new Font(fontName, fontSize);
            var maxSize = new SizeF((float)columnWidth, 1000f);
            var format = new StringFormat(StringFormatFlags.LineLimit);
            format.Trimming = StringTrimming.Word;
            var textSize = g.MeasureString(text, font, maxSize, format);
            var lineCount = (int)Math.Ceiling(textSize.Height / rowHeight);
            return lineCount;
        }
    }
}


//NameFormatter.cs
namespace RequestManagement.Common.Utilities
{
    public static class NameFormatter
    {
        /// <summary>
        /// Преобразует полное имя (например, "Иванов Иван Иванович", "Иванов Иван" или "Иванов Иван Угли")
        /// в сокращённую запись (например, "Иванов И.И." или "Иванов И."). 
        /// Отчество необязательно, дополнительные части после имени или отчества игнорируются.
        /// </summary>
        /// <param name="fullName">Полное имя, состоящее из 2 или более частей, разделённых пробелами.</param>
        /// <returns>Сокращённая запись имени (например, "Иванов И.И." или "Иванов И.") или null, если входные данные некорректны.</returns>
        public static string FormatToShortName(string? fullName)
        {
            // Проверка на null или пустую строку
            if (string.IsNullOrWhiteSpace(fullName))
            {
                return "";
            }

            // Разделяем имя на части, игнорируя множественные пробелы
            var parts = fullName.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);

            // Проверяем, что есть минимум 2 части (фамилия и имя)
            if (parts.Length < 2)
            {
                return "";
            }

            // Извлекаем фамилию и имя
            var surname = parts[0];
            var firstName = parts[1];

            // Проверяем, что фамилия и имя не пустые
            if (string.IsNullOrEmpty(surname) || string.IsNullOrEmpty(firstName))
            {
                return "";
            }

            // Формируем сокращённую запись
            // Если есть отчество (3 или более частей), добавляем его инициал
            if (parts.Length >= 3 && !string.IsNullOrEmpty(parts[2]))
            {
                var patronymic = parts[2];
                return $"{surname} {firstName[0]}.{patronymic[0]}.";
            }

            // Если отчества нет, возвращаем только инициал имени
            return $"{surname} {firstName[0]}.";
        }
    }
}

//UserRole.cs
namespace RequestManagement.Common.Models.Enums;

/// <summary>
/// Перечисление ролей пользователей
/// </summary>
public enum UserRole
{
    /// <summary>
    /// Администратор с полными правами
    /// </summary>
    Administrator = 0,

    /// <summary>
    /// Пользователь с ограниченными правами
    /// </summary>
    User = 1,

    /// <summary>
    /// Наблюдатель с правами только на чтение
    /// </summary>
    Observer = 2
}

//IEntity.cs
namespace RequestManagement.Common.Models.Interfaces
{
    public interface IEntity
    {
        public int Id { get; set; }
    }
}


//Program.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Server.Data;
using RequestManagement.Server.Services;
using RequestManagement.Common.Interfaces;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;

var builder = WebApplication.CreateBuilder(args);

// ����������� ��������� ��
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

// ����������� ��������
builder.Services.AddScoped<IRequestService, RequestService>();
builder.Services.AddScoped<IStockService, StockService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IExpenseService, ExpenseService>();
builder.Services.AddScoped<IIncomingService, IncomingService>();
builder.Services.AddScoped<IWarehouseService, WarehouseService>();
builder.Services.AddScoped<ICommissionsService, CommissionsService>();
builder.Services.AddScoped<INomenclatureAnalogService, NomenclatureAnalogService>();

// ��������� JWT
var key = Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"] ?? throw new InvalidOperationException());
builder.Services.AddAuthorization();

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(key)
        };
    });

// ���������� gRPC
builder.Services.AddGrpc();

var app = builder.Build();
AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);
// ��������� ��������� ��������� ��������
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();

app.MapGrpcService<RequestManagement.Server.Controllers.RequestController>();
app.MapGrpcService<RequestManagement.Server.Controllers.StockController>();
app.MapGrpcService<RequestManagement.Server.Controllers.AuthController>();
app.MapGrpcService<RequestManagement.Server.Controllers.ExpenseController>();
app.MapGrpcService<RequestManagement.Server.Controllers.IncomingController>();
app.MapGrpcService<RequestManagement.Server.Controllers.WarehouseController>();
app.MapGrpcService<RequestManagement.Server.Controllers.CommissionsController>();
app.MapGrpcService<RequestManagement.Server.Controllers.NomenclatureAnalogController>();

app.Run();

//AuthController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Controllers
{
    /// <summary>
    /// gRPC-контроллер для аутентификации
    /// </summary>
    public class AuthController : AuthService.AuthServiceBase
    {
        private readonly IAuthService _authService;
        private readonly ILogger<AuthController> _logger;
        private readonly IConfiguration _configuration;

        public AuthController(IAuthService authService, ILogger<AuthController> logger, IConfiguration configuration)
        {
            _authService = authService;
            _logger = logger;
            _configuration = configuration;
        }

        /// <summary>
        /// Аутентифицирует пользователя и возвращает JWT-токен
        /// </summary>
        public override async Task<AuthenticateResponse> Authenticate(AuthenticateRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Authenticating user with login: {Login}", request.Login);

            var user = await _authService.AuthenticateAsync(request.Login, request.Password);
            if (user == null)
            {
                return new AuthenticateResponse
                {
                    UserId = 0,
                    Login = "",
                    Role = 0,
                    Token = ""
                };
            }

            // Генерация JWT-токена
            var token = GenerateJwtToken(user);

            return new AuthenticateResponse
            {
                UserId = user.Id,
                Login = user.Login,
                Role = (int)user.Role,
                Token = token
            };
        }

        /// <summary>
        /// Проверяет права доступа пользователя
        /// </summary>
        public override async Task<AuthorizeResponse> Authorize(AuthorizeRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Authorizing user {UserId} for role {Role}", request.UserId, request.RequiredRole);

            bool isAuthorized = await _authService.AuthorizeAsync(request.UserId, (UserRole)request.RequiredRole);
            return new AuthorizeResponse { IsAuthorized = isAuthorized };
        }

        /// <summary>
        /// Генерирует JWT-токен для пользователя
        /// </summary>
        private string GenerateJwtToken(User user)
        {
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
            var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var claims = new[]
            {
                new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
                new Claim(JwtRegisteredClaimNames.UniqueName, user.Login),
                new Claim(ClaimTypes.Role, user.Role.ToString()),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            };

            var token = new JwtSecurityToken(
                issuer: _configuration["Jwt:Issuer"],
                audience: _configuration["Jwt:Audience"],
                claims: claims,
                expires: DateTime.Now.AddHours(1), // Токен действителен 1 час
                signingCredentials: credentials
            );

            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}

//CommissionsController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;

namespace RequestManagement.Server.Controllers
{
    public class CommissionsController(ICommissionsService commissionsService, ILogger<RequestController> logger)
        : CommissionsService.CommissionsServiceBase
    {
        public override async Task<GetAllCommissionsResponse> GetAllCommissions(GetAllCommissionsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all commissions by filter");

            var commissionsList = await commissionsService.GetAllCommissionsAsync(request.Filter);
            var response = new GetAllCommissionsResponse();
            response.Commissions.AddRange(commissionsList.Select(e => new Commissions
            {
                Id = e.Id,
                Name = e.Name,
                ApproveAct = e.ApproveForAct != null ? new CommissionsDriver
                {
                    Id = e.ApproveForAct.Id,
                    FullName = e.ApproveForAct.FullName,
                    ShortName = e.ApproveForAct.ShortName,
                    Position = e.ApproveForAct.Position
                } : null,
                ApproveDefectAndLimit = e.ApproveForDefectAndLimit != null ? new CommissionsDriver
                {
                    Id = e.ApproveForDefectAndLimit.Id,
                    FullName = e.ApproveForDefectAndLimit.FullName,
                    ShortName = e.ApproveForDefectAndLimit.ShortName,
                    Position = e.ApproveForDefectAndLimit.Position
                } : null,
                Chairman = e.Chairman != null ? new CommissionsDriver
                {
                    Id = e.Chairman.Id,
                    FullName = e.Chairman.FullName,
                    ShortName = e.Chairman.ShortName,
                    Position = e.Chairman.Position
                } : null,
                Member1 = e.Member1 != null ? new CommissionsDriver
                {
                    Id = e.Member1.Id,
                    FullName = e.Member1.FullName,
                    ShortName = e.Member1.ShortName,
                    Position = e.Member1.Position
                } : null,
                Member2 = e.Member2 != null ? new CommissionsDriver
                {
                    Id = e.Member2.Id,
                    FullName = e.Member2.FullName,
                    ShortName = e.Member2.ShortName,
                    Position = e.Member2.Position
                } : null,
                Member3 = e.Member3 != null ? new CommissionsDriver
                {
                    Id = e.Member3.Id,
                    FullName = e.Member3.FullName,
                    ShortName = e.Member3.ShortName,
                    Position = e.Member3.Position
                } : null,
                Member4 = e.Member4 != null ? new CommissionsDriver
                {
                    Id = e.Member4.Id,
                    FullName = e.Member4.FullName,
                    ShortName = e.Member4.ShortName,
                    Position = e.Member4.Position
                } : null
            }));
            return response;
        }

        public override async Task<CreateCommissionsResponse> CreateCommissions(CreateCommissionsRequest request, ServerCallContext context)
        {
            logger.LogInformation("Creating new commissions with name: {Name}", request.Name);

            var commissions = new RequestManagement.Common.Models.Commissions
            {
                Name = request.Name,
                ApproveForActId = request.ApproveActId == 0 ? 1 : request.ApproveActId,
                ApproveForDefectAndLimitId = request.ApproveDefectAndLimitId == 0 ? 1 : request.ApproveDefectAndLimitId,
                ChairmanId = request.ChairmanId == 0 ? 1 : request.ChairmanId,
                Member1Id = request.Member1Id == 0 ? 1 : request.Member1Id,
                Member2Id = request.Member2Id == 0 ? 1 : request.Member2Id,
                Member3Id = request.Member3Id == 0 ? 1 : request.Member3Id,
                Member4Id = request.Member4Id == 0 ? 1 : request.Member4Id
            };

            var id = await commissionsService.CreateCommissionsAsync(commissions);
            return new CreateCommissionsResponse { Id = id };
        }

        public override async Task<UpdateCommissionsResponse> UpdateCommissions(UpdateCommissionsRequest request, ServerCallContext context)
        {
            try
            {
                logger.LogInformation("Updating commissions with ID: {Id}", request.Id);

                var commissions = new RequestManagement.Common.Models.Commissions
                {
                    Id = request.Id,
                    Name = request.Name,
                    ApproveForActId = request.ApproveActId == 0 ? 1 : request.ApproveActId,
                    ApproveForDefectAndLimitId = request.ApproveDefectAndLimitId == 0 ? 1 : request.ApproveDefectAndLimitId,
                    ChairmanId = request.ChairmanId == 0 ? 1 : request.ChairmanId,
                    Member1Id = request.Member1Id == 0 ? 1 : request.Member1Id,
                    Member2Id = request.Member2Id == 0 ? 1 : request.Member2Id,
                    Member3Id = request.Member3Id == 0 ? 1 : request.Member3Id,
                    Member4Id = request.Member4Id == 0 ? 1 : request.Member4Id
                };

                var success = await commissionsService.UpdateCommissionsAsync(commissions);
                return new UpdateCommissionsResponse { Success = success };
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Error updating commissions with ID: {Id}", request.Id);
                return new UpdateCommissionsResponse { Success = false};
            }
        }

        public override async Task<DeleteCommissionsResponse> DeleteCommissions(DeleteCommissionsRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting commissions with ID: {Id}", request.Id);

            var success = await commissionsService.DeleteCommissionsAsync(request.Id);
            return new DeleteCommissionsResponse { Success = success };
        }
    }
}


//ExpenseController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using System.Security.Claims;

namespace RequestManagement.Server.Controllers
{
    public class ExpenseController(IExpenseService expenseService, ILogger<RequestController> logger) : ExpenseService.ExpenseServiceBase
    {
        private readonly IExpenseService _expenseService = expenseService ?? throw new ArgumentNullException(nameof(expenseService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        public override async Task<GetNomenclatureMapingResponse> GetNomenclatureMaping(
            GetNomenclatureMapingRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            var value = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var response = new GetNomenclatureMapingResponse();
            if (value != null)
            {
                var userId = int.Parse(value);
                var mapping = await _expenseService.GetLastNomenclatureDefectMappingAsync(userId, request.NomenclatureId);
                if (mapping != null)
                {
                    response.Defect = new ExpenseDefect
                    {
                        Id = mapping.Defect.Id,
                        Name = mapping.Defect.Name,
                    };
                }
            }
            return response;
        }

        public override async Task<GetLastSelectionResponse> GetLastSelection(GetLastSelectionRequest request,
            ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            var value = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var response = new GetLastSelectionResponse();
            if (value != null)
            {
                var userId = int.Parse(value);
                var lastSelection = await _expenseService.GetUserLastSelectionAsync(userId);
                if (lastSelection != null)
                {
                    if (lastSelection is { DriverId: not null, Driver: not null })
                        response.Driver = new ExpenseDriver
                        {
                            Id = lastSelection.Driver.Id,
                            FullName = lastSelection.Driver.FullName,
                            ShortName = lastSelection.Driver.ShortName,
                            Position = lastSelection.Driver.Position
                        };
                    if (lastSelection is { EquipmentId: not null, Equipment: not null })
                        response.Equipment = new ExpenseEquipment
                        {
                            Id = lastSelection.Equipment.Id,
                            Name = lastSelection.Equipment.Name,
                            LicensePlate = lastSelection.Equipment.StateNumber
                        };
                }
                var mapping = await _expenseService.GetLastNomenclatureDefectMappingAsync(userId, request.NomenclatureId);
                if (mapping != null)
                {
                    response.Defect = new ExpenseDefect
                    {
                        Id = mapping.Defect.Id,
                        Name = mapping.Defect.Name,
                    };
                }
            }
            return response;
        }

        public override async Task<GetAllExpensesResponse> GetAllExpenses(GetAllExpensesRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all expenses");

            var expenseList = await _expenseService.GetAllExpensesAsync(request.Filter, request.WarehouseId, request.EquipmentId, request.DriverId, request.DefectId, request.FromDate, request.ToDate);
            var response = new GetAllExpensesResponse();
            response.Expenses.AddRange(expenseList.Select(e => new Expense
            {
                Id = e.Id,
                Code = e.Code,
                Stock = new ExpenseStock
                {
                    Id = e.StockId,
                    Warehouse = new ExpenseWarehouse
                    {
                        Id = e.Stock.Warehouse.Id,
                        Name = e.Stock.Warehouse.Name
                    },
                    Nomenclature = new ExpenseNomenclature
                    {
                        Id = e.Stock.Nomenclature.Id,
                        Name = e.Stock.Nomenclature.Name,
                        Code = e.Stock.Nomenclature.Code,
                        UnitOfMeasure = e.Stock.Nomenclature.UnitOfMeasure,
                        Article = e.Stock.Nomenclature.Article
                    },
                    InitialQuantity = (double)e.Stock.InitialQuantity,
                    ReceivedQuantity = (double)e.Stock.ReceivedQuantity,
                    ConsumedQuantity = (double)e.Stock.ConsumedQuantity
                },
                Quantity = (double)e.Quantity,
                Equipment = new ExpenseEquipment
                {
                    Id = e.Equipment.Id,
                    Name = e.Equipment.Name,
                    Code = e.Equipment.Code,
                    LicensePlate = e.Equipment.StateNumber
                },
                Driver = new ExpenseDriver
                {
                    Id = e.Driver.Id,
                    Code = e.Driver.Code,
                    FullName = e.Driver.FullName,
                    ShortName = e.Driver.ShortName,
                    Position = e.Driver.Position
                },
                Defect = new ExpenseDefect
                {
                    Id = e.Defect.Id,
                    Name = e.Defect.Name,
                    DefectGroup = new ExpenseDefectGroup
                    {
                        Id = e.Defect.DefectGroupId,
                        Name = e.Defect.DefectGroup.Name
                    }
                },
                Date = e.Date.ToString("o") // ISO 8601 format
            }));

            return response;
        }

        public override async Task<CreateExpenseResponse> CreateExpense(CreateExpenseRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }
            var userId = 0;
            var value = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (value != null)
            {
                userId = int.Parse(value);
            }
            _logger.LogInformation("Creating new expense");
            var expense = new RequestManagement.Common.Models.Expense
            {
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                EquipmentId = request.EquipmentId,
                DriverId = request.DriverId,
                DefectId = request.DefectId,
                Date = DateTime.Parse(request.Date)
            };
            var newExpense = await _expenseService.CreateExpenseAsync(expense);
            await _expenseService.SaveUserLastSelectionAsync(userId, request.DriverId, request.EquipmentId);
            await _expenseService.SaveNomenclatureDefectMappingAsync(userId, newExpense.StockId, request.DefectId);
            return new CreateExpenseResponse { Id = newExpense.Id };
        }

        public override async Task<UpdateExpenseResponse> UpdateExpense(UpdateExpenseRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }
            _logger.LogInformation("Updating expense with ID: {Id}", request.Id);
            var userId = 0;
            var value = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (value != null)
            {
                userId = int.Parse(value);
            }
            var expense = new Common.Models.Expense
            {
                Id = request.Id,
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                EquipmentId = request.EquipmentId,
                DriverId = request.DriverId,
                DefectId = request.DefectId,
                Date = DateTime.Parse(request.Date)
            };

            var success = await _expenseService.UpdateExpenseAsync(expense);
            await _expenseService.SaveUserLastSelectionAsync(userId, request.DriverId, request.EquipmentId);
            await _expenseService.SaveNomenclatureDefectMappingAsync(userId, expense.StockId, request.DefectId);
            return new UpdateExpenseResponse { Success = success };
        }

        public override async Task<DeleteExpenseResponse> DeleteExpense(DeleteExpenseRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting expense with ID: {Id}", request.Id);

            var success = await _expenseService.DeleteExpenseAsync(request.Id);
            return new DeleteExpenseResponse { Success = success };
        }
        public override async Task<DeleteExpenseResponse> DeleteExpenses(DeleteExpensesRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting expense with IDs : {Id}", request.Id.ToList());

            var success = await _expenseService.DeleteExpensesAsync(request.Id.ToList());
            return new DeleteExpenseResponse { Success = success };
        }

        public override async Task<UploadMaterialExpenseResponse> UploadMaterialExpense(
            UploadMaterialExpenseRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Uploading expense with excel file");
            var materialExpense =
                request.MaterialExpenses.Select(x => new RequestManagement.Common.Models.MaterialExpense
                {
                    Number = x.Number,
                    Date = DateTime.Parse(x.Date),
                    DriverFullName = x.DriverFullName,
                    EquipmentCode = x.EquipmentCode,
                    NomenclatureArticle = x.NomenclatureArticle,
                    NomenlatureUnitOfMeasure = x.NomenlatureUnitOfMeasure,
                    DriverCode = x.DriverCode,
                    NomenclatureName = x.NomenclatureName,
                    EquipmentName = x.EquipmentName,
                    NomenclatureCode = x.NomenclatureCode,
                    Quantity = (decimal)x.Quantity
                }).ToList();
            var success = await _expenseService.UploadMaterialsExpenseAsync(materialExpense, request.WarehouseId);
            return new UploadMaterialExpenseResponse { Success = success };
        }
    }
}


//IncomingController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using WpfClient.Models;

namespace RequestManagement.Server.Controllers
{
    public class IncomingController(IIncomingService incomingService, ILogger<RequestController> logger) : IncomingService.IncomingServiceBase
    {
        private readonly IIncomingService _incomingService = incomingService ?? throw new ArgumentNullException(nameof(incomingService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        public override async Task<UploadMaterialIncomingResponse> UploadMaterialIncoming(UploadMaterialIncomingRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Upload incomings");
            var result = await _incomingService.UploadIncomingsAsync(new MaterialIncoming
            {
                WarehouseName = request.WarehouseName,
                Items = request.Items.Select(x=>new MaterialIncomingItem
                {
                    RegistratorNumber = x.RegistratorNumber,
                    RegistratorType = x.RegistratorType,
                    RegistratorDate = x.RegistratorDate,
                    ReceiptOrderNumber = x.ReceiptOrderNumber,
                    ReceiptOrderDate = x.ReceiptOrderDate,
                    ApplicationNumber = x.ApplicationNumber,
                    ApplicationDate = x.ApplicationDate,
                    ApplicationResponsibleName = x.ApplicationResponsibleName,
                    ApplicationEquipmentName = x.ApplicationEquipmentName,
                    ApplicationEquipmentCode = x.ApplicationEquipmentCode,
                    Items = x.Items.Select(c=>new MaterialStock
                    {
                        ItemName = c.Name,
                        Code = c.Code,
                        Article = c.Article,
                        Unit = c.Unit,
                        FinalBalance = c.FinalBalance
                    }).ToList()
                }).ToList()
            });
            return new UploadMaterialIncomingResponse { Success = result };
        } 

        public override async Task<GetAllIncomingsResponse> GetAllIncomings(GetAllIncomingsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all incomings");

            var incomingList = await _incomingService.GetAllIncomingsAsync(request.Filter,request.WarehouseId,request.FromDate,request.ToDate);
            var response = new GetAllIncomingsResponse();
            response.Incoming.AddRange(incomingList.Select(e => new Incoming
            {
                Id = e.Id,
                Stock = new IncomingStock
                {
                    Id = e.StockId,
                    Warehouse = new IncomingWarehouse
                    {
                        Id = e.Stock.Warehouse.Id,
                        Name = e.Stock.Warehouse.Name
                    },
                    Nomenclature = new IncomingNomenclature
                    {
                        Id = e.Stock.Nomenclature.Id,
                        Name = e.Stock.Nomenclature.Name,
                        Code = e.Stock.Nomenclature.Code,
                        UnitOfMeasure = e.Stock.Nomenclature.UnitOfMeasure,
                        Article = e.Stock.Nomenclature.Article
                    },
                    InitialQuantity = (double)e.Stock.InitialQuantity,
                    ReceivedQuantity = (double)e.Stock.ReceivedQuantity,
                    ConsumedQuantity = (double)e.Stock.ConsumedQuantity
                },
                Quantity = (double)e.Quantity,
                Date = e.Date.ToString("o") // ISO 8601 format
            }));

            return response;
        }

        public override async Task<CreateIncomingResponse> CreateIncoming(CreateIncomingRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new incoming");
            var incoming = new RequestManagement.Common.Models.Incoming
            {
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                Date = DateTime.Parse(request.Date)
            };
            var newIncoming = await _incomingService.CreateIncomingAsync(incoming);
            return new CreateIncomingResponse { Id = newIncoming.Id };
        }

        public override async Task<UpdateIncomingResponse> UpdateIncoming(UpdateIncomingRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating incoming with ID: {Id}", request.Id);

            var incoming = new RequestManagement.Common.Models.Incoming
            {
                Id = request.Id,
                StockId = request.StockId,
                Quantity = (decimal)request.Quantity,
                Date = DateTime.Parse(request.Date)
            };
            var success = await _incomingService.UpdateIncomingAsync(incoming);
            return new UpdateIncomingResponse { Success = success };
        }

        public override async Task<DeleteIncomingResponse> DeleteIncoming(DeleteIncomingRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting incoming with ID: {Id}", request.Id);

            var success = await _incomingService.DeleteIncomingAsync(request.Id);
            return new DeleteIncomingResponse { Success = success };
        }
        public override async Task<DeleteIncomingResponse> DeleteIncomings(DeleteIncomingsRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting incoming with IDs : {Id}", request.Id.ToList());

            var success = await _incomingService.DeleteIncomingsAsync(request.Id.ToList());
            return new DeleteIncomingResponse { Success = success };
        }
    }
}


//NomenclatureAnalogController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;

namespace RequestManagement.Server.Controllers
{
    public class NomenclatureAnalogController(INomenclatureAnalogService nomenclatureAnalogService, ILogger<RequestController> logger)
        : NomenclatureAnalogService.NomenclatureAnalogServiceBase
    {
        public override async Task<GetAllNomenclatureAnalogsResponse> GetAllNomenclatureAnalogs(GetAllNomenclatureAnalogsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all nomenclatureAnalog by filter");

            var nomenclatureAnalogList = await nomenclatureAnalogService.GetAllNomenclatureAnalogsAsync(request.Id);
            var response = new GetAllNomenclatureAnalogsResponse();
            response.Nomenclature.AddRange(nomenclatureAnalogList.Select(e => new AnalogNomenclature
            {
                Id = e.Id,
                Name = e.Name,
                Article = e.Article,
                Code = e.Code,
                UnitOfMeasure = e.UnitOfMeasure
            }));
            return response;
        }
        public override async Task<AddNomenclatureAnalogResponse> AddNomenclatureAnalog(AddNomenclatureAnalogRequest request, ServerCallContext context)
        {
            logger.LogInformation("Creating new nomenclatureAnalog");

            var nomenclatureAnalog = new Common.Models.NomenclatureAnalog
            {
                AnalogId = request.Analog,
                OriginalId = request.Original
            };

            var id = await nomenclatureAnalogService.AddNomenclatureAnalogAsync(nomenclatureAnalog);
            return new AddNomenclatureAnalogResponse { Id = id };
        }
        public override async Task<DeleteNomenclatureAnalogResponse> DeleteNomenclatureAnalog(DeleteNomenclatureAnalogRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting nomenclatureAnalog with ID: {Id}", request.Analog);

            var success = await nomenclatureAnalogService.DeleteNomenclatureAnalogAsync(request.Original, request.Analog);
            return new DeleteNomenclatureAnalogResponse { Success = success };
        }
    }
}


//RequestController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;

namespace RequestManagement.Server.Controllers
{
    /// <summary>
    /// gRPC-контроллер для работы с оборудованием
    /// </summary>
    public class RequestController(IRequestService requestService, ILogger<RequestController> logger)
        : RequestService.RequestServiceBase
    {
        private readonly IRequestService _requestService = requestService ?? throw new ArgumentNullException(nameof(requestService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        /// <summary>
        /// Получает список всех единиц оборудования
        /// </summary>
        public override async Task<GetAllEquipmentResponse> GetAllEquipment(GetAllEquipmentRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (!user.Identity.IsAuthenticated)
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all equipment");

            var equipmentList = await _requestService.GetAllEquipmentAsync(request.Filter);
            var response = new GetAllEquipmentResponse();
            response.Equipment.AddRange(equipmentList.Select(e => new Equipment
            {
                Id = e.Id,
                Name = e.Name,
                LicensePlate = e.StateNumber ?? ""
            }));

            return response;
        }

        /// <summary>
        /// Создает новую единицу оборудования
        /// </summary>
        public override async Task<CreateEquipmentResponse> CreateEquipment(CreateEquipmentRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new equipment with name: {Name}", request.Name);

            var equipment = new RequestManagement.Common.Models.Equipment
            {
                Name = request.Name,
                StateNumber = request.LicensePlate
            };

            var id = await _requestService.CreateEquipmentAsync(equipment);
            return new CreateEquipmentResponse { Id = id };
        }

        /// <summary>
        /// Обновляет существующую единицу оборудования
        /// </summary>
        public override async Task<UpdateEquipmentResponse> UpdateEquipment(UpdateEquipmentRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating equipment with ID: {Id}", request.Id);

            var equipment = new RequestManagement.Common.Models.Equipment
            {
                Id = request.Id,
                Name = request.Name,
                StateNumber = request.LicensePlate
            };

            var success = await _requestService.UpdateEquipmentAsync(equipment);
            return new UpdateEquipmentResponse { Success = success };
        }

        /// <summary>
        /// Удаляет единицу оборудования
        /// </summary>
        public override async Task<DeleteEquipmentResponse> DeleteEquipment(DeleteEquipmentRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting equipment with ID: {Id}", request.Id);

            var success = await _requestService.DeleteEquipmentAsync(request.Id);
            return new DeleteEquipmentResponse { Success = success };
        }

        public override async Task<GetAllDriversResponse> GetAllDrivers(GetAllDriversRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all drivers by filter");

            var equipmentList = await _requestService.GetAllDriversAsync(request.Filter);
            var response = new GetAllDriversResponse();
            response.Drivers.AddRange(equipmentList.Select(e => new Driver
            {
                Id = e.Id,
                FullName = e.FullName,
                ShortName = e.ShortName,
                Position = e.Position
            }));

            return response;
        }

        public override async Task<CreateDriverResponse> CreateDriver(CreateDriverRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new driver with full name and position: {Name} - {Position}", request.Driver.FullName, request.Driver.Position);

            var driver = new RequestManagement.Common.Models.Driver
            {
                FullName = request.Driver.FullName,
                ShortName = request.Driver.ShortName,
                Position = request.Driver.Position
            };

            var id = await _requestService.CreateDriverAsync(driver);
            return new CreateDriverResponse { Id = id };
        }

        public override async Task<UpdateDriverResponse> UpdateDriver(UpdateDriverRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating driver with ID: {Id}", request.Driver.Id);

            var driver = new RequestManagement.Common.Models.Driver
            {
                Id = request.Driver.Id,
                FullName = request.Driver.FullName,
                ShortName = request.Driver.ShortName,
                Position = request.Driver.Position
            };

            var success = await _requestService.UpdateDriverAsync(driver);
            return new UpdateDriverResponse { Success = success };
        }

        public override async Task<DeleteDriverResponse> DeleteDriver(DeleteDriverRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting driver with ID: {Id}", request.Id);

            var success = await _requestService.DeleteDriverAsync(request.Id);
            return new DeleteDriverResponse { Success = success };
        }

        public override async Task<GetAllDefectGroupsResponse> GetAllDefectGroups(GetAllDefectGroupsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all drivers by filter");

            var defectGroupList = await _requestService.GetAllDefectGroupsAsync(request.Filter);
            var response = new GetAllDefectGroupsResponse();
            response.DefectGroup.AddRange(defectGroupList.Select(e => new DefectGroup
            {
                Id = e.Id,
                Name = e.Name,
            }));

            return response;
        }
        public override async Task<CreateDefectGroupResponse> CreateDefectGroup(CreateDefectGroupRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new defectGroup with full name: {Name}", request.DefectGroup.Name);

            var defectGroup = new Common.Models.DefectGroup
            {
                Name = request.DefectGroup.Name,
            };

            var id = await _requestService.CreateDefectGroupAsync(defectGroup);
            return new CreateDefectGroupResponse { Id = id };
        }
        public override async Task<UpdateDefectGroupResponse> UpdateDefectGroup(UpdateDefectGroupRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating defectGroup with ID: {Id}", request.DefectGroup.Id);

            var defectGroup = new Common.Models.DefectGroup
            {
                Id = request.DefectGroup.Id,
                Name = request.DefectGroup.Name,
            };

            var success = await _requestService.UpdateDefectGroupAsync(defectGroup);
            return new UpdateDefectGroupResponse { Success = success };
        }
        public override async Task<DeleteDefectGroupResponse> DeleteDefectGroup(DeleteDefectGroupRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting defectGroup with ID: {Id}", request.Id);

            var success = await _requestService.DeleteDefectGroupAsync(request.Id);
            return new DeleteDefectGroupResponse { Success = success };
        }

        public override async Task<GetAllDefectsResponse> GetAllDefects(GetAllDefectsRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all defects by filter");

            var defectList = await _requestService.GetAllDefectsAsync(request.Filter);
            var response = new GetAllDefectsResponse();
            response.Defect.AddRange(defectList.Select(e => new Defect
            {
                Id = e.Id,
                Name = e.Name,
                DefectGroupId = e.DefectGroupId
            }));

            return response;
        }

        public override async Task<CreateDefectResponse> CreateDefect(CreateDefectRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new defect with name: {Name}", request.Defect.Name);

            var defect = new Common.Models.Defect
            {
                Name = request.Defect.Name,
                DefectGroupId = request.Defect.DefectGroupId
            };

            var id = await _requestService.CreateDefectAsync(defect);
            return new CreateDefectResponse { Id = id };
        }
        public override async Task<UpdateDefectResponse> UpdateDefect(UpdateDefectRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating defect with ID: {Id}", request.Defect.Id);

            var defect = new Common.Models.Defect
            {
                Id = request.Defect.Id,
                Name = request.Defect.Name,
                DefectGroupId = request.Defect.DefectGroupId
            };

            var success = await _requestService.UpdateDefectAsync(defect);
            return new UpdateDefectResponse { Success = success };
        }

        public override async Task<DeleteDefectResponse> DeleteDefect(DeleteDefectRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Deleting defect with ID: {Id}", request.Id);

            var success = await _requestService.DeleteDefectAsync(request.Id);
            return new DeleteDefectResponse { Success = success };
        }

        public override async Task<GetAllNomenclaturesResponse> GetAllNomenclatures(GetAllNomenclaturesRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all nomenclatures by filter");

            var nomenclatureList = await requestService.GetAllNomenclaturesAsync(request.Filter);
            var response = new GetAllNomenclaturesResponse();
            response.Nomenclature.AddRange(nomenclatureList.Select(e => new Nomenclature
            {
                Id = e.Id,
                Name = e.Name,
                Code = e.Code,
                UnitOfMeasure = e.UnitOfMeasure,
                Article = e.Article
            }));

            return response;
        }
        public override async Task<CreateNomenclatureResponse> CreateNomenclature(CreateNomenclatureRequest request, ServerCallContext context)
        {
            logger.LogInformation("Creating new nomenclature with name: {Name}", request.Nomenclature.Name);

            var nomenclature = new RequestManagement.Common.Models.Nomenclature
            {
                Name = request.Nomenclature.Name,
                Code = request.Nomenclature.Code,
                UnitOfMeasure = request.Nomenclature.UnitOfMeasure,
                Article = request.Nomenclature.Article
            };

            var id = await requestService.CreateNomenclatureAsync(nomenclature);
            return new CreateNomenclatureResponse { Id = id };
        }

        public override async Task<UpdateNomenclatureResponse> UpdateNomenclature(UpdateNomenclatureRequest request, ServerCallContext context)
        {
            logger.LogInformation("Updating nomenclature with ID: {Id}", request.Nomenclature.Id);

            var nomenclature = new RequestManagement.Common.Models.Nomenclature
            {
                Id = request.Nomenclature.Id,
                Name = request.Nomenclature.Name,
                Code = request.Nomenclature.Code,
                UnitOfMeasure = request.Nomenclature.UnitOfMeasure,
                Article = request.Nomenclature.Article
            };

            var success = await requestService.UpdateNomenclatureAsync(nomenclature);
            return new UpdateNomenclatureResponse { Success = success };
        }

        public override async Task<DeleteNomenclatureResponse> DeleteNomenclature(DeleteNomenclatureRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting nomenclature with ID: {Id}", request.Id);

            var success = await requestService.DeleteNomenclatureAsync(request.Id);
            return new DeleteNomenclatureResponse { Success = success };
        }
    }
}

//StockController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;
using WpfClient.Models;

namespace RequestManagement.Server.Controllers
{
    public class StockController(IStockService requestService, ILogger<RequestController> logger) : StockService.StockServiceBase
    {
        private readonly IStockService _requestService = requestService ?? throw new ArgumentNullException(nameof(requestService));
        private readonly ILogger<RequestController> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        public override async Task<UploadMaterialStockResponse> UploadMaterialStock(UploadMaterialStockRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Upload Materials to stock");
            var materialList = request.Materials.Select(e => new MaterialStock { ItemName = e.Name, Code = e.Code,Article = e.Article,Unit = e.Unit,FinalBalance = e.FinalBalance}).ToList();
            var result = await _requestService.UploadMaterialsStockAsync(materialList, request.WarehouseId, DateTime.Parse(request.Date));
            return new UploadMaterialStockResponse{ Success = result };
        }

        public override async Task<GetAllStocksResponse> GetAllStock(GetAllStocksRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            _logger.LogInformation("Getting all stock");

            var stockList = await _requestService.GetAllStocksAsync(
                request.WarehouseId, 
                request.Filter,
                request.InitialQuantityFilterType,
                request.InitialQuantity,
                request.ReceivedQuantityFilterType,
                request.ReceivedQuantity,
                request.ConsumedQuantityFilterType,
                request.ConsumedQuantity,
                request.FinalQuantityFilterType,
                request.FinalQuantity
                );
            var response = new GetAllStocksResponse();
            response.Stocks.AddRange(stockList.Select(e => new Stock
            {
                Id = e.Id,
                WarehouseId = e.WarehouseId,
                NomenclatureId = e.NomenclatureId,
                InitialQuantity = (double)e.InitialQuantity,
                ReceivedQuantity = (double)e.ReceivedQuantity,
                ConsumedQuantity = (double)e.ConsumedQuantity,
                Nomenclature = new StockNomenclature{Code = e.Nomenclature.Code,Article = e.Nomenclature.Article, Name = e.Nomenclature.Name, UnitOfMeasure = e.Nomenclature.UnitOfMeasure},
            }));

            return response;
        }
        public override async Task<CreateStockResponse> CreateStock(CreateStockRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Creating new stock");

            var stock = new Common.Models.Stock
            {
                WarehouseId = request.WarehouseId,
                NomenclatureId = request.NomenclatureId,
                InitialQuantity = (decimal)request.InitialQuantity
            };
            var id = await _requestService.CreateStockAsync(stock);
            return new CreateStockResponse { Id = id };
        }

        public override async Task<UpdateStockResponse> UpdateStock(UpdateStockRequest request, ServerCallContext context)
        {
            _logger.LogInformation("Updating stock");
            var stock = new RequestManagement.Common.Models.Stock
            {
                Id = request.Id,
                NomenclatureId = request.NomenclatureId,
                InitialQuantity = (decimal)request.InitialQuantity
            };
            var success = await requestService.UpdateStockAsync(stock);
            return new UpdateStockResponse { Success = success };
        }

        public override async Task<DeleteStockResponse> DeleteStock(DeleteStockRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting stock with ID: {Id}", request.Id);
            var success = await requestService.DeleteStockAsync(request.Id);
            return new DeleteStockResponse { Success = success };
        }
    }
}


//WarehouseController.cs
using Grpc.Core;
using RequestManagement.Common.Interfaces;

namespace RequestManagement.Server.Controllers
{
    public class WarehouseController(IWarehouseService warehouseService, ILogger<RequestController> logger)
        : WarehouseService.WarehouseServiceBase
    {
        public override async Task<GetAllWarehousesResponse> GetAllWarehouses(GetAllWarehousesRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all warehouses by filter");

            var warehouseList = await warehouseService.GetAllWarehousesAsync(request.Filter);
            var response = new GetAllWarehousesResponse();
            response.Warehouse.AddRange(warehouseList.Select(e => new Warehouse
            {
                Id = e.Id,
                Name = e.Name,
                LastUpdated = e.LastUpdated.ToString("o")
            }));

            return response;
        }

        public override async Task<GetOrCreateWarehouseResponse> GetOrCreateWarehouse(
            GetOrCreateWarehouseRequest request, ServerCallContext context)
        {
            var user = context.GetHttpContext().User;
            if (user.Identity is { IsAuthenticated: false })
            {
                throw new RpcException(new Status(StatusCode.Unauthenticated, "User is not authenticated"));
            }

            logger.LogInformation("Getting all warehouses by filter");
            var warehouse = await warehouseService.GetOrCreateWarehousesAsync(request.Filter);
            var response = new GetOrCreateWarehouseResponse
            {
                Warehouse = new Warehouse { Id = warehouse.Id, Name = warehouse.Name, LastUpdated = warehouse.LastUpdated.ToString("o") }
            };
            return response;
        }

        public override async Task<CreateWarehouseResponse> CreateWarehouse(CreateWarehouseRequest request, ServerCallContext context)
        {
            logger.LogInformation("Creating new warehouse with name: {Name}", request.Warehouse.Name);

            var warehouse = new RequestManagement.Common.Models.Warehouse
            {
                Name = request.Warehouse.Name,
                LastUpdated = DateTime.Parse(request.Warehouse.LastUpdated)
            };

            var id = await warehouseService.CreateWarehouseAsync(warehouse);
            return new CreateWarehouseResponse { Id = id };
        }

        public override async Task<UpdateWarehouseResponse> UpdateWarehouse(UpdateWarehouseRequest request, ServerCallContext context)
        {
            logger.LogInformation("Updating warehouse with ID: {Id}", request.Warehouse.Id);

            var warehouse = new RequestManagement.Common.Models.Warehouse
            {
                Id = request.Warehouse.Id,
                Name = request.Warehouse.Name,
                LastUpdated = DateTime.Parse(request.Warehouse.LastUpdated)
            };

            var success = await warehouseService.UpdateWarehouseAsync(warehouse);
            return new UpdateWarehouseResponse { Success = success };
        }

        public override async Task<DeleteWarehouseResponse> DeleteWarehouse(DeleteWarehouseRequest request, ServerCallContext context)
        {
            logger.LogInformation("Deleting warehouse with ID: {Id}", request.Id);

            var success = await warehouseService.DeleteWarehouseAsync(request.Id);
            return new DeleteWarehouseResponse { Success = success };
        }
    }
}


//ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        // DbSets с правильным именованием (множественное число)
        public DbSet<User> Users { get; set; }
        public DbSet<Equipment> Equipments { get; set; }
        public DbSet<Warehouse> Warehouses { get; set; }
        public DbSet<Nomenclature> Nomenclatures { get; set; }
        public DbSet<DefectGroup> DefectGroups { get; set; }
        public DbSet<Defect> Defects { get; set; }
        public DbSet<Driver> Drivers { get; set; }
        public DbSet<Stock> Stocks { get; set; }
        public DbSet<Expense> Expenses { get; set; }
        public DbSet<Incoming> Incomings { get; set; }
        public DbSet<UserLastSelection> UserLastSelections { get; set; }
        public DbSet<NomenclatureDefectMapping> NomenclatureDefectMappings { get; set; }
        public DbSet<Commissions> Commissions { get; set; }
        public DbSet<NomenclatureAnalog> NomenclatureAnalogs { get; set; }
        public DbSet<Application> Applications { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            ConfigureUser(modelBuilder);
            ConfigureEquipment(modelBuilder);
            ConfigureWarehouse(modelBuilder);
            ConfigureNomenclature(modelBuilder);
            ConfigureDefectGroup(modelBuilder);
            ConfigureDefect(modelBuilder);
            ConfigureDriver(modelBuilder);
            ConfigureStock(modelBuilder);
            ConfigureExpense(modelBuilder);
            ConfigureIncoming(modelBuilder);
            ConfigureUserLastSelection(modelBuilder);
            ConfigureNomenclatureDefectMapping(modelBuilder);
            ConfigureCommissions(modelBuilder);
            ConfigureNomenclatureAnalog(modelBuilder);
            ConfigureApplication(modelBuilder);
            SeedInitialData(modelBuilder);
        }

        private void ConfigureUser(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<User>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Login)
                    .IsRequired()
                    .HasMaxLength(50);
                entity.Property(e => e.Password)
                    .IsRequired()
                    .HasMaxLength(256);
                entity.HasIndex(e => e.Login)
                    .IsUnique();
            });
        }

        private void ConfigureEquipment(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Equipment>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.Property(e => e.StateNumber)
                    .HasMaxLength(20);
                entity.Property(e => e.Code)
                    .IsRequired()
                    .HasMaxLength(50);
                entity.HasIndex(e => e.Code);
            });
        }

        private void ConfigureWarehouse(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Warehouse>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.Property(e => e.Code)
                    .HasMaxLength(50);
                entity.Property(e => e.LastUpdated)
                    .HasColumnType("timestamp with time zone");
                entity.HasIndex(e => e.Name);
            });
        }

        private void ConfigureNomenclature(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Nomenclature>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Code)
                    .IsRequired()
                    .HasMaxLength(50);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(200);
                entity.Property(e => e.Article)
                    .HasMaxLength(100);
                entity.Property(e => e.UnitOfMeasure)
                    .IsRequired()
                    .HasMaxLength(20);
                entity.HasIndex(e => e.Code);
            });
        }

        private void ConfigureDefectGroup(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<DefectGroup>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.HasMany(e => e.Defects)
                    .WithOne(d => d.DefectGroup)
                    .HasForeignKey(d => d.DefectGroupId)
                    .OnDelete(DeleteBehavior.Cascade);
            });
        }

        private void ConfigureDefect(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Defect>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.HasIndex(e => e.Name);
            });
        }

        private void ConfigureDriver(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Driver>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.FullName)
                    .IsRequired()
                    .HasMaxLength(150);
                entity.Property(e => e.ShortName)
                    .IsRequired()
                    .HasMaxLength(50);
                entity.Property(e => e.Position)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.Property(e => e.Code)
                    .IsRequired()
                    .HasMaxLength(50);
                entity.HasIndex(e => e.Code);
            });
        }

        private void ConfigureStock(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Stock>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.InitialQuantity)
                    .HasColumnType("decimal(18,2)");
                entity.Property(e => e.ReceivedQuantity)
                    .HasColumnType("decimal(18,2)");
                entity.Property(e => e.ConsumedQuantity)
                    .HasColumnType("decimal(18,2)");
                entity.HasOne(e => e.Warehouse)
                    .WithMany(w => w.Stocks)
                    .HasForeignKey(e => e.WarehouseId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Nomenclature)
                    .WithMany(n => n.Stocks)
                    .HasForeignKey(e => e.NomenclatureId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => new { e.WarehouseId, e.NomenclatureId });
            });
        }

        private void ConfigureExpense(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Expense>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Ignore(e => e.IsSelected);
                entity.Property(e => e.Code)
                    .HasMaxLength(50);
                entity.Property(e => e.Quantity)
                    .HasColumnType("decimal(18,2)");
                entity.Property(e => e.Date)
                    .HasColumnType("timestamp with time zone");
                entity.HasOne(e => e.Stock)
                    .WithMany()
                    .HasForeignKey(e => e.StockId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Equipment)
                    .WithMany()
                    .HasForeignKey(e => e.EquipmentId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Driver)
                    .WithMany()
                    .HasForeignKey(e => e.DriverId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Defect)
                    .WithMany()
                    .HasForeignKey(e => e.DefectId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => e.Date);
            });
        }

        private void ConfigureIncoming(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Incoming>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Ignore(e => e.IsSelected);
                entity.Property(e => e.Quantity)
                    .HasColumnType("decimal(18,2)");
                entity.Property(e => e.Date)
                    .HasColumnType("timestamp with time zone");
                entity.Property(e => e.Code)
                    .IsRequired()
                    .HasMaxLength(50);
                entity.HasOne(e => e.Stock)
                    .WithMany()
                    .HasForeignKey(e => e.StockId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Application)
                    .WithMany()
                    .HasForeignKey(e => e.ApplicationId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => e.Date);
            });
        }

        private void ConfigureUserLastSelection(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<UserLastSelection>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.LastUpdated)
                    .HasColumnType("timestamp with time zone");
                entity.HasOne(e => e.User)
                    .WithMany()
                    .HasForeignKey(e => e.UserId)
                    .OnDelete(DeleteBehavior.Cascade);
                entity.HasOne(e => e.Driver)
                    .WithMany()
                    .HasForeignKey(e => e.DriverId)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Equipment)
                    .WithMany()
                    .HasForeignKey(e => e.EquipmentId)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Commissions)
                    .WithMany()
                    .HasForeignKey(e => e.CommissionsId)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => e.UserId);
            });
        }

        private void ConfigureNomenclatureDefectMapping(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<NomenclatureDefectMapping>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.LastUsed)
                    .HasColumnType("timestamp with time zone");
                entity.HasOne(e => e.User)
                    .WithMany()
                    .HasForeignKey(e => e.UserId)
                    .OnDelete(DeleteBehavior.Cascade);
                entity.HasOne(e => e.Nomenclature)
                    .WithMany()
                    .HasForeignKey(e => e.NomenclatureId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Defect)
                    .WithMany()
                    .HasForeignKey(e => e.DefectId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => new { e.UserId, e.NomenclatureId });
            });
        }
        private void ConfigureApplication(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Application>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Number)
                    .IsRequired()
                    .HasMaxLength(50);
                entity.Property(e => e.Date)
                    .HasColumnType("timestamp with time zone");
                entity.HasOne(e => e.Responsible)
                    .WithMany()
                    .HasForeignKey(e => e.ResponsibleId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Equipment)
                    .WithMany()
                    .HasForeignKey(e => e.EquipmentId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => e.Number);
            });
        }
        private void ConfigureCommissions(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Commissions>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name)
                    .IsRequired()
                    .HasMaxLength(100);
                entity.HasOne(e => e.ApproveForAct)
                    .WithMany()
                    .HasForeignKey(e => e.ApproveForActId)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.ApproveForDefectAndLimit)
                    .WithMany()
                    .HasForeignKey(e => e.ApproveForDefectAndLimitId)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Chairman)
                    .WithMany()
                    .HasForeignKey(e => e.ChairmanId)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Member1)
                    .WithMany()
                    .HasForeignKey(e => e.Member1Id)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Member2)
                    .WithMany()
                    .HasForeignKey(e => e.Member2Id)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Member3)
                    .WithMany()
                    .HasForeignKey(e => e.Member3Id)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Member4)
                    .WithMany()
                    .HasForeignKey(e => e.Member4Id)
                    .IsRequired(false)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => e.Name);
            });
        }

        private void ConfigureNomenclatureAnalog(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<NomenclatureAnalog>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.HasOne(e => e.Original)
                    .WithMany()
                    .HasForeignKey(e => e.OriginalId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasOne(e => e.Analog)
                    .WithMany()
                    .HasForeignKey(e => e.AnalogId)
                    .OnDelete(DeleteBehavior.Restrict);
                entity.HasIndex(e => new { e.OriginalId, e.AnalogId });
            });
        }

        private void SeedInitialData(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<User>().HasData(
                new User
                {
                    Id = 1,
                    Login = "admin",
                    Password = "$2a$11$IeKuyvG/5SoDYP0NFz3kouC3CPUIuUa6ShTfgVVf9oUlfqbXq8LrC",
                    Role = UserRole.Administrator
                }
            );

            modelBuilder.Entity<Warehouse>().HasData(
                new Warehouse
                {
                    Id = 1,
                    Name = "Основной склад",
                    LastUpdated = DateTime.SpecifyKind(DateTime.Parse("2025-01-01"), DateTimeKind.Utc)
                },
                new Warehouse
                {
                    Id = 2,
                    Name = "Резервный склад",
                    LastUpdated = DateTime.SpecifyKind(DateTime.Parse("2025-01-01"), DateTimeKind.Utc)
                }
            );

            modelBuilder.Entity<Nomenclature>().HasData(
                new Nomenclature
                {
                    Id = 1,
                    Code = "ТКР001",
                    Name = "Турбокомпрессор ТКР 7С-6 левый КАМАЗ Евро 2",
                    Article = "7406.1118013",
                    UnitOfMeasure = "шт"
                },
                new Nomenclature
                {
                    Id = 2,
                    Code = "АКБ001",
                    Name = "Аккумулятор 6СТ-190",
                    Article = "6СТ-190",
                    UnitOfMeasure = "шт"
                },
                new Nomenclature
                {
                    Id = 3,
                    Code = "АКБ002",
                    Name = "Аккумулятор 6СТ-200 (аналог 6СТ-190)",
                    Article = "6СТ-200",
                    UnitOfMeasure = "шт"
                }
            );

            modelBuilder.Entity<Stock>().HasData(
                new Stock
                {
                    Id = 1,
                    NomenclatureId = 1,
                    WarehouseId = 1,
                    InitialQuantity = 70,
                    ReceivedQuantity = 0,
                    ConsumedQuantity = 0
                },
                new Stock
                {
                    Id = 2,
                    NomenclatureId = 2,
                    WarehouseId = 1,
                    InitialQuantity = 10,
                    ReceivedQuantity = 0,
                    ConsumedQuantity = 0
                },
                new Stock
                {
                    Id = 3,
                    NomenclatureId = 1,
                    WarehouseId = 2,
                    InitialQuantity = 40,
                    ReceivedQuantity = 0,
                    ConsumedQuantity = 0
                },
                new Stock
                {
                    Id = 4,
                    NomenclatureId = 2,
                    WarehouseId = 2,
                    InitialQuantity = 20,
                    ReceivedQuantity = 0,
                    ConsumedQuantity = 0
                }
            );

            modelBuilder.Entity<Driver>().HasData(
                new Driver
                {
                    Id = 1,
                    FullName = "Иванов Иван Иванович",
                    ShortName = "Иванов И.И.",
                    Position = "Водитель",
                    Code = "DRV001"
                },
                new Driver
                {
                    Id = 2,
                    FullName = "Петров Петр Петрович",
                    ShortName = "Петров П.П.",
                    Position = "Водитель",
                    Code = "DRV002"
                }
            );

            modelBuilder.Entity<Commissions>().HasData(
                new Commissions
                {
                    Id = 1,
                    Name = "Магический филиал",
                    ApproveForActId = 1,
                    ApproveForDefectAndLimitId = 1,
                    ChairmanId = 1,
                    Member1Id = 1,
                    Member2Id = 1,
                    Member3Id = 1,
                    Member4Id = 1
                }
            );

            modelBuilder.Entity<Equipment>().HasData(
                new Equipment
                {
                    Id = 1,
                    Name = "КАМАЗ 53215-15",
                    StateNumber = "Н 507 СН",
                    Code = "EQP001"
                }
            );

            modelBuilder.Entity<DefectGroup>().HasData(
                new DefectGroup { Id = 1, Name = "Механические повреждения" },
                new DefectGroup { Id = 2, Name = "Электрические неисправности" }
            );

            modelBuilder.Entity<Defect>().HasData(
                new Defect { Id = 1, Name = "Трещина корпуса", DefectGroupId = 1 },
                new Defect { Id = 2, Name = "Короткое замыкание", DefectGroupId = 2 }
            );

            modelBuilder.Entity<Expense>().HasData(
                new Expense
                {
                    Id = 1,
                    StockId = 1,
                    Quantity = 5,
                    EquipmentId = 1,
                    DriverId = 1,
                    DefectId = 1,
                    Date = DateTime.SpecifyKind(DateTime.Parse("2025-04-12"), DateTimeKind.Utc),
                    Code = "EXP001"
                }
            );

            // Добавляем начальные данные для Application
            modelBuilder.Entity<Application>().HasData(
                new Application
                {
                    Id = 1,
                    Number = "APP001",
                    Date = DateTime.SpecifyKind(DateTime.Parse("2025-04-10"), DateTimeKind.Utc),
                    ResponsibleId = 1, // Ссылаемся на Driver с Id = 1
                    EquipmentId = 1    // Ссылаемся на Equipment с Id = 1
                }
            );

            modelBuilder.Entity<Incoming>().HasData(
                new Incoming
                {
                    Id = 1,
                    StockId = 1,
                    Quantity = 5,
                    Date = DateTime.SpecifyKind(DateTime.Parse("2025-04-15"), DateTimeKind.Utc),
                    Code = "INC001",
                    ApplicationId = 1 // Теперь ссылается на существующую запись в Application
                }
            );
        }
    }
}

//auth.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

package auth;

// Сервис аутентификации
service AuthService {
    rpc Authenticate (AuthenticateRequest) returns (AuthenticateResponse);
    rpc Authorize (AuthorizeRequest) returns (AuthorizeResponse);
}

// Сообщения для запросов и ответов

// Запрос на аутентификацию
message AuthenticateRequest {
    string login = 1;         // Логин пользователя
    string password = 2;      // Пароль пользователя
}

// Ответ на аутентификацию
message AuthenticateResponse {
    int32 user_id = 1;        // ID пользователя (0, если аутентификация не удалась)
    string login = 2;         // Логин пользователя
    int32 role = 3;           // Роль пользователя (enum UserRole)
    string token = 4;         // JWT-токен для дальнейших запросов
}

// Запрос на проверку прав доступа
message AuthorizeRequest {
    int32 user_id = 1;        // ID пользователя
    int32 required_role = 2;  // Требуемая роль (enum UserRole)
}

// Ответ на проверку прав доступа
message AuthorizeResponse {
    bool is_authorized = 1;   // Признак наличия прав
}

//commissions.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service CommissionsService {
    rpc GetAllCommissions (GetAllCommissionsRequest) returns (GetAllCommissionsResponse);
    rpc CreateCommissions(CreateCommissionsRequest) returns (CreateCommissionsResponse);
    rpc UpdateCommissions (UpdateCommissionsRequest) returns (UpdateCommissionsResponse);
    rpc DeleteCommissions (DeleteCommissionsRequest) returns (DeleteCommissionsResponse);
}

message Commissions {
    int32 id = 1;
    string name = 2;
    CommissionsDriver approve_act = 3;
    CommissionsDriver approve_defect_and_limit = 4;
    CommissionsDriver chairman = 5;
    CommissionsDriver member1 = 6;
    CommissionsDriver member2 = 7;
    CommissionsDriver member3 = 8;
    CommissionsDriver member4 = 9;
}

message CommissionsDriver{
    int32 id = 1;
    string full_name = 2;  
    string short_name = 3; 
    string position = 4; 
}

message GetAllCommissionsRequest {
	string filter = 1;
}

message GetAllCommissionsResponse {
    repeated Commissions commissions = 1;
}

message CreateCommissionsRequest {
    string name = 1;
    int32 approve_act_id = 2;
    int32 approve_defect_and_limit_id = 3;
    int32 chairman_id = 4;
    int32 member1_id = 5;
    int32 member2_id = 6;
    int32 member3_id = 7;
    int32 member4_id = 8;
}

message CreateCommissionsResponse {
	int32 id = 1;
}

message UpdateCommissionsRequest {
	int32 id = 1;
	string name = 2;
	int32 approve_act_id = 3;
    int32 approve_defect_and_limit_id = 4;
	int32 chairman_id = 5;
	int32 member1_id = 6;
	int32 member2_id = 7;
	int32 member3_id = 8;
	int32 member4_id = 9;
}

message UpdateCommissionsResponse {
	bool success = 1;
}

message DeleteCommissionsRequest {
	int32 id = 1;
}

message DeleteCommissionsResponse {
	bool success = 1;
}

//expense.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service ExpenseService {
  rpc GetAllExpenses (GetAllExpensesRequest) returns (GetAllExpensesResponse);
  rpc CreateExpense (CreateExpenseRequest) returns (CreateExpenseResponse);
  rpc UpdateExpense (UpdateExpenseRequest) returns (UpdateExpenseResponse);
  rpc DeleteExpense (DeleteExpenseRequest) returns (DeleteExpenseResponse);
  rpc DeleteExpenses (DeleteExpensesRequest) returns (DeleteExpenseResponse);
  rpc GetLastSelection (GetLastSelectionRequest) returns (GetLastSelectionResponse);
  rpc GetNomenclatureMaping (GetNomenclatureMapingRequest) returns (GetNomenclatureMapingResponse);
  rpc UploadMaterialExpense (UploadMaterialExpenseRequest) returns (UploadMaterialExpenseResponse);
}

message MaterialExpense {
    string number = 1;
    string date = 2;
    string driver_full_name = 3;
    string driver_code = 4;
    string equipment_name = 5;
    string equipment_code = 6;
    string nomenclature_name = 7;
    string nomenclature_code = 8;
    string nomenclature_article = 9;
    string nomenlature_unit_of_measure = 10;
    double quantity = 11;
}

message UploadMaterialExpenseRequest{
	repeated MaterialExpense materialExpenses = 1;
    int32 warehouseId = 2;
}

message UploadMaterialExpenseResponse{
	bool success = 1;
}

message GetAllExpensesRequest {
  string filter = 1;
  int32 warehouse_id = 2;
  int32 equipment_id = 3;
  int32 driver_id = 4;
  int32 defect_id = 5;
  string from_date = 6;
  string to_date = 7;
}

message GetAllExpensesResponse {
  repeated Expense expenses = 1;
}

message Expense {
  int32 id = 1;
  ExpenseStock stock = 2;
  double quantity = 3;
  ExpenseEquipment equipment = 4;
  ExpenseDriver driver = 5;
  ExpenseDefect defect = 6;
  string date = 7;
  string code = 8;
}

message ExpenseDefectGroup {
    int32 id = 1;
    string name = 2;   
}

message ExpenseDefect {
    int32 id = 1;
    string name = 2;
    ExpenseDefectGroup defectGroup = 3;
}

message ExpenseDriver {
    int32 id = 1;
    string full_name = 2;
    string short_name = 3; 
    string position = 4;
    string code = 5;
}

message ExpenseEquipment {
    int32 id = 1;
    string name = 2;
    string license_plate = 3;
    string code = 4;
}

message ExpenseWarehouse {
    int32 id = 1;
    string name = 2;
}

message ExpenseStock {
    int32 id = 1;
    ExpenseWarehouse warehouse = 2;
    double initial_quantity = 3;
    double received_quantity = 4;
    double consumed_quantity = 5;
    ExpenseNomenclature nomenclature = 6;
}

message ExpenseNomenclature {
    int32 id = 1;
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

message CreateExpenseRequest {
  int32 stock_id = 1;
  double quantity = 2;
  int32 equipment_id = 3;
  int32 driver_id = 4;
  int32 defect_id = 5;
  string date = 6;
}

message CreateExpenseResponse {
  int32 id = 1;
}

message UpdateExpenseRequest {
  int32 id = 1;
  int32 stock_id = 2;
  double quantity = 3;
  int32 equipment_id = 4;
  int32 driver_id = 5;
  int32 defect_id = 6;
  string date = 7;
}

message UpdateExpenseResponse {
  bool success = 1;
}

message DeleteExpenseRequest {
  int32 id = 1;
}

message DeleteExpensesRequest {
  repeated int32 id = 1;
}

message DeleteExpenseResponse {
  bool success = 1;
}

message GetLastSelectionResponse {
  ExpenseDriver driver = 1;
  ExpenseEquipment equipment = 2;
  ExpenseDefect defect = 3;
}

message GetLastSelectionRequest {
  int32 nomenclature_id = 1;
}

message GetNomenclatureMapingRequest {
  int32 nomenclature_id = 1;
}

message GetNomenclatureMapingResponse {
  ExpenseDefect defect = 1;
}

//incoming.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service IncomingService {
  rpc GetAllIncomings (GetAllIncomingsRequest) returns (GetAllIncomingsResponse);
  rpc CreateIncoming (CreateIncomingRequest) returns (CreateIncomingResponse);
  rpc UpdateIncoming (UpdateIncomingRequest) returns (UpdateIncomingResponse);
  rpc DeleteIncoming (DeleteIncomingRequest) returns (DeleteIncomingResponse);
  rpc DeleteIncomings (DeleteIncomingsRequest) returns (DeleteIncomingResponse);
  rpc UploadMaterialIncoming(UploadMaterialIncomingRequest) returns (UploadMaterialIncomingResponse);
}

message UploadMaterialIncomingRequest {
    string warehouse_name= 1;
    repeated IncomingMaterialItem items = 2;
}

message UploadMaterialIncomingResponse {
  bool success = 1;
}


message IncomingMaterialItem{
    string registrator_type = 1;
    string registrator_number = 2;
    string registrator_date = 3;
    string receipt_order_number = 4;
    string receipt_order_date = 5;
    string application_number = 6;
    string application_date = 7;
    string application_responsible_name = 8;
    string application_equipment_name = 9;
    string application_equipment_code = 10;
    repeated IncomingMaterialStockMessage items = 11;
}

message IncomingMaterialStockMessage {
    string name = 1;
    string code = 2;
    string article = 3;
    string unit = 4;
    double finalBalance = 5;
}

message GetAllIncomingsRequest {
  string filter = 1;
  int32 warehouse_id = 2;
  string from_date = 3;
  string to_date = 4;
}

message GetAllIncomingsResponse {
  repeated Incoming incoming = 1;
}

message CreateIncomingRequest {
  int32 stock_id = 1;
  double quantity = 2;
  string date = 3;
}

message CreateIncomingResponse {
  int32 id = 1;
}

message UpdateIncomingRequest {
  int32 id = 1;
  int32 stock_id = 2;
  double quantity = 3;
  string date = 4;
}

message UpdateIncomingResponse {
  bool success = 1;
}

message DeleteIncomingRequest {
  int32 id = 1;
}

message DeleteIncomingsRequest {
  repeated int32 id = 1;
}

message DeleteIncomingResponse {
  bool success = 1;
}

message Incoming {
  int32 id = 1;
  IncomingStock stock = 2;
  double quantity = 3;
  string date = 4;
}

message IncomingWarehouse {
    int32 id = 1;
    string name = 2;
}

message IncomingStock {
    int32 id = 1;
    IncomingWarehouse warehouse = 2;
    double initial_quantity = 3;
    double received_quantity = 4;
    double consumed_quantity = 5;
    IncomingNomenclature nomenclature = 6;
}

message IncomingNomenclature {
    int32 id = 1;
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

//nomenclatureanalog.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service NomenclatureAnalogService {
    rpc GetAllNomenclatureAnalogs (GetAllNomenclatureAnalogsRequest) returns (GetAllNomenclatureAnalogsResponse);
    rpc AddNomenclatureAnalog(AddNomenclatureAnalogRequest) returns (AddNomenclatureAnalogResponse);
    rpc DeleteNomenclatureAnalog(DeleteNomenclatureAnalogRequest) returns (DeleteNomenclatureAnalogResponse);
}

message DeleteNomenclatureAnalogRequest {
	int32 original = 1;
    int32 analog = 2;
}

message DeleteNomenclatureAnalogResponse {
	bool success = 1;
}

message GetAllNomenclatureAnalogsRequest {
	int32 id = 1;
}

message GetAllNomenclatureAnalogsResponse {
	repeated AnalogNomenclature nomenclature = 1;
}

message AddNomenclatureAnalogRequest{
	int32 original = 1;
    int32 analog = 2;
}

message AddNomenclatureAnalogResponse{
	int32 id = 1;
}

message AnalogNomenclature {
    int32 id = 1;
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

//request.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service RequestService {
    rpc GetAllEquipment (GetAllEquipmentRequest) returns (GetAllEquipmentResponse);
    rpc CreateEquipment (CreateEquipmentRequest) returns (CreateEquipmentResponse);
    rpc UpdateEquipment (UpdateEquipmentRequest) returns (UpdateEquipmentResponse);
    rpc DeleteEquipment (DeleteEquipmentRequest) returns (DeleteEquipmentResponse);

    rpc GetAllDrivers (GetAllDriversRequest) returns (GetAllDriversResponse);
    rpc CreateDriver (CreateDriverRequest) returns (CreateDriverResponse);
    rpc UpdateDriver (UpdateDriverRequest) returns (UpdateDriverResponse);
    rpc DeleteDriver (DeleteDriverRequest) returns (DeleteDriverResponse);

    rpc GetAllDefectGroups (GetAllDefectGroupsRequest) returns (GetAllDefectGroupsResponse);
    rpc CreateDefectGroup (CreateDefectGroupRequest) returns (CreateDefectGroupResponse);
    rpc UpdateDefectGroup (UpdateDefectGroupRequest) returns (UpdateDefectGroupResponse);
    rpc DeleteDefectGroup (DeleteDefectGroupRequest) returns (DeleteDefectGroupResponse);

    rpc GetAllDefects (GetAllDefectsRequest) returns (GetAllDefectsResponse);
    rpc CreateDefect(CreateDefectRequest) returns (CreateDefectResponse);
    rpc UpdateDefect (UpdateDefectRequest) returns (UpdateDefectResponse);
    rpc DeleteDefect (DeleteDefectRequest) returns (DeleteDefectResponse);

    rpc GetAllNomenclatures (GetAllNomenclaturesRequest) returns (GetAllNomenclaturesResponse);
    rpc CreateNomenclature(CreateNomenclatureRequest) returns (CreateNomenclatureResponse);
    rpc UpdateNomenclature (UpdateNomenclatureRequest) returns (UpdateNomenclatureResponse);
    rpc DeleteNomenclature (DeleteNomenclatureRequest) returns (DeleteNomenclatureResponse);
}

// Сообщения для оборудования
message GetAllEquipmentRequest {
    string filter = 1;
}

message GetAllEquipmentResponse {
    repeated Equipment equipment = 1;
}

message CreateEquipmentRequest {
    string name = 1;
    string license_plate = 2;
}

message CreateEquipmentResponse {
    int32 id = 1;
}

message UpdateEquipmentRequest {
    int32 id = 1;
    string name = 2;
    string license_plate = 3;
}

message UpdateEquipmentResponse {
    bool success = 1;
}

message DeleteEquipmentRequest {
    int32 id = 1;
}

message DeleteEquipmentResponse {
    bool success = 1;
}

message Equipment {
    int32 id = 1;
    string name = 2;
    string license_plate = 3;
}

message GetAllDriversRequest {
    string filter = 1; // Фильтр для поиска по имени или должности
}

message GetAllDriversResponse {
    repeated Driver drivers = 1;
}

message CreateDriverRequest {
    Driver driver = 1;
}

message CreateDriverResponse {
    int32 id = 1; // ID созданного водителя
}

message UpdateDriverRequest {
    Driver driver = 1;
}

message UpdateDriverResponse {
    bool success = 1;
}

message DeleteDriverRequest {
    int32 id = 1;
}

message DeleteDriverResponse {
    bool success = 1;
}

message Driver {
    int32 id = 1;
    string full_name = 2;   // Полное ФИО
    string short_name = 3;  // Фамилия с инициалами
    string position = 4;    // Должность
}

message GetAllDefectGroupsRequest {
    string filter = 1;
}

message GetAllDefectGroupsResponse {
    repeated DefectGroup defectGroup = 1;
}

message CreateDefectGroupRequest {
    DefectGroup defectGroup = 1;
}

message CreateDefectGroupResponse {
    int32 id = 1;
}

message UpdateDefectGroupRequest {
    DefectGroup defectGroup = 1;
}

message UpdateDefectGroupResponse {
    bool success = 1;
}

message DeleteDefectGroupRequest {
    int32 id = 1;
}

message DeleteDefectGroupResponse {
    bool success = 1;
}

message DefectGroup {
    int32 id = 1;
    string name = 2;   
}

message GetAllDefectsRequest {
    string filter = 1;
}

message GetAllDefectsResponse {
    repeated Defect defect = 1;
}

message CreateDefectRequest {
    Defect defect = 1;
}

message CreateDefectResponse {
    int32 id = 1;
}

message UpdateDefectRequest {
    Defect defect = 1;
}

message UpdateDefectResponse {
    bool success = 1;
}

message DeleteDefectRequest {
    int32 id = 1;
}

message DeleteDefectResponse {
    bool success = 1;
}

message Defect {
    int32 id = 1;
    string name = 2;
    int32 defectGroupId = 3;
}

message GetAllNomenclaturesRequest {
    string filter = 1;
}

message GetAllNomenclaturesResponse {
    repeated Nomenclature nomenclature = 1;
}

message CreateNomenclatureRequest {
    Nomenclature nomenclature = 1;
}

message CreateNomenclatureResponse {
    int32 id = 1;
}

message UpdateNomenclatureRequest {
    Nomenclature nomenclature = 1;
}

message UpdateNomenclatureResponse {
    bool success = 1;
}

message DeleteNomenclatureRequest {
    int32 id = 1;
}

message DeleteNomenclatureResponse {
    bool success = 1;
}

message Nomenclature {
    int32 id = 1;
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

//stock.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service StockService {
    rpc GetAllStock (GetAllStocksRequest) returns (GetAllStocksResponse);
    rpc CreateStock (CreateStockRequest) returns (CreateStockResponse);
    rpc UpdateStock (UpdateStockRequest) returns (UpdateStockResponse);
    rpc DeleteStock (DeleteStockRequest) returns (DeleteStockResponse);
    rpc UploadMaterialStock (UploadMaterialStockRequest) returns (UploadMaterialStockResponse);
}

message GetAllStocksRequest {
    int32 warehouseId = 1;
    string filter = 2;
    int32 initialQuantityFilterType = 3;
    double initialQuantity = 4;
    int32 receivedQuantityFilterType = 5;
    double receivedQuantity = 6;
    int32 consumedQuantityFilterType = 7;
    double consumedQuantity = 8;
    int32 finalQuantityFilterType = 9;
    double finalQuantity = 10;
}

message GetAllStocksResponse {
    repeated Stock stocks = 1;
}

message CreateStockRequest {
    int32 warehouse_id = 1;
    int32 nomenclature_id = 2;
    double initial_quantity = 3;
}

message CreateStockResponse {
    int32 id = 1;
}

message UpdateStockRequest {
    int32 id = 1;
    int32 nomenclature_id = 3;
    double initial_quantity = 4;
}

message UpdateStockResponse {
    bool success = 1;
}

message DeleteStockRequest {
    int32 id = 1;
}

message DeleteStockResponse {
    bool success = 1;
}

message UploadMaterialStockRequest{
    int32 warehouse_id = 1;
    string date = 2;
    repeated MaterialStockMessage materials = 3;
}

message UploadMaterialStockResponse{
     bool success = 1;
}

message Stock {
    int32 id = 1;
    int32 warehouse_id = 2;
    int32 nomenclature_id = 3;
    double initial_quantity = 4;
    double received_quantity = 5;
    double consumed_quantity = 6;
    StockNomenclature nomenclature = 7;
}

message StockNomenclature {
    string code = 2;
    string name = 3;
    string article = 4;
    string unitOfMeasure = 5;
}

message MaterialStockMessage {
    string name = 1;
    string code = 2;
    string article = 3;
    string unit = 4;
    double finalBalance = 5;
}

//warehouse.proto
syntax = "proto3";

option csharp_namespace = "RequestManagement.Server.Controllers";

service WarehouseService {
    rpc GetAllWarehouses (GetAllWarehousesRequest) returns (GetAllWarehousesResponse);
    rpc CreateWarehouse(CreateWarehouseRequest) returns (CreateWarehouseResponse);
    rpc UpdateWarehouse (UpdateWarehouseRequest) returns (UpdateWarehouseResponse);
    rpc DeleteWarehouse (DeleteWarehouseRequest) returns (DeleteWarehouseResponse);
    rpc GetOrCreateWarehouse (GetOrCreateWarehouseRequest) returns (GetOrCreateWarehouseResponse);
}

message GetOrCreateWarehouseRequest{
    string filter = 1;
}

message GetOrCreateWarehouseResponse{
    Warehouse warehouse = 1;
}

message GetAllWarehousesRequest {
    string filter = 1;
}

message GetAllWarehousesResponse {
    repeated Warehouse warehouse = 1;
}

message CreateWarehouseRequest {
    Warehouse warehouse = 1;
}

message CreateWarehouseResponse {
    int32 id = 1;
}

message UpdateWarehouseRequest {
    Warehouse warehouse = 1;
}

message UpdateWarehouseResponse {
    bool success = 1;
}

message DeleteWarehouseRequest {
    int32 id = 1;
}

message DeleteWarehouseResponse {
    bool success = 1;
}

message Warehouse {
    int32 id = 1;
    string name = 2;
    string last_updated = 3;
    string code = 4;
}

//AuthService.cs
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Services
{
    /// <summary>
    /// Сервис авторизации
    /// </summary>
    public class AuthService : IAuthService
    {
        private readonly IUserService _userService;

        public AuthService(IUserService userService)
        {
            _userService = userService ?? throw new ArgumentNullException(nameof(userService));
        }

        /// <summary>
        /// Аутентифицирует пользователя по логину и паролю
        /// </summary>
        public async Task<User> AuthenticateAsync(string login, string password)
        {
            if (string.IsNullOrWhiteSpace(login))
                throw new ArgumentException("Login cannot be null or empty", nameof(login));
            if (string.IsNullOrWhiteSpace(password))
                throw new ArgumentException("Password cannot be null or empty", nameof(password));
            var tmp_pass = BCrypt.Net.BCrypt.HashPassword(password);
            Console.WriteLine(tmp_pass);
            var user = await _userService.GetUserByLoginAsync(login);
            if (user == null || !BCrypt.Net.BCrypt.Verify(password, user.Password))
                return null;

            return user;
        }

        /// <summary>
        /// Проверяет, имеет ли пользователь права на выполнение действия
        /// </summary>
        public async Task<bool> AuthorizeAsync(int userId, UserRole requiredRole)
        {
            return await _userService.HasRoleAsync(userId, requiredRole);
        }
    }
}

//CommissionsService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class CommissionsService(ApplicationDbContext dbContext) : ICommissionsService
    {
        private readonly ApplicationDbContext _dbContext =
            dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        public async Task<List<Commissions>> GetAllCommissionsAsync(string filter = "")
        {
            var query = _dbContext.Commissions.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Commissions
                {
                    Id = e.Id,
                    Name = e.Name,
                    ApproveForAct = e.ApproveForAct,
                    ApproveForDefectAndLimit = e.ApproveForDefectAndLimit,
                    Chairman = e.Chairman,
                    Member1 = e.Member1,
                    Member2 = e.Member2,
                    Member3 = e.Member3,
                    Member4 = e.Member4
                })
                .ToListAsync();
        }

        public async Task<int> CreateCommissionsAsync(Commissions commissions)
        {
            _dbContext.Commissions.Add(commissions);
            await _dbContext.SaveChangesAsync();
            return commissions.Id;
        }

        public async Task<bool> UpdateCommissionsAsync(Commissions commissions)
        {
            try
            {
                var existCommissions = await _dbContext.Commissions
                    .FirstOrDefaultAsync(e => e.Id == commissions.Id);

                if (existCommissions == null)
                    return false;

                existCommissions.Name = commissions.Name;
                existCommissions.ApproveForActId = commissions.ApproveForActId;
                existCommissions.ApproveForDefectAndLimitId = commissions.ApproveForDefectAndLimitId;
                existCommissions.ChairmanId = commissions.ChairmanId;
                existCommissions.Member1Id = commissions.Member1Id;
                existCommissions.Member2Id = commissions.Member2Id;
                existCommissions.Member3Id = commissions.Member3Id;
                existCommissions.Member4Id = commissions.Member4Id;
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
                return false;
            }
        }

        public async Task<bool> DeleteCommissionsAsync(int id)
        {
            try
            {
                var commissions = await _dbContext.Commissions
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (commissions == null)
                    return false;

                _dbContext.Commissions.Remove(commissions);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
                return false;
            }
        }
    }
}


//ExpenseService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Common.Utilities;
using RequestManagement.Server.Controllers;
using RequestManagement.Server.Data;
using System.Linq;

namespace RequestManagement.Server.Services
{
    public class ExpenseService(ApplicationDbContext dbContext) : IExpenseService
    {
        public readonly record struct NomenclatureKey(string Name, string Code, string Article, string UnitOfMeasure);

        public async Task<List<RequestManagement.Common.Models.Expense>> GetAllExpensesAsync(string filter, int requestWarehouseId, int requestEquipmentId, int requestDriverId,
            int requestDefectId, string requestFromDate, string requestToDate)
        {
            var query = dbContext.Expenses
                .Include(e => e.Stock)
                .ThenInclude(s => s.Nomenclature)
                .Include(e => e.Stock)
                .ThenInclude(s => s.Warehouse)
                .Include(e => e.Equipment)
                .Include(e => e.Driver)
                .Include(e => e.Defect)
                .ThenInclude(s => s.DefectGroup)
                .AsQueryable();

            if (!string.IsNullOrWhiteSpace(filter))
            {
                query = query.Where(e => EF.Functions.Like(e.Stock.Nomenclature.Name, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Article, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Code, $"%{filter}%"));
            }
            if (requestWarehouseId != 0)
            {
                query = query.Where(e => e.Stock.WarehouseId == requestWarehouseId);
            }
            if (requestEquipmentId != 0)
            {
                query = query.Where(e => e.EquipmentId == requestEquipmentId);
            }
            if (requestDriverId != 0)
            {
                query = query.Where(e => e.DriverId == requestDriverId);
            }
            if (requestDefectId != 0)
            {
                query = query.Where(e => e.DefectId == requestDefectId);
            }
            if (DateTime.TryParse(requestFromDate, out var fromDate) &&
                DateTime.TryParse(requestToDate, out var toDate))
            {
                query = query.Where(e => e.Date >= fromDate && e.Date < toDate.AddDays(1));
            }
            else
            {
                if (DateTime.TryParse(requestFromDate, out fromDate))
                {
                    query = query.Where(e => e.Date >= fromDate);
                }

                if (DateTime.TryParse(requestToDate, out toDate))
                {
                    query = query.Where(e => e.Date < toDate.AddDays(1));
                }
            }
            return await query.ToListAsync();
        }

        public async Task<bool> UploadMaterialsExpenseAsync(List<RequestManagement.Common.Models.MaterialExpense>? materials, int warehouseId)
        {

            if (materials == null || materials.Count == 0)
                return true;

            try
            {
                var driverCodes = materials.Select(m => m.DriverCode).Distinct().ToList();
                var equipmentCodes = materials.Select(m => m.EquipmentCode).Distinct().ToList();
                var nomenclatureKeys = materials
                    .Select(m => new NomenclatureKey(m.NomenclatureName, m.NomenclatureCode, m.NomenclatureArticle, m.NomenlatureUnitOfMeasure))
                    .Distinct()
                    .ToList();

                // Загружаем данные из базы одним запросом
                var existingDrivers = await dbContext.Drivers
                    .Where(d => driverCodes.Contains(d.Code))
                    .ToDictionaryAsync(d => d.Code);

                var existingEquipments = await dbContext.Equipments
                    .Where(e => equipmentCodes.Contains(e.Code))
                    .ToDictionaryAsync(e => e.Code);

                var existingStocks = await dbContext.Stocks
                    .Include(s => s.Nomenclature)
                    .Where(s => s.WarehouseId == warehouseId)
                    .ToListAsync();

                var stockMap = existingStocks
                    .Select(s => new
                    {
                        Stock = s,
                        Key = new NomenclatureKey(s.Nomenclature.Name, s.Nomenclature.Code, s.Nomenclature.Article!, s.Nomenclature.UnitOfMeasure)
                    })
                    .Where(x => nomenclatureKeys.Contains(x.Key))
                    .ToDictionary(x => x.Key, x => x.Stock);


                var nomenclatureIds = stockMap.Values.Select(s => s.NomenclatureId).Distinct().ToList();
                var defectMappings = await dbContext.NomenclatureDefectMappings
                    .Where(m => nomenclatureIds.Contains(m.NomenclatureId))
                    .ToDictionaryAsync(m => m.NomenclatureId, m => m.DefectId);

                // Подготовка к вставке
                var newDrivers = new List<RequestManagement.Common.Models.Driver>();
                var newEquipments = new List<RequestManagement.Common.Models.Equipment>();
                var newExpenses = new List<RequestManagement.Common.Models.Expense>();

                foreach (var material in materials)
                {
                    // Драйвер
                    if (!existingDrivers.TryGetValue(material.DriverCode, out var driver))
                    {
                        driver = new RequestManagement.Common.Models.Driver
                        {
                            Code = material.DriverCode,
                            FullName = material.DriverFullName,
                            Position = "",
                            ShortName = NameFormatter.FormatToShortName(material.DriverFullName)
                        };
                        newDrivers.Add(driver);
                        existingDrivers[driver.Code] = driver; // Добавляем в словарь, чтобы переиспользовать
                    }

                    // Оборудование
                    if (!existingEquipments.TryGetValue(material.EquipmentCode, out var equipment))
                    {
                        equipment = new RequestManagement.Common.Models.Equipment
                        {
                            Code = material.EquipmentCode,
                            Name = material.EquipmentName
                        };
                        newEquipments.Add(equipment);
                        existingEquipments[equipment.Code] = equipment;
                    }

                    // Склад
                    var key = new NomenclatureKey(
                        material.NomenclatureName,
                        material.NomenclatureCode,
                        material.NomenclatureArticle,
                        material.NomenlatureUnitOfMeasure);

                    if (!stockMap.TryGetValue(key, out var stock))
                        continue;

                    var defectId = defectMappings.TryGetValue(stock.NomenclatureId, out var id) ? id : 1;

                    var expense = new RequestManagement.Common.Models.Expense
                    {
                        Code = material.Number,
                        Date = material.Date,
                        Quantity = material.Quantity,
                        StockId = stock.Id,
                        Driver = driver,
                        Equipment = equipment,
                        DefectId = defectId
                    };
                    stock.ConsumedQuantity += expense.Quantity;
                    newExpenses.Add(expense);
                }

                // Добавляем новые сущности
                await dbContext.Drivers.AddRangeAsync(newDrivers);
                await dbContext.Equipments.AddRangeAsync(newEquipments);
                await dbContext.Expenses.AddRangeAsync(newExpenses);

                await dbContext.SaveChangesAsync();
                return true;
            }
            catch(Exception ex)
            {
                Console.WriteLine(ex.Message);
                return false;
            }
        }


        public async Task<Common.Models.Expense> CreateExpenseAsync(Common.Models.Expense expense)
        {
            try
            {
                if (expense == null) throw new ArgumentNullException(nameof(expense));

                // Проверка наличия записи в Stock
                var stock = await dbContext.Stocks
                    .FirstOrDefaultAsync(s => s.Id == expense.StockId);

                if (stock == null)
                {
                    throw new InvalidOperationException("Stock with the given ID does not exist.");
                }

                // Обновление ConsumedQuantity
                stock.ConsumedQuantity += expense.Quantity;

                dbContext.Expenses.Add(expense);
                await dbContext.SaveChangesAsync();

                return expense;
            }
            catch
            {
                return new RequestManagement.Common.Models.Expense();
            }

        }
        public async Task<bool> UpdateExpenseAsync(Common.Models.Expense expense)
        {
            if (expense == null) throw new ArgumentNullException(nameof(expense));

            var existingExpense = await dbContext.Expenses
                .FirstOrDefaultAsync(e => e.Id == expense.Id);

            if (existingExpense == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var oldStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == existingExpense.StockId);
            var newStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == expense.StockId);

            if (oldStock == null || newStock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }
            oldStock.ConsumedQuantity -= existingExpense.Quantity;
            newStock.ConsumedQuantity += expense.Quantity;

            existingExpense.StockId = expense.StockId;
            existingExpense.Quantity = expense.Quantity;
            existingExpense.EquipmentId = expense.EquipmentId;
            existingExpense.DriverId = expense.DriverId;
            existingExpense.DefectId = expense.DefectId;
            existingExpense.Date = expense.Date;

            await dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteExpenseAsync(int id)
        {
            var expense = await dbContext.Expenses
                .FirstOrDefaultAsync(e => e.Id == id);

            if (expense == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var stock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == expense.StockId);

            if (stock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }

            // Уменьшение ConsumedQuantity
            stock.ConsumedQuantity -= expense.Quantity;

            dbContext.Expenses.Remove(expense);
            await dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<UserLastSelection?> GetUserLastSelectionAsync(int userId)
        {
            return await dbContext.UserLastSelections
                .Include(s => s.Driver)
                .Include(s => s.Equipment)
                .FirstOrDefaultAsync(s => s.UserId == userId);
        }

        public async Task<NomenclatureDefectMapping?> GetLastNomenclatureDefectMappingAsync(int userId, int nomenclatureId)
        {
            return await dbContext.NomenclatureDefectMappings
                .Include(m => m.Nomenclature)
                .Include(m => m.Defect)
                .FirstOrDefaultAsync(m => m.UserId == userId && m.NomenclatureId == nomenclatureId);
        }

        public async Task SaveUserLastSelectionAsync(int userId, int? driverId, int? equipmentId)
        {
            var existing = await dbContext.UserLastSelections
                .FirstOrDefaultAsync(s => s.UserId == userId);

            if (existing == null)
            {
                existing = new UserLastSelection
                {
                    UserId = userId,
                    DriverId = driverId,
                    EquipmentId = equipmentId,
                    LastUpdated = DateTime.UtcNow
                };
                dbContext.UserLastSelections.Add(existing);
            }
            else
            {
                existing.DriverId = driverId;
                existing.EquipmentId = equipmentId;
                existing.LastUpdated = DateTime.UtcNow;
            }

            await dbContext.SaveChangesAsync();
        }

        public async Task SaveNomenclatureDefectMappingAsync(int userId, int stockId, int defectId)
        {
            var stock = await dbContext.Stocks.FirstOrDefaultAsync(x => x.Id == stockId);
            if(stock == null)return;
            var existing = await dbContext.NomenclatureDefectMappings
                .FirstOrDefaultAsync(m => m.UserId == userId && m.NomenclatureId == stock.NomenclatureId);

            if (existing == null)
            {
                existing = new NomenclatureDefectMapping
                {
                    UserId = userId,
                    NomenclatureId = stock.NomenclatureId,
                    DefectId = defectId,
                    LastUsed = DateTime.UtcNow
                };
                dbContext.NomenclatureDefectMappings.Add(existing);
            }
            else
            {
                existing.DefectId = defectId;
                existing.LastUsed = DateTime.UtcNow;
            }

            await dbContext.SaveChangesAsync();
        }

        public async Task<bool> DeleteExpensesAsync(List<int> requestIds)
        {
            var expenses = await dbContext.Expenses
                .Where(e => requestIds.Contains(e.Id))
                .Include(e => e.Stock)
                .ToListAsync();
            if (!expenses.Any())
            {
                return false;
            }

            foreach (var expense in expenses)
            {
                expense.Stock.ConsumedQuantity -= expense.Quantity;
            }
            dbContext.Expenses.RemoveRange(expenses);
            var deletedCount = await dbContext.SaveChangesAsync();
            return deletedCount > 0;
        }
    }
}


//IncomingService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Common.Utilities;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class IncomingService(ApplicationDbContext dbContext) : IIncomingService
    {
        public async Task<List<Incoming>> GetAllIncomingsAsync(string filter, int requestWarehouseId,  string requestFromDate, string requestToDate)
        {
            var query = dbContext.Incomings
                .Include(e => e.Stock)
                .ThenInclude(s => s.Nomenclature)
                .Include(e => e.Stock)
                .ThenInclude(s => s.Warehouse)
                .AsQueryable();

            if (!string.IsNullOrWhiteSpace(filter))
            {
                query = query.Where(e => EF.Functions.Like(e.Stock.Nomenclature.Name, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Article, $"%{filter}%") ||
                                         EF.Functions.Like(e.Stock.Nomenclature.Code, $"%{filter}%"));
            }
            if (requestWarehouseId != 0)
            {
                query = query.Where(e => e.Stock.WarehouseId == requestWarehouseId);
            }
            if (DateTime.TryParse(requestFromDate, out var fromDate) &&
                DateTime.TryParse(requestToDate, out var toDate))
            {
                query = query.Where(e => e.Date >= fromDate && e.Date < toDate.AddDays(1));
            }
            else
            {
                if (DateTime.TryParse(requestFromDate, out fromDate))
                {
                    query = query.Where(e => e.Date >= fromDate);
                }

                if (DateTime.TryParse(requestToDate, out toDate))
                {
                    query = query.Where(e => e.Date < toDate.AddDays(1));
                }
            }
            return await query.ToListAsync();
        }

        public async Task<bool> UploadIncomingsAsync(MaterialIncoming incoming)
        {
            if (incoming == null || incoming.Items == null || !incoming.Items.Any())
            {
                return false;
            }

            try
            {
                // 1. Проверяем/создаем склад
                var warehouse = await dbContext.Warehouses
                    .FirstOrDefaultAsync(w => w.Name == incoming.WarehouseName);

                if (warehouse == null)
                {
                    warehouse = new Warehouse
                    {
                        Name = incoming.WarehouseName,
                        Code = string.Empty,
                        LastUpdated = DateTime.UtcNow
                    };
                    dbContext.Warehouses.Add(warehouse);
                    await dbContext.SaveChangesAsync();
                }

                // 2. Подготавливаем словари для минимизации запросов
                var driverNames = incoming.Items
                    .Select(i => i.ApplicationResponsibleName)
                    .Where(name => !string.IsNullOrEmpty(name))
                    .Distinct()
                    .ToList();

                var equipmentCodes = incoming.Items
                    .Select(i => i.ApplicationEquipmentCode)
                    .Where(code => !string.IsNullOrEmpty(code))
                    .Distinct()
                    .ToList();

                var nomenclatureKeys = incoming.Items
                    .SelectMany(i => i.Items)
                    .Select(m => (m.Code, m.Article, m.ItemName, m.Unit))
                    .Distinct()
                    .ToList();

                // Загружаем существующие данные
                var existingDrivers = await dbContext.Drivers
                    .Where(d => driverNames.Contains(d.FullName))
                    .ToDictionaryAsync(d => d.FullName);

                var existingEquipments = await dbContext.Equipments
                    .Where(e => equipmentCodes.Contains(e.Code))
                    .ToDictionaryAsync(e => e.Code);

                var existingNomenclatures = await dbContext.Nomenclatures
                    .Where(n => nomenclatureKeys.Select(k => k.Code).Contains(n.Code) &&
                                nomenclatureKeys.Select(k => k.Article).Contains(n.Article) &&
                                nomenclatureKeys.Select(k => k.ItemName).Contains(n.Name) &&
                                nomenclatureKeys.Select(k => k.Unit).Contains(n.UnitOfMeasure))
                    .ToDictionaryAsync(n => (n.Code, n.Article, n.Name, n.UnitOfMeasure), n => n);

                var existingStocks = await dbContext.Stocks
                    .Where(s => s.WarehouseId == warehouse.Id)
                    .ToDictionaryAsync(s => (s.NomenclatureId, s.WarehouseId), s => s);

                // 3. Подготавливаем списки для новых сущностей
                var newDrivers = new List<Driver>();
                var newEquipments = new List<Equipment>();
                var newNomenclatures = new List<Nomenclature>();
                var newStocks = new List<Stock>();
                var newApplications = new List<Application>();
                var newIncomings = new List<Incoming>();

                foreach (var item in incoming.Items)
                {
                    // Проверяем, нужно ли создавать Application
                    Application? application = null;
                    if (!string.IsNullOrEmpty(item.ApplicationNumber) &&
                        !string.IsNullOrEmpty(item.ApplicationDate))
                    {
                        if (!DateTime.TryParse(item.ApplicationDate, out var applicationDate))
                        {
                            continue; // Пропускаем, если дата некорректна
                        }

                        // Проверяем существование Application
                        application = await dbContext.Applications
                            .FirstOrDefaultAsync(a => a.Number == item.ApplicationNumber && a.Date == applicationDate);

                        if (application == null)
                        {
                            // Создаем Driver, если указано имя
                            int responsibleId = 1; // ID по умолчанию
                            if (!string.IsNullOrEmpty(item.ApplicationResponsibleName))
                            {
                                if (!existingDrivers.TryGetValue(item.ApplicationResponsibleName, out var responsible))
                                {
                                    responsible = new Driver
                                    {
                                        Code = string.Empty,
                                        FullName = item.ApplicationResponsibleName,
                                        ShortName = NameFormatter.FormatToShortName(item.ApplicationResponsibleName),
                                        Position = string.Empty
                                    };
                                    newDrivers.Add(responsible);
                                    existingDrivers[responsible.FullName] = responsible;
                                }
                                responsibleId = responsible.Id;
                            }

                            // Создаем Equipment, если указан код
                            int equipmentId = 1; // ID по умолчанию
                            if (!string.IsNullOrEmpty(item.ApplicationEquipmentCode))
                            {
                                if (!existingEquipments.TryGetValue(item.ApplicationEquipmentCode, out var equipment))
                                {
                                    equipment = new Equipment
                                    {
                                        Code = item.ApplicationEquipmentCode,
                                        Name = item.ApplicationEquipmentName ?? string.Empty,
                                        StateNumber = string.Empty
                                    };
                                    newEquipments.Add(equipment);
                                    existingEquipments[equipment.Code] = equipment;
                                }
                                equipmentId = equipment.Id;
                            }

                            // Создаем новую Application
                            application = new Application
                            {
                                Number = item.ApplicationNumber,
                                Date = applicationDate,
                                ResponsibleId = responsibleId,
                                EquipmentId = equipmentId
                            };
                            newApplications.Add(application);
                        }
                    }

                    // Обрабатываем элементы MaterialStock
                    foreach (var material in item.Items)
                    {
                        // Проверяем/создаем Nomenclature
                        var nomenclatureKey = (material.Code, material.Article, material.ItemName, material.Unit);
                        if (!existingNomenclatures.TryGetValue(nomenclatureKey, out var nomenclature))
                        {
                            nomenclature = new Nomenclature
                            {
                                Code = material.Code,
                                Name = material.ItemName,
                                Article = material.Article,
                                UnitOfMeasure = material.Unit
                            };
                            newNomenclatures.Add(nomenclature);
                            existingNomenclatures[nomenclatureKey] = nomenclature;
                        }

                        // Проверяем/создаем Stock
                        var stockKey = (nomenclature.Id, warehouse.Id);
                        if (!existingStocks.TryGetValue(stockKey, out var stock))
                        {
                            stock = new Stock
                            {
                                WarehouseId = warehouse.Id,
                                NomenclatureId = nomenclature.Id,
                                InitialQuantity = 0,
                                ReceivedQuantity = 0,
                                ConsumedQuantity = 0
                            };
                            newStocks.Add(stock);
                            existingStocks[stockKey] = stock;
                        }

                        // Определяем Code и Date для Incoming
                        string incomingCode;
                        DateTime incomingDate;
                        if (!string.IsNullOrEmpty(item.ReceiptOrderNumber) &&
                            !string.IsNullOrEmpty(item.ReceiptOrderDate) &&
                            DateTime.TryParse(item.ReceiptOrderDate, out var receiptOrderDate))
                        {
                            incomingCode = item.ReceiptOrderNumber;
                            incomingDate = receiptOrderDate;
                        }
                        else
                        {
                            incomingCode = item.RegistratorNumber;
                            incomingDate = DateTime.TryParse(item.RegistratorDate, out var registratorDate)
                                ? registratorDate
                                : DateTime.UtcNow;
                        }

                        // Создаем Incoming
                        var incomingEntry = new Incoming
                        {
                            StockId = stock.Id,
                            Quantity = (decimal)material.FinalBalance,
                            Date = incomingDate,
                            Code = incomingCode,
                            ApplicationId = application?.Id ?? 1 // Используем ID по умолчанию, если application не создана
                        };
                        stock.ReceivedQuantity += incomingEntry.Quantity;
                        newIncomings.Add(incomingEntry);
                    }
                }

                // Пакетное добавление новых сущностей
                if (newDrivers.Any())
                {
                    await dbContext.Drivers.AddRangeAsync(newDrivers);
                }
                if (newEquipments.Any())
                {
                    await dbContext.Equipments.AddRangeAsync(newEquipments);
                }
                if (newNomenclatures.Any())
                {
                    await dbContext.Nomenclatures.AddRangeAsync(newNomenclatures);
                }
                if (newStocks.Any())
                {
                    await dbContext.Stocks.AddRangeAsync(newStocks);
                }
                if (newApplications.Any())
                {
                    await dbContext.Applications.AddRangeAsync(newApplications);
                }
                if (newIncomings.Any())
                {
                    await dbContext.Incomings.AddRangeAsync(newIncomings);
                }

                // Сохраняем изменения
                await dbContext.SaveChangesAsync();
                return true;
            }
            catch (Exception ex)
            {
                // Логирование ошибки (предполагается использование ILogger)
                Console.WriteLine($"Error in UploadIncomingsAsync: {ex.Message}");
                return false;
            }
        }

        public async Task<Incoming> CreateIncomingAsync(Incoming incoming)
        {
            try
            {
                if (incoming == null) throw new ArgumentNullException(nameof(incoming));

                // Проверка наличия записи в Stock
                var stock = await dbContext.Stocks
                    .FirstOrDefaultAsync(s => s.Id == incoming.StockId);

                if (stock == null)
                {
                    throw new InvalidOperationException("Stock with the given ID does not exist.");
                }

                // Обновление ReceivedQuantity
                stock.ReceivedQuantity += incoming.Quantity;

                dbContext.Incomings.Add(incoming);
                await dbContext.SaveChangesAsync();

                return incoming;
            }
            catch
            {
                return new Incoming();
            }

        }
        public async Task<bool> UpdateIncomingAsync(Incoming incoming)
        {
            if (incoming == null) throw new ArgumentNullException(nameof(incoming));

            var existingIncoming = await dbContext.Incomings
                .FirstOrDefaultAsync(e => e.Id == incoming.Id);

            if (existingIncoming == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var oldStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == existingIncoming.StockId);
            var newStock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == incoming.StockId);

            if (oldStock == null || newStock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }
            oldStock.ReceivedQuantity -= existingIncoming.Quantity;
            newStock.ReceivedQuantity += incoming.Quantity;

            existingIncoming.StockId = incoming.StockId;
            existingIncoming.Quantity = incoming.Quantity;
            existingIncoming.Date = incoming.Date;

            await dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteIncomingAsync(int id)
        {
            var incoming = await dbContext.Incomings
                .FirstOrDefaultAsync(e => e.Id == id);

            if (incoming == null)
            {
                return false;
            }

            // Проверка наличия записи в Stock
            var stock = await dbContext.Stocks
                .FirstOrDefaultAsync(s => s.Id == incoming.StockId);

            if (stock == null)
            {
                throw new InvalidOperationException("Stock with the given ID does not exist.");
            }

            // Уменьшение ReceivedQuantity
            stock.ReceivedQuantity -= incoming.Quantity;

            dbContext.Incomings.Remove(incoming);
            await dbContext.SaveChangesAsync();
            return true;
        }

     

        public async Task<bool> DeleteIncomingsAsync(List<int> requestIds)
        {
            var incomings = await dbContext.Incomings
                .Where(e => requestIds.Contains(e.Id))
                .Include(e => e.Stock)
                .ToListAsync();
            if (!incomings.Any())
            {
                return false;
            }

            foreach (var incoming in incomings)
            {
                incoming.Stock.ReceivedQuantity -= incoming.Quantity;
            }
            dbContext.Incomings.RemoveRange(incomings);
            var deletedCount = await dbContext.SaveChangesAsync();
            return deletedCount > 0;
        }
    }
}


//NomenclatureAnalogService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class NomenclatureAnalogService(ApplicationDbContext dbContext) : INomenclatureAnalogService
    {
        private readonly ApplicationDbContext _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        public async Task<List<Nomenclature>> GetAllNomenclatureAnalogsAsync(int filter)
        {
            try
            {
                var allAnalogIds = await GetTransitiveAnalogIdsAsync(filter);
                return await _dbContext.Nomenclatures
                    .Where(n => allAnalogIds.Contains(n.Id) && n.Id != filter)
                    .Distinct()
                    .ToListAsync();
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                return [];
            }
        }
        private async Task<HashSet<int>> GetTransitiveAnalogIdsAsync(int startId)
        {
            var result = new HashSet<int>();
            var queue = new Queue<int>();
            queue.Enqueue(startId);

            while (queue.Count > 0)
            {
                var currentId = queue.Dequeue();

                // Находим все связанные ID (как оригиналы, так и аналоги)
                var relatedIds = await _dbContext.NomenclatureAnalogs
                    .Where(x => x.AnalogId == currentId || x.OriginalId == currentId)
                    .Select(x => x.OriginalId == currentId ? x.AnalogId : x.OriginalId)
                    .Distinct()
                    .ToListAsync();

                foreach (var id in relatedIds.Where(id => id != currentId && !result.Contains(id)))
                {
                    result.Add(id);
                    queue.Enqueue(id);
                }
            }

            return result;
        }
        public async Task<int> AddNomenclatureAnalogAsync(NomenclatureAnalog nomenclatureAnalog)
        {
            try
            {
                var result = await _dbContext.NomenclatureAnalogs.Where(x => (x.AnalogId == nomenclatureAnalog.AnalogId && x.OriginalId == nomenclatureAnalog.OriginalId) || (x.AnalogId == nomenclatureAnalog.OriginalId && x.OriginalId == nomenclatureAnalog.AnalogId)).FirstOrDefaultAsync();
                if (result != null) return result.Id;
                _dbContext.NomenclatureAnalogs.Add(nomenclatureAnalog);
                await _dbContext.SaveChangesAsync();
                return nomenclatureAnalog.Id;
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                return 0;
            }
        }

        public async Task<bool> DeleteNomenclatureAnalogAsync(int originalId, int analogId)
        {
            try
            {
                var result = await _dbContext.NomenclatureAnalogs.Where(x => (x.AnalogId == analogId && x.OriginalId == originalId) || (x.AnalogId == originalId && x.OriginalId == analogId)).FirstOrDefaultAsync();
                if (result == null) return true;
                _dbContext.NomenclatureAnalogs.Remove(result);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                return false;
            }
        }
    }
}


//RequestService.cs


using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class RequestService(ApplicationDbContext dbContext) : IRequestService
    {
        private readonly ApplicationDbContext _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));

        public async Task<int> CreateEquipmentAsync(Equipment equipment)
        {
            _dbContext.Equipments.Add(equipment);
            await _dbContext.SaveChangesAsync();
            return equipment.Id;
        }

        public async Task<bool> UpdateEquipmentAsync(Equipment equipment)
        {
            var existingEquipment = await _dbContext.Equipments
                .FirstOrDefaultAsync(e => e.Id == equipment.Id);

            if (existingEquipment == null)
                return false;

            existingEquipment.Name = equipment.Name;
            existingEquipment.StateNumber = equipment.StateNumber;

            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteEquipmentAsync(int id)
        {
            try
            {
                var equipment = await _dbContext.Equipments
                .FirstOrDefaultAsync(e => e.Id == id);

                if (equipment == null)
                    return false;

                _dbContext.Equipments.Remove(equipment);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<Equipment>> GetAllEquipmentAsync(string filter = "")
        {
            var query = _dbContext.Equipments.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase) || e.StateNumber!.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Equipment
                {
                    Id = e.Id,
                    Name = e.Name,
                    StateNumber = e.StateNumber ?? ""
                })
                .ToListAsync();
        }

        public async Task<List<Driver>> GetAllDriversAsync(string filter = "")
        {
            var query = _dbContext.Drivers.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.FullName.ToLower().Contains(phrase) || e.Position.ToLower().Contains(phrase)));
            }
            query = query.Where(e => e.Id != 1);
            return await query
                .Select(e => new Driver
                {
                    Id = e.Id,
                    FullName = e.FullName,
                    ShortName = e.ShortName,
                    Position = e.Position
                })
                .ToListAsync();
        }

        public async Task<int> CreateDriverAsync(Driver driver)
        {
            _dbContext.Drivers.Add(driver);
            await _dbContext.SaveChangesAsync();
            return driver.Id;
        }

        public async Task<bool> UpdateDriverAsync(Driver driver)
        {
            if(driver.Id == 1)return true;
            var existDriver = await _dbContext.Drivers
                .FirstOrDefaultAsync(e => e.Id == driver.Id);

            if (existDriver == null)
                return false;

            existDriver.FullName = driver.FullName;
            existDriver.ShortName = driver.ShortName;
            existDriver.Position = driver.Position;

            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteDriverAsync(int id)
        {
            try
            {
                if (id == 1) return true;
                var driver = await _dbContext.Drivers
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (driver == null)
                    return false;

                _dbContext.Drivers.Remove(driver);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<DefectGroup>> GetAllDefectGroupsAsync(string filter = "")
        {
            var query = _dbContext.DefectGroups.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new DefectGroup
                {
                    Id = e.Id,
                    Name = e.Name,
                })
                .ToListAsync();
        }
        public async Task<int> CreateDefectGroupAsync(DefectGroup defectGroup)
        {
            _dbContext.DefectGroups.Add(defectGroup);
            await _dbContext.SaveChangesAsync();
            return defectGroup.Id;
        }
        public async Task<bool> UpdateDefectGroupAsync(DefectGroup defectGroup)
        {
            var existDefectGroup = await _dbContext.DefectGroups
                .FirstOrDefaultAsync(e => e.Id == defectGroup.Id);

            if (existDefectGroup == null)
                return false;

            existDefectGroup.Name = defectGroup.Name;
            await _dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteDefectGroupAsync(int id)
        {
            try
            {
                var defectGroup = await _dbContext.DefectGroups
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (defectGroup == null)
                    return false;

                _dbContext.DefectGroups.Remove(defectGroup);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<Defect>> GetAllDefectsAsync(string filter = "")
        {
            var query = _dbContext.Defects.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase) || e.DefectGroup.Name.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Defect
                {
                    Id = e.Id,
                    Name = e.Name,
                    DefectGroupId = e.DefectGroupId
                })
                .ToListAsync();
        }

        public async Task<int> CreateDefectAsync(Defect defect)
        {
            _dbContext.Defects.Add(defect);
            await _dbContext.SaveChangesAsync();
            return defect.Id;
        }
        public async Task<bool> UpdateDefectAsync(Defect defect)
        {
            var existDefect = await _dbContext.Defects
                .FirstOrDefaultAsync(e => e.Id == defect.Id);

            if (existDefect == null)
                return false;

            existDefect.Name = defect.Name;
            existDefect.DefectGroupId = defect.DefectGroupId;
            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteDefectAsync(int id)
        {
            try
            {
                var defect = await _dbContext.Defects
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (defect == null)
                    return false;

                _dbContext.Defects.Remove(defect);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }

        public async Task<List<Nomenclature>> GetAllNomenclaturesAsync(string filter = "")
        {
            var query = _dbContext.Nomenclatures.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase) || e.Article.ToLower().Contains(phrase) || e.Code.ToLower().Contains(phrase) || e.UnitOfMeasure.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Nomenclature
                {
                    Id = e.Id,
                    Name = e.Name,
                    Article = e.Article,
                    Code = e.Code,
                    UnitOfMeasure = e.UnitOfMeasure
                })
                .ToListAsync();
        }

        public async Task<int> CreateNomenclatureAsync(Nomenclature nomenclature)
        {
            _dbContext.Nomenclatures.Add(nomenclature);
            await _dbContext.SaveChangesAsync();
            return nomenclature.Id;
        }

        public async Task<bool> UpdateNomenclatureAsync(Nomenclature nomenclature)
        {
            var existNomenclature = await _dbContext.Nomenclatures
                .FirstOrDefaultAsync(e => e.Id == nomenclature.Id);

            if (existNomenclature == null)
                return false;

            existNomenclature.Name = nomenclature.Name;
            existNomenclature.Article = nomenclature.Article;
            existNomenclature.Code = nomenclature.Code;
            existNomenclature.UnitOfMeasure = nomenclature.UnitOfMeasure;
            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteNomenclatureAsync(int id)
        {
            try
            {
                var nomenclature = await _dbContext.Nomenclatures
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (nomenclature == null)
                    return false;

                _dbContext.Nomenclatures.Remove(nomenclature);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}

//StockService.cs
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;
using WpfClient.Models;
using EFCore.BulkExtensions;
using Windows.UI;

namespace RequestManagement.Server.Services
{
    public class StockService(ApplicationDbContext dbContext) : IStockService
    {
        private readonly ApplicationDbContext _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        private static IQueryable<Stock> ApplyQuantityFilter(
            IQueryable<Stock> query,
            Expression<Func<Stock, decimal>> quantitySelector,
            Helpers.QuantityFilter? filter)
        {
            if (filter is null) return query;

            return filter.Operator switch
            {
                Helpers.ComparisonOperator.GreaterThan => query.Where(BuildComparisonExpression(quantitySelector, filter.Value, ">")),
                Helpers.ComparisonOperator.EqualTo => query.Where(BuildComparisonExpression(quantitySelector, filter.Value, "==")),
                Helpers.ComparisonOperator.LessThan => query.Where(BuildComparisonExpression(quantitySelector, filter.Value, "<")),
                _ => query // Невозможный случай, если enum ограничен
            };
        }
        private static Expression<Func<Stock, bool>> BuildComparisonExpression(
            Expression<Func<Stock, decimal>> quantitySelector,
            decimal value,
            string comparisonOperator)
        {
            var parameter = quantitySelector.Parameters[0];
            var constant = Expression.Constant(value, typeof(decimal));

            var comparison = comparisonOperator switch
            {
                ">" => Expression.GreaterThan(quantitySelector.Body, constant),
                "==" => Expression.Equal(quantitySelector.Body, constant),
                "<" => Expression.LessThan(quantitySelector.Body, constant),
                _ => throw new ArgumentException("Неподдерживаемый оператор сравнения")
            };

            return Expression.Lambda<Func<Stock, bool>>(comparison, parameter);
        }

        public async Task<List<Stock>> GetAllStocksAsync(
            int warehouseId,
            string filter = "",
            int initialQuantityFilterType = 0,
            double initialQuantity = 0,
            int receivedQuantityFilterType = 0,
            double receivedQuantity = 0,
            int consumedQuantityFilterType = 0,
            double consumedQuantity = 0,
            int finalQuantityFilterType = 0,
            double finalQuantity = 0
            )
        {
            var query = _dbContext.Stocks
                .AsQueryable()
                .Where(s => s.WarehouseId == warehouseId);
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) =>
                    current.Where(s => EF.Functions.ILike(s.Nomenclature.Name, $"%{phrase}%") ||
                                       EF.Functions.ILike(s.Nomenclature.Article, $"%{phrase}%") ||
                                       EF.Functions.ILike(s.Nomenclature.Code, $"%{phrase}%")));
            }
            query = ApplyQuantityFilter(query, s => s.InitialQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)initialQuantity, initialQuantityFilterType));
            query = ApplyQuantityFilter(query, s => s.ReceivedQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)receivedQuantity, receivedQuantityFilterType));
            query = ApplyQuantityFilter(query, s => s.ConsumedQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)consumedQuantity, consumedQuantityFilterType));
            query = ApplyQuantityFilter(query, s => s.InitialQuantity + s.ReceivedQuantity - s.ConsumedQuantity, Helpers.QuantityFilter.GetQuantityFilter((decimal)finalQuantity, finalQuantityFilterType));
            return await query
                .Select(s => new Stock
                {
                    Id = s.Id,
                    NomenclatureId = s.NomenclatureId,
                    WarehouseId = s.WarehouseId,
                    InitialQuantity = s.InitialQuantity,
                    ReceivedQuantity = s.ReceivedQuantity,
                    ConsumedQuantity = s.ConsumedQuantity,
                    Nomenclature = s.Nomenclature
                })
                .ToListAsync();
        }

        public async Task<bool> UploadMaterialsStockAsync(List<MaterialStock> materials, int warehouseId, DateTime date)
        {
            if (materials == null || !materials.Any())
            {
                return false;
            }

            try
            {
                // Получаем существующие номенклатуры и склады
                var existingNomenclatures = await _dbContext.Nomenclatures
                    .Where(n => materials.Select(m => m.Code).Contains(n.Code) &&
                                materials.Select(m => m.Article).Contains(n.Article) &&
                                materials.Select(m => m.ItemName).Contains(n.Name) &&
                                materials.Select(m => m.Unit).Contains(n.UnitOfMeasure))
                    .ToDictionaryAsync(n => (n.Code, n.Article, n.Name, n.UnitOfMeasure), n => n.Id);

                var warehouseExists = await _dbContext.Warehouses.AnyAsync(w => w.Id == warehouseId);
                if (!warehouseExists)
                {
                    return false;
                }

                // Получаем существующие записи Stock для указанного склада
                var existingStocks = await _dbContext.Stocks
                    .Include(s => s.Nomenclature)
                    .Where(s => s.WarehouseId == warehouseId)
                    .ToDictionaryAsync(s => (s.NomenclatureId, s.WarehouseId), s => s);

                // Подготавливаем данные для обновления или создания
                var stocksToAdd = new List<Stock>();
                var stocksToUpdate = new List<Stock>();

                foreach (var material in materials)
                {
                    // Проверяем, существует ли номенклатура
                    var nomenclatureKey = (material.Code, material.Article, material.ItemName, material.Unit);
                    if (!existingNomenclatures.TryGetValue(nomenclatureKey, out var nomenclatureId))
                    {
                        // Создаем новую номенклатуру, если не существует
                        var newNomenclature = new Nomenclature
                        {
                            Code = material.Code,
                            Name = material.ItemName,
                            Article = material.Article,
                            UnitOfMeasure = material.Unit
                        };
                        _dbContext.Nomenclatures.Add(newNomenclature);
                        await _dbContext.SaveChangesAsync();
                        nomenclatureId = newNomenclature.Id;
                        existingNomenclatures[nomenclatureKey] = nomenclatureId;
                    }

                    var stockKey = (nomenclatureId, warehouseId);
                    if (existingStocks.TryGetValue(stockKey, out var existingStock))
                    {
                        // Обновляем существующую запись
                        existingStock.InitialQuantity = (decimal)material.FinalBalance;

                        // Пересчитываем ReceivedQuantity и ConsumedQuantity
                        var receivedQuantity = await _dbContext.Incomings
                            .Where(i => i.StockId == existingStock.Id && i.Date >= date)
                            .SumAsync(i => i.Quantity);

                        var consumedQuantity = await _dbContext.Expenses
                            .Where(e => e.StockId == existingStock.Id && e.Date >= date)
                            .SumAsync(e => e.Quantity);

                        existingStock.ReceivedQuantity = receivedQuantity;
                        existingStock.ConsumedQuantity = consumedQuantity;

                        stocksToUpdate.Add(existingStock);
                    }
                    else
                    {
                        // Создаем новую запись
                        var newStock = new Stock
                        {
                            WarehouseId = warehouseId,
                            NomenclatureId = nomenclatureId,
                            InitialQuantity = (decimal)material.FinalBalance,
                            ReceivedQuantity = 0,
                            ConsumedQuantity = 0
                        };
                        stocksToAdd.Add(newStock);
                    }
                }

                // Пакетное добавление новых записей
                if (stocksToAdd.Any())
                {
                    await _dbContext.Stocks.AddRangeAsync(stocksToAdd);
                }

                // Пакетное обновление существующих записей
                if (stocksToUpdate.Any())
                {
                    _dbContext.Stocks.UpdateRange(stocksToUpdate);
                }

                // Сохраняем изменения
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch (Exception ex)
            {
                // Логирование ошибки (предполагается, что используется ILogger)
                return false;
            }
        }

        public async Task<int> CreateStockAsync(Stock stock)
        {
            _dbContext.Stocks.Add(stock);
            await _dbContext.SaveChangesAsync();
            return stock.Id;
        }

        public async Task<bool> UpdateStockAsync(Stock stock)
        {
            var existingStock = await _dbContext.Stocks.FirstOrDefaultAsync(e => e.Id == stock.Id);
            if (existingStock == null)
                return false;
            existingStock.NomenclatureId = stock.NomenclatureId;
            existingStock.InitialQuantity = stock.InitialQuantity;
            await _dbContext.SaveChangesAsync();
            return true;
        }
        public async Task<bool> DeleteStockAsync(int id)
        {
            try
            {
                var stock = await _dbContext.Stocks.FirstOrDefaultAsync(e => e.Id == id);
                if (stock == null)
                    return false;
                _dbContext.Stocks.Remove(stock);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}


//UserService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;
using RequestManagement.Common.Models.Enums;

namespace RequestManagement.Server.Services
{
    /// <summary>
    /// Сервис для работы с пользователями
    /// </summary>
    public class UserService : IUserService
    {
        private readonly ApplicationDbContext _dbContext;

        public UserService(ApplicationDbContext dbContext)
        {
            _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        }

        /// <summary>
        /// Создает нового пользователя
        /// </summary>
        public async Task<int> CreateUserAsync(User user)
        {
            if (user == null)
                throw new ArgumentNullException(nameof(user));

            // Проверка на уникальность логина
            if (await _dbContext.Users.AnyAsync(u => u.Login == user.Login))
                throw new InvalidOperationException($"User with login '{user.Login}' already exists");

            // Хэшируем пароль перед сохранением
            user.Password = BCrypt.Net.BCrypt.HashPassword(user.Password);

            _dbContext.Users.Add(user);
            await _dbContext.SaveChangesAsync();
            return user.Id;
        }

        /// <summary>
        /// Обновляет данные пользователя
        /// </summary>
        public async Task<bool> UpdateUserAsync(User user)
        {
            if (user == null)
                throw new ArgumentNullException(nameof(user));

            var existingUser = await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == user.Id);

            if (existingUser == null)
                return false;

            // Проверка на уникальность логина (исключая текущего пользователя)
            if (await _dbContext.Users.AnyAsync(u => u.Login == user.Login && u.Id != user.Id))
                throw new InvalidOperationException($"Login '{user.Login}' is already taken by another user");

            existingUser.Login = user.Login;
            // Хэшируем новый пароль только если он изменился
            if (existingUser.Password != user.Password)
            {
                existingUser.Password = BCrypt.Net.BCrypt.HashPassword(user.Password);
            }
            existingUser.Role = user.Role;

            await _dbContext.SaveChangesAsync();
            return true;
        }

        /// <summary>
        /// Удаляет пользователя по идентификатору
        /// </summary>
        public async Task<bool> DeleteUserAsync(int userId)
        {
            var user = await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == userId);

            if (user == null)
                return false;

            _dbContext.Users.Remove(user);
            await _dbContext.SaveChangesAsync();
            return true;
        }

        /// <summary>
        /// Получает пользователя по идентификатору
        /// </summary>
        public async Task<User> GetUserByIdAsync(int userId)
        {
            return await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == userId);
        }

        /// <summary>
        /// Получает пользователя по логину
        /// </summary>
        public async Task<User> GetUserByLoginAsync(string login)
        {
            if (string.IsNullOrWhiteSpace(login))
                throw new ArgumentException("Login cannot be null or empty", nameof(login));

            return await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Login == login);
        }

        /// <summary>
        /// Проверяет, имеет ли пользователь указанную роль
        /// </summary>
        public async Task<bool> HasRoleAsync(int userId, UserRole role)
        {
            var user = await _dbContext.Users
                .FirstOrDefaultAsync(u => u.Id == userId);

            return user != null && user.Role == role;
        }
    }
}

//WarehouseService.cs
using Microsoft.EntityFrameworkCore;
using RequestManagement.Common.Interfaces;
using RequestManagement.Common.Models;
using RequestManagement.Server.Data;

namespace RequestManagement.Server.Services
{
    public class WarehouseService(ApplicationDbContext dbContext) : IWarehouseService
    {
        private readonly ApplicationDbContext _dbContext =
            dbContext ?? throw new ArgumentNullException(nameof(dbContext));

        public async Task<List<Warehouse>> GetAllWarehousesAsync(string filter = "")
        {
            var query = _dbContext.Warehouses.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var phrases = filter.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                query = phrases.Aggregate(query, (current, phrase) => current.Where(e => e.Name.ToLower().Contains(phrase)));
            }
            return await query
                .Select(e => new Warehouse
                {
                    Id = e.Id,
                    Name = e.Name,
                    LastUpdated = e.LastUpdated,
                    Code = e.Code
                })
                .ToListAsync();
        }

        public async Task<Warehouse> GetOrCreateWarehousesAsync(string filter)
        {
            var query = _dbContext.Warehouses.AsQueryable();
            if (!string.IsNullOrWhiteSpace(filter))
            {
                var normalizedFilter = filter.Trim().ToLower();
                query = query.Where(e => e.Name.ToLower() == normalizedFilter);
            }
            var result = await query
                .Select(e => new Warehouse
                {
                    Id = e.Id,
                    Name = e.Name,
                    LastUpdated = e.LastUpdated,
                    Code = e.Code
                })
                .ToListAsync();
            if (result.Count != 0) return result[0];
            var newWarehouse = new Warehouse { Name = filter, LastUpdated = DateTime.Now };
            await _dbContext.Warehouses.AddAsync(newWarehouse);
            await _dbContext.SaveChangesAsync();
            return newWarehouse;
        }

        public async Task<int> CreateWarehouseAsync(Warehouse warehouse)
        {
            _dbContext.Warehouses.Add(warehouse);
            await _dbContext.SaveChangesAsync();
            return warehouse.Id;
        }

        public async Task<bool> UpdateWarehouseAsync(Warehouse warehouse)
        {
            var existWarehouse = await _dbContext.Warehouses
                .FirstOrDefaultAsync(e => e.Id == warehouse.Id);

            if (existWarehouse == null)
                return false;

            existWarehouse.Name = warehouse.Name;
            existWarehouse.LastUpdated = warehouse.LastUpdated;
            await _dbContext.SaveChangesAsync();
            return true;
        }

        public async Task<bool> DeleteWarehouseAsync(int id)
        {
            try
            {
                var warehouse = await _dbContext.Warehouses
                    .FirstOrDefaultAsync(e => e.Id == id);

                if (warehouse == null)
                    return false;

                _dbContext.Warehouses.Remove(warehouse);
                await _dbContext.SaveChangesAsync();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}


